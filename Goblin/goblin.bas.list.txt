------- FILE C:\Users\Daniele\Documents\GitHub\atari-goblin\Goblin\goblin.bas.asm LEVEL 1 PASS 3
      1  8400					      processor	6502
------- FILE vcs.h LEVEL 2 PASS 3
      0  8400 ????				      include	"vcs.h"
      1  8400 ????						; VCS.H
      2  8400 ????						; Version 1.05, 13/November/2003
      3  8400 ????
      4  8400 ????	       00 69	   VERSION_VCS =	105
      5  8400 ????
      6  8400 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      7  8400 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  8400 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
      9  8400 ????						;
     10  8400 ????						; This file defines hardware registers and memory mapping for the
     11  8400 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     12  8400 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  8400 ????						; available at at http://www.atari2600.org/dasm
     14  8400 ????						;
     15  8400 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     16  8400 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     17  8400 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     18  8400 ????						; with your views.  Please contribute, if you think you can improve this
     19  8400 ????						; file!
     20  8400 ????						;
     21  8400 ????						; Latest Revisions...
     22  8400 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     23  8400 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     24  8400 ????						;			    This will allow conditional code to verify VCS.H being
     25  8400 ????						;			    used for code assembly.
     26  8400 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     27  8400 ????						;			 convenient disassembly/reassembly compatibility for hardware
     28  8400 ????						;			 mirrored reading/writing differences.	This is more a
     29  8400 ????						;			 readability issue, and binary compatibility with disassembled
     30  8400 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     31  8400 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     32  8400 ????						;			 which was broken by the use of segments in this file, as
     33  8400 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     34  8400 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     35  8400 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     36  8400 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     37  8400 ????						;						   it is safe to leave it undefined, and the base address will
     38  8400 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     39  8400 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     40  8400 ????						;			  - register definitions are now generated through assignment
     41  8400 ????						;			    in uninitialised segments.	This allows a changeable base
     42  8400 ????						;			    address architecture.
     43  8400 ????						; 1.0	22/MAR/2003		Initial release
     44  8400 ????
     45  8400 ????
     46  8400 ????						;-------------------------------------------------------------------------------
     47  8400 ????
     48  8400 ????						; TIA_BASE_ADDRESS
     49  8400 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     50  8400 ????						; Normally 0, the base address should (externally, before including this file)
     51  8400 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     52  8400 ????						; The reason is that this bankswitching scheme treats any access to locations
     53  8400 ????						; < $40 as a bankswitch.
     54  8400 ????
     55  8400 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     56  8400 ????			  -TIA_BASE_ADDRESS =	0
     57  8400 ????				      ENDIF
     58  8400 ????
     59  8400 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     60  8400 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     61  8400 ????						; *OR* by declaring the label before including this file, eg:
     62  8400 ????						; TIA_BASE_ADDRESS = $40
     63  8400 ????						;   include "vcs.h"
     64  8400 ????
     65  8400 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     66  8400 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     67  8400 ????						; for the mirrored ROM hardware registers.
     68  8400 ????
     69  8400 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     70  8400 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     71  8400 ????						; they defaut to the TIA_BASE_ADDRESS.
     72  8400 ????
     73  8400 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     74  8400 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     75  8400 ????				      ENDIF
     76  8400 ????
     77  8400 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     78  8400 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     79  8400 ????				      ENDIF
     80  8400 ????
     81  8400 ????						;-------------------------------------------------------------------------------
     82  8400 ????
     83 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     84 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     85 U0000
     86 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     87 U0000
     88 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     89 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     90 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     91 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     92 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     93 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     94 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     95 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     96 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     97 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     98 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     99 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    100 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    101 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    102 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    103 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    104 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    105 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    106 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    107 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    108 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    109 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    110 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    111 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    112 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    113 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    114 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    115 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    116 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    117 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    118 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    119 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    120 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    121 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    122 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    123 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    124 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    125 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    126 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    127 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    128 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    129 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    130 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    131 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    132 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    133 U002d
    134 U002d							;-------------------------------------------------------------------------------
    135 U002d
    136 U000e ????				      SEG.U	TIA_REGISTERS_READ
    137 U0000					      ORG	TIA_BASE_READ_ADDRESS
    138 U0000
    139 U0000							;											bit 7	 bit 6
    140 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    141 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    142 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    143 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    144 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    145 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    146 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    147 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    148 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    149 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    150 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    151 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    152 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    153 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    154 U000e
    155 U000e							;-------------------------------------------------------------------------------
    156 U000e
    157 U0298 ????				      SEG.U	RIOT
    158 U0280					      ORG	$280
    159 U0280
    160 U0280							; RIOT MEMORY MAP
    161 U0280
    162 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    163 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    164 U0281
    165 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    166 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    167 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    168 U0284		       00	   INTIM      ds	1	; $284		Timer output
    169 U0285
    170 U0285		       00	   TIMINT     ds	1	; $285
    171 U0286
    172 U0286							; Unused/undefined registers ($285-$294)
    173 U0286
    174 U0286		       00		      ds	1	; $286
    175 U0287		       00		      ds	1	; $287
    176 U0288		       00		      ds	1	; $288
    177 U0289		       00		      ds	1	; $289
    178 U028a		       00		      ds	1	; $28A
    179 U028b		       00		      ds	1	; $28B
    180 U028c		       00		      ds	1	; $28C
    181 U028d		       00		      ds	1	; $28D
    182 U028e		       00		      ds	1	; $28E
    183 U028f		       00		      ds	1	; $28F
    184 U0290		       00		      ds	1	; $290
    185 U0291		       00		      ds	1	; $291
    186 U0292		       00		      ds	1	; $292
    187 U0293		       00		      ds	1	; $293
    188 U0294
    189 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    190 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    191 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    192 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    193 U0298
    194 U0298							;-------------------------------------------------------------------------------
    195 U0298							; The following required for back-compatibility with code which does not use
    196 U0298							; segments.
    197 U0298
    198  8400 ????				      SEG
    199  8400 ????
    200  8400 ????						; EOF
------- FILE C:\Users\Daniele\Documents\GitHub\atari-goblin\Goblin\goblin.bas.asm
------- FILE macro.h LEVEL 2 PASS 3
      0  8400 ????				      include	"macro.h"
      1  8400 ????						; MACRO.H
      2  8400 ????						; Version 1.05, 13/NOVEMBER/2003
      3  8400 ????
      4  8400 ????	       00 69	   VERSION_MACRO =	105
      5  8400 ????
      6  8400 ????						;
      7  8400 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  8400 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
      9  8400 ????						;
     10  8400 ????						; This file defines DASM macros useful for development for the Atari 2600.
     11  8400 ????						; It is distributed as a companion machine-specific support package
     12  8400 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  8400 ????						; available at at http://www.atari2600.org/dasm
     14  8400 ????						;
     15  8400 ????						; Many thanks to the people who have contributed.  If you take issue with the
     16  8400 ????						; contents, or would like to add something, please write to me
     17  8400 ????						; (atari2600@taswegian.com) with your contribution.
     18  8400 ????						;
     19  8400 ????						; Latest Revisions...
     20  8400 ????						;
     21  8400 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     22  8400 ????						;			    This will allow conditional code to verify MACRO.H being
     23  8400 ????						;			    used for code assembly.
     24  8400 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     25  8400 ????						;
     26  8400 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     27  8400 ????						;
     28  8400 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     29  8400 ????						;			   (standardised macro for vertical synch code)
     30  8400 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     31  8400 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     32  8400 ????						; 1.0	22/MAR/2003		Initial release
     33  8400 ????
     34  8400 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     35  8400 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     36  8400 ????						;   If you do not allow illegal opcode usage, you must include this file
     37  8400 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     38  8400 ????						;   registers and require them to be defined first).
     39  8400 ????
     40  8400 ????						; Available macros...
     41  8400 ????						;   SLEEP n		 - sleep for n cycles
     42  8400 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     43  8400 ????						;   CLEAN_START	 - set machine to known state on startup
     44  8400 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     45  8400 ????
     46  8400 ????						;-------------------------------------------------------------------------------
     47  8400 ????						; SLEEP duration
     48  8400 ????						; Original author: Thomas Jentzsch
     49  8400 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     50  8400 ????						; useful for code where precise timing is required.
     51  8400 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     52  8400 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     53  8400 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     54  8400 ????
     55  8400 ????				      MAC	sleep
     56  8400 ????			   .CYCLES    SET	{1}
     57  8400 ????
     58  8400 ????				      IF	.CYCLES < 2
     59  8400 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     60  8400 ????				      ERR
     61  8400 ????				      ENDIF
     62  8400 ????
     63  8400 ????				      IF	.CYCLES & 1
     64  8400 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     65  8400 ????				      nop	0
     66  8400 ????				      ELSE
     67  8400 ????				      bit	VSYNC
     68  8400 ????				      ENDIF
     69  8400 ????			   .CYCLES    SET	.CYCLES - 3
     70  8400 ????				      ENDIF
     71  8400 ????
     72  8400 ????				      REPEAT	.CYCLES / 2
     73  8400 ????				      nop
     74  8400 ????				      REPEND
     75  8400 ????				      ENDM		;usage: SLEEP n (n>1)
     76  8400 ????
     77  8400 ????						;-------------------------------------------------------------------------------
     78  8400 ????						; VERTICAL_SYNC
     79  8400 ????						; Original author: Manuel Polik
     80  8400 ????						; Inserts the code required for a proper 3 scannline
     81  8400 ????						; vertical sync sequence
     82  8400 ????						;
     83  8400 ????						; Note: Alters the accumulator
     84  8400 ????						;
     85  8400 ????						; IN:
     86  8400 ????						; OUT: A = 1
     87  8400 ????
     88  8400 ????				      MAC	vertical_sync
     89  8400 ????				      LDA	#$02	; A = VSYNC enable
     90  8400 ????				      STA	WSYNC	; Finish current line
     91  8400 ????				      STA	VSYNC	; Start vertical sync
     92  8400 ????				      STA	WSYNC	; 1st line vertical sync
     93  8400 ????				      STA	WSYNC	; 2nd line vertical sync
     94  8400 ????				      LSR		; A = VSYNC disable
     95  8400 ????				      STA	WSYNC	; 3rd line vertical sync
     96  8400 ????				      STA	VSYNC	; Stop vertical sync
     97  8400 ????				      ENDM
     98  8400 ????
     99  8400 ????						;-------------------------------------------------------------------------------
    100  8400 ????						; CLEAN_START
    101  8400 ????						; Original author: Andrew Davie
    102  8400 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    103  8400 ????						; Sets stack pointer to $FF, and all registers to 0
    104  8400 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    105  8400 ????						; Use as very first section of code on boot (ie: at reset)
    106  8400 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    107  8400 ????
    108  8400 ????				      MAC	clean_start
    109  8400 ????				      sei
    110  8400 ????				      cld
    111  8400 ????
    112  8400 ????				      ldx	#0
    113  8400 ????				      txa
    114  8400 ????				      tay
    115  8400 ????			   .CLEAR_STACK dex
    116  8400 ????				      txs
    117  8400 ????				      pha
    118  8400 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    119  8400 ????
    120  8400 ????				      ENDM
    121  8400 ????
    122  8400 ????						;-------------------------------------------------------
    123  8400 ????						; SET_POINTER
    124  8400 ????						; Original author: Manuel Rotschkar
    125  8400 ????						;
    126  8400 ????						; Sets a 2 byte RAM pointer to an absolute address.
    127  8400 ????						;
    128  8400 ????						; Usage: SET_POINTER pointer, address
    129  8400 ????						; Example: SET_POINTER SpritePTR, SpriteData
    130  8400 ????						;
    131  8400 ????						; Note: Alters the accumulator, NZ flags
    132  8400 ????						; IN 1: 2 byte RAM location reserved for pointer
    133  8400 ????						; IN 2: absolute address
    134  8400 ????
    135  8400 ????				      MAC	set_pointer
    136  8400 ????			   .POINTER   SET	{1}
    137  8400 ????			   .ADDRESS   SET	{2}
    138  8400 ????
    139  8400 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    140  8400 ????				      STA	.POINTER	; Store in pointer
    141  8400 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    142  8400 ????				      STA	.POINTER+1	; Store in pointer+1
    143  8400 ????
    144  8400 ????				      ENDM
    145  8400 ????
    146  8400 ????						; EOF
------- FILE C:\Users\Daniele\Documents\GitHub\atari-goblin\Goblin\goblin.bas.asm
------- FILE DPCplus.h LEVEL 2 PASS 3
      0  8400 ????				      include	"DPCplus.h"
      1  8400 ????						; DPCplus.H - Display Processor Chip Plus Definitions
      2  8400 ????						; Chris Walton, Fred Quimby, Darrell Spice 2010
      3  8400 ????						; Version 0.00
      4  8400 ????
      5  8400 ????						; DPC Base Address
      6  8400 ????			  -	      IFNCONST	DPC_BASE_ADDRESS
      7  8400 ????			  -DPC_BASE_ADDRESS =	$1000
      8  8400 ????				      ENDIF
      9  8400 ????
     10  8400 ????						; DPC Read Base
     11  8400 ????			  -	      IFNCONST	DPC_BASE_READ_ADDRESS
     12  8400 ????			  -DPC_BASE_READ_ADDRESS =	DPC_BASE_ADDRESS
     13  8400 ????				      ENDIF
     14  8400 ????
     15  8400 ????						; DPC Write Base
     16  8400 ????			  -	      IFNCONST	DPC_BASE_WRITE_ADDRESS
     17  8400 ????			  -DPC_BASE_WRITE_ADDRESS =	DPC_BASE_ADDRESS+$28
     18  8400 ????				      ENDIF
     19  8400 ????
     20 U1028 ????				      SEG.U	DPC_REGISTERS_READ
     21 U1000					      ORG	DPC_BASE_READ_ADDRESS
     22 U1000
     23 U1000							;****************************************
     24 U1000							; DPC+ Read Registers
     25 U1000							;****************************************
     26 U1000							;
     27 U1000							;----------------------------------------
     28 U1000							; Random Numbers
     29 U1000							;----------------------------------------
     30 U1000							; DPC+ provides a 32 bit LFSR (Linear feedback shift register)
     31 U1000							; which is used as a random number generator.	Each individual byte of the
     32 U1000							; random number will return values from 0-255.  The random numbers will follow
     33 U1000							; an exact sequence, so it's best to clock them at least once per frame even if
     34 U1000							; you don't need the value (this allows the amount of time it takes the user to
     35 U1000							; start the game to select a random starting point in the sequence)
     36 U1000							;----------------------------------------
     37 U1000		       00	   RANDOM0NEXT DS	1	; $00 clock next 32 bit number and returns byte 0
     38 U1001		       00	   RANDOM0PRIOR DS	1	; $01 clock prior 32 bit number and returns byte 0
     39 U1002		       00	   RANDOM1    DS	1	; $02 returns byte 1 of random number w/out clock
     40 U1003		       00	   RANDOM2    DS	1	; $03 returns byte 2 of random number w/out clock
     41 U1004		       00	   RANDOM3    DS	1	; $04 returns byte 3 of random number w/out clock
     42 U1005
     43 U1005							;----------------------------------------
     44 U1005							; Music Fetcher
     45 U1005							;----------------------------------------
     46 U1005							; When generating music, this value must be read every single scanline and
     47 U1005							; stored into AUDV0.
     48 U1005							;----------------------------------------
     49 U1005		       00	   AMPLITUDE  DS	1	; $05
     50 U1006
     51 U1006							;----------------------------------------
     52 U1006							; Reserved
     53 U1006							;----------------------------------------
     54 U1006		       00		      DS	1	; $06
     55 U1007		       00		      DS	1	; $07
     56 U1008
     57 U1008							;----------------------------------------
     58 U1008							; Data Fetcher
     59 U1008							;----------------------------------------
     60 U1008							; There are 8 Data Fetchers which are used to access data stored in the Display
     61 U1008							; Data bank.  Before using, you must point the Data Fetcher at the data to read
     62 U1008							; via DFxLOW and DFxHI.  After each read the Data Fetcher will update to point
     63 U1008							; to the next byte of data to return.
     64 U1008							;
     65 U1008							; psuedo code* to point Data Fetcher 1 to the color data
     66 U1008							;	lda #<(ColorDataPosition - HowFarDownScreen)
     67 U1008							;	sta DF1LOW
     68 U1008							;	lda #>(ColorDataPosition - HowFarDownScreen)
     69 U1008							;	sta DF1HI
     70 U1008							;	....
     71 U1008							; then in the kernel read the Data Fetcher and update the color, takes 7 cycles
     72 U1008							;	LDA DF1DATA
     73 U1008							;	STA COLUP0
     74 U1008							;
     75 U1008							; * see DPCplus.asm for actual code
     76 U1008							;----------------------------------------
     77 U1008		       00	   DF0DATA    DS	1	; $08
     78 U1009		       00	   DF1DATA    DS	1	; $09
     79 U100a		       00	   DF2DATA    DS	1	; $0A
     80 U100b		       00	   DF3DATA    DS	1	; $0B
     81 U100c		       00	   DF4DATA    DS	1	; $0C
     82 U100d		       00	   DF5DATA    DS	1	; $0D
     83 U100e		       00	   DF6DATA    DS	1	; $0E
     84 U100f		       00	   DF7DATA    DS	1	; $0F
     85 U1010
     86 U1010							;----------------------------------------
     87 U1010							; Data Fetcher, Windowed
     88 U1010							;----------------------------------------
     89 U1010							; The 8 Data Fetchers can also be read in a "windowed" mode, which is most
     90 U1010							; commonly used to update sprites.  To use windowed mode, point the Data
     91 U1010							; Fetcher the same as above, but then also set the Top and Bottom of the
     92 U1010							; Window using DFxTOP and DFxBOT.  When reading via the DFxDATAW registers, a 0
     93 U1010							; value will be returned for anything that's outside of the window.
     94 U1010							;
     95 U1010							; psuedo code to point Data Fetcher0 to the sprite data
     96 U1010							;	lda #<(SpriteDataPosition - HowFarDownScreen)
     97 U1010							;	sta DF0LOW
     98 U1010							;	lda #>(SpriteDataPosition - HowFarDownScreen)
     99 U1010							;	sta DF0HI
    100 U1010							;
    101 U1010							; set the window for Data Fetcher 0
    102 U1010							;	lda #<(SpriteDataPosition - 1)
    103 U1010							;	sta DF0TOP
    104 U1010							;	lda #<(SpriteDataPosition + ImageHeight)
    105 U1010							;	sta DF0BOT
    106 U1010							;	....
    107 U1010							; then in the kernel read the Data Fetcher and update the sprite, takes 7 cycles
    108 U1010							;	LDA DF0DATAW
    109 U1010							;	STA GRP0
    110 U1010							;----------------------------------------
    111 U1010		       00	   DF0DATAW   DS	1	; $10
    112 U1011		       00	   DF1DATAW   DS	1	; $11
    113 U1012		       00	   DF2DATAW   DS	1	; $12
    114 U1013		       00	   DF3DATAW   DS	1	; $13
    115 U1014		       00	   DF4DATAW   DS	1	; $14
    116 U1015		       00	   DF5DATAW   DS	1	; $15
    117 U1016		       00	   DF6DATAW   DS	1	; $16
    118 U1017		       00	   DF7DATAW   DS	1	; $17
    119 U1018
    120 U1018							;----------------------------------------
    121 U1018							; Fractional Data Fetcher
    122 U1018							;----------------------------------------
    123 U1018							; Another 8 Data Fetchers exist which work differently than the first 8.
    124 U1018							; These allow you to fractionally increment the Data Fetcher so a single
    125 U1018							; value can be read a set number of times before advancing to the next value.
    126 U1018							; This is commonly used to draw asymmetrical playfields without needing to
    127 U1018							; use 1200 bytes of data (200 scanlines * 6 playfield updates).
    128 U1018							; Before using, you must point the Fractional Data Fetcher at the data to read
    129 U1018							; via DFxFRACLOW and DFxFRACHI.  You must also set the increment value via
    130 U1018							; DFxFRACINC.
    131 U1018							;
    132 U1018							; Set pointer
    133 U1018							;	LDA #<PlayfieldPF0l
    134 U1018							;	STA DF0FRACLOW
    135 U1018							;	... repeat for PF1l, PF2l, PF0r, PF1r and PF2r
    136 U1018							;	lda #>PlayFieldPF0l
    137 U1018							;	STA DF0FRACHI
    138 U1018							;	... repeat for PF1l, PF2l, PF0r, PF1r and PF2r
    139 U1018							; Set the increment to repeat the value for x reads
    140 U1018							;	LDA #(256/x)
    141 U1018							;	STA DF0FRACINC
    142 U1018							;	 STA DF1FRACINC
    143 U1018							;	... repeat for 2-5
    144 U1018							;
    145 U1018							; Special Condition - IF you want to increment the pointer after every read
    146 U1018							; (just like the normal Data Fetcher), then use the following to set the
    147 U1018							; increment AND prime the Fractional Data Fetcher
    148 U1018							;	LDA #255
    149 U1018							;	STA DF0FRACINC
    150 U1018							;	 STA DF1FRACINC
    151 U1018							;	... repeat for 2-5
    152 U1018							;	LDA DF0FRACDATA - priming read (first value will be read twice)
    153 U1018							;	LDA DF1FRACDATA - priming read (first value will be read twice)
    154 U1018							;	... repeat for 2-5
    155 U1018							;
    156 U1018							; then in the kernel read the Fractional Data Fetchers and update the playfield
    157 U1018							;	LDA DF0FRACDATA
    158 U1018							;	STA PF0
    159 U1018							;	LDA PF1FRACDATA
    160 U1018							;	STA PF1
    161 U1018							;	... repeat for Data Fetchers 2-5, putting them in PF2, PF0, PF1 and PF2
    162 U1018							;----------------------------------------
    163 U1018		       00	   DF0FRACDATA DS	1	; $18
    164 U1019		       00	   DF1FRACDATA DS	1	; $19
    165 U101a		       00	   DF2FRACDATA DS	1	; $1A
    166 U101b		       00	   DF3FRACDATA DS	1	; $1B
    167 U101c		       00	   DF4FRACDATA DS	1	; $1C
    168 U101d		       00	   DF5FRACDATA DS	1	; $1D
    169 U101e		       00	   DF6FRACDATA DS	1	; $1E
    170 U101f		       00	   DF7FRACDATA DS	1	; $1F
    171 U1020
    172 U1020							;----------------------------------------
    173 U1020							; Data Fetcher Window Flag
    174 U1020							;----------------------------------------
    175 U1020							; The Data Fetcher Window Flag allows you to dual-purpose the first four
    176 U1020							; Data Fetchers.  The Window is not required when a Data Fetcher is used to
    177 U1020							; update a sprite's color.  The Flag will return $FF if it's within the window,
    178 U1020							; or 0 if it's not - this value can be used to control the display of the ball
    179 U1020							; and missiles. The Data Fetcher will NOT increment when reading the flag.
    180 U1020							;
    181 U1020							; psuedo code to point Data Fetcher 1 to the color data
    182 U1020							;	lda #<(ColorDataPosition - HowFarDownScreen)
    183 U1020							;	sta DF1LOW
    184 U1020							;	lda #>(ColorDataPosition - HowFarDownScreen)
    185 U1020							;	sta DF1HI
    186 U1020							;
    187 U1020							; set the window based on the missile's Y position and height (number of
    188 U1020							; scanlines to draw missile on)
    189 U1020							;	lda #<(ColorDataPosition + MissileYposition - 1)
    190 U1020							;	sta DF1TOP
    191 U1020							;	lda #<(ColorDataPosition + MissileYposition + MissileHeight)
    192 U1020							;	sta DF1BOT
    193 U1020							;
    194 U1020							; then in the kernel read the Data Fetcher and update the color, then read the
    195 U1020							; flag and update the missile
    196 U1020							;	LDA DF1DATA
    197 U1020							;	STA COLUP0
    198 U1020							;	LDA DF1FLAG
    199 U1020							;	STA ENAM0
    200 U1020							;----------------------------------------
    201 U1020		       00	   DF0FLAG    DS	1	; $20
    202 U1021		       00	   DF1FLAG    DS	1	; $21
    203 U1022		       00	   DF2FLAG    DS	1	; $22
    204 U1023		       00	   DF3FLAG    DS	1	; $23
    205 U1024
    206 U1024							;----------------------------------------
    207 U1024							; Reserved
    208 U1024							;----------------------------------------
    209 U1024		       00		      DS	1	; $24
    210 U1025		       00		      DS	1	; $25
    211 U1026		       00		      DS	1	; $26
    212 U1027		       00		      DS	1	; $27
    213 U1028
    214 U1028
    215 U1080 ????				      SEG.U	DPC_REGISTERS_WRITE
    216 U1028					      ORG	DPC_BASE_WRITE_ADDRESS
    217 U1028
    218 U1028							;****************************************
    219 U1028							; SECTION 2 - DPC+ Write Registers
    220 U1028							;****************************************
    221 U1028							;
    222 U1028							;----------------------------------------
    223 U1028							; Fractional Data Fetcher, Low Pointer
    224 U1028							;----------------------------------------
    225 U1028							; These are used in conjunction with DFxFRACHI to point a Fractional Data
    226 U1028							; Fetcher to the data to read.  For usage, see "Fractional Data Fetcher"
    227 U1028							; in SECTION 1.
    228 U1028							;----------------------------------------
    229 U1028		       00	   DF0FRACLOW DS	1	; $28
    230 U1029		       00	   DF1FRACLOW DS	1	; $29
    231 U102a		       00	   DF2FRACLOW DS	1	; $2A
    232 U102b		       00	   DF3FRACLOW DS	1	; $2B
    233 U102c		       00	   DF4FRACLOW DS	1	; $2C
    234 U102d		       00	   DF5FRACLOW DS	1	; $2D
    235 U102e		       00	   DF6FRACLOW DS	1	; $2E
    236 U102f		       00	   DF7FRACLOW DS	1	; $2F
    237 U1030
    238 U1030							;----------------------------------------
    239 U1030							; Fractional Data Fetcher, High Pointer
    240 U1030							;----------------------------------------
    241 U1030							; These are used in conjunction with DFxFRACLOW to point a Fractional Data
    242 U1030							; Fetcher to the data to read.  For usage, see "Fractional Data Fetcher"
    243 U1030							; in SECTION 1.
    244 U1030							;
    245 U1030							; NOTE: for only the lower 4 bits are used.
    246 U1030							;----------------------------------------
    247 U1030		       00	   DF0FRACHI  DS	1	; $30
    248 U1031		       00	   DF1FRACHI  DS	1	; $31
    249 U1032		       00	   DF2FRACHI  DS	1	; $32
    250 U1033		       00	   DF3FRACHI  DS	1	; $33
    251 U1034		       00	   DF4FRACHI  DS	1	; $34
    252 U1035		       00	   DF5FRACHI  DS	1	; $35
    253 U1036		       00	   DF6FRACHI  DS	1	; $36
    254 U1037		       00	   DF7FRACHI  DS	1	; $37
    255 U1038
    256 U1038							;----------------------------------------
    257 U1038							; Fractional Data Fetcher, Increment
    258 U1038							;----------------------------------------
    259 U1038							; These are used to set the increment amount for the Fractional Data Fetcher.
    260 U1038							; To increment pointer after every Xth read use int(256/X)
    261 U1038							; For usage, see "Fractional Data Fetcher" in SECTION 1.
    262 U1038							;----------------------------------------
    263 U1038		       00	   DF0FRACINC DS	1	; $38
    264 U1039		       00	   DF1FRACINC DS	1	; $39
    265 U103a		       00	   DF2FRACINC DS	1	; $3A
    266 U103b		       00	   DF3FRACINC DS	1	; $3B
    267 U103c		       00	   DF4FRACINC DS	1	; $3C
    268 U103d		       00	   DF5FRACINC DS	1	; $3D
    269 U103e		       00	   DF6FRACINC DS	1	; $3E
    270 U103f		       00	   DF7FRACINC DS	1	; $3F
    271 U1040
    272 U1040							;----------------------------------------
    273 U1040							; Data Fetcher, Window Top
    274 U1040							;----------------------------------------
    275 U1040							; These are used with DFxBOT to define the Data Fetcher Window
    276 U1040							; For usage, see "Data Fetcher, Windowed" in SECTION 1.
    277 U1040							;----------------------------------------
    278 U1040		       00	   DF0TOP     DS	1	; $40
    279 U1041		       00	   DF1TOP     DS	1	; $41
    280 U1042		       00	   DF2TOP     DS	1	; $42
    281 U1043		       00	   DF3TOP     DS	1	; $43
    282 U1044		       00	   DF4TOP     DS	1	; $44
    283 U1045		       00	   DF5TOP     DS	1	; $45
    284 U1046		       00	   DF6TOP     DS	1	; $46
    285 U1047		       00	   DF7TOP     DS	1	; $47
    286 U1048
    287 U1048							;----------------------------------------
    288 U1048							; Data Fetcher, Window Bottom
    289 U1048							;----------------------------------------
    290 U1048							; These are used with DFxTOP to define the Data Fetcher Window
    291 U1048							; For usage, see "Data Fetcher, Windowed" in SECTION 1.
    292 U1048							;----------------------------------------
    293 U1048		       00	   DF0BOT     DS	1	; $48
    294 U1049		       00	   DF1BOT     DS	1	; $49
    295 U104a		       00	   DF2BOT     DS	1	; $4A
    296 U104b		       00	   DF3BOT     DS	1	; $4B
    297 U104c		       00	   DF4BOT     DS	1	; $4C
    298 U104d		       00	   DF5BOT     DS	1	; $4D
    299 U104e		       00	   DF6BOT     DS	1	; $4E
    300 U104f		       00	   DF7BOT     DS	1	; $4F
    301 U1050
    302 U1050							;----------------------------------------
    303 U1050							; Data Fetcher, Low Pointer
    304 U1050							;----------------------------------------
    305 U1050							; These are used in conjunction with DFxHI to point a Data Fetcher to the data
    306 U1050							; to read.  For usage, see "Data Fetcher" in SECTION 1.
    307 U1050							;----------------------------------------
    308 U1050		       00	   DF0LOW     DS	1	; $50
    309 U1051		       00	   DF1LOW     DS	1	; $51
    310 U1052		       00	   DF2LOW     DS	1	; $52
    311 U1053		       00	   DF3LOW     DS	1	; $53
    312 U1054		       00	   DF4LOW     DS	1	; $54
    313 U1055		       00	   DF5LOW     DS	1	; $55
    314 U1056		       00	   DF6LOW     DS	1	; $56
    315 U1057		       00	   DF7LOW     DS	1	; $57
    316 U1058
    317 U1058							;----------------------------------------
    318 U1058							; Fast Fetch Mode
    319 U1058							;----------------------------------------
    320 U1058							; Fast Fetch Mode enables the fastest way to read DPC+ registers.  Normal
    321 U1058							; reads use LDA Absolute addressing (LDA DF0DATA) which takes 4 cycles to
    322 U1058							; process.  Fast Fetch Mode intercepts LDA Immediate addressing (LDA #<DF0DATA)
    323 U1058							; which takes only 2 cycles!  Only immediate values < $28 are intercepted
    324 U1058							;
    325 U1058							; set Fast Fetch Mode
    326 U1058							;	LDA #0
    327 U1058							;	STA FASTFETCH
    328 U1058							;
    329 U1058							; then use immediate mode to read the registers, takes just 5 cycles to update
    330 U1058							; any TIA register
    331 U1058							;
    332 U1058							;	LDA #<DF0DATA
    333 U1058							;	STA GRP0
    334 U1058							;
    335 U1058							; when done, turn off Fast Fetch Mode using any non-zero value
    336 U1058							;	LDA #$FF
    337 U1058							;	STA FASTFETCH
    338 U1058							;
    339 U1058							; NOTE: if you forget to turn off FASTFETCH mode, then code like this will not
    340 U1058							;	 work as you expect
    341 U1058							;	LDA #0	; returns a RANDOM NUMBER, not 0.
    342 U1058							;	STA COLUPF
    343 U1058							;----------------------------------------
    344 U1058		       00	   FASTFETCH  DS	1	; $58
    345 U1059
    346 U1059							;----------------------------------------
    347 U1059							; Function Support
    348 U1059							;----------------------------------------
    349 U1059							; Currently only Function 255 is defined, and it is used to call user
    350 U1059							; written ARM routines (or C code compiled for the ARM processor.)
    351 U1059							;
    352 U1059							; PARAMETER is not used by function 255, it may be used by future functions.
    353 U1059							;
    354 U1059							; call custom ARM routine
    355 U1059							;	LDA #$FF
    356 U1059							;	STA CALLFUNCTION
    357 U1059							;
    358 U1059							; A custom ARM demo will be released in the near future
    359 U1059							;----------------------------------------
    360 U1059		       00	   PARAMETER  DS	1	; $59
    361 U105a		       00	   CALLFUNCTION DS	1	; $5A
    362 U105b
    363 U105b							;----------------------------------------
    364 U105b							; Reserved
    365 U105b							;----------------------------------------
    366 U105b		       00		      DS	1	; $5B	 ; reserved
    367 U105c		       00		      DS	1	; $5C	 ; reserved
    368 U105d
    369 U105d							;----------------------------------------
    370 U105d							; Waveforms
    371 U105d							;----------------------------------------
    372 U105d							; Waveforms are 32 byte tables that define a waveform.  Waveforms must be 32
    373 U105d							; byte aligned, and can only be stored in the 4K Display Data Bank. You MUST
    374 U105d							; define an "OFF" waveform,  comprised of all zeros.  The sum of all waveforms
    375 U105d							; being played should be <= 15, so typically you'll use a maximum of 5 for any
    376 U105d							; given value.
    377 U105d							;
    378 U105d							; Valid values are 0-127 and point to the 4K Display Data bank.  The formula
    379 U105d							; (* & $1fff)/32 as shown below will calculate the value for you
    380 U105d							;
    381 U105d							;
    382 U105d							; example waveforms
    383 U105d							;	align 32		; forces the waveform to a 32 byte boundary
    384 U105d							;SOUND_OFF = (* & $1fff)/32	; calculates waveform pointer
    385 U105d							;	.byte 0,0,0,0,0,0,0,0
    386 U105d							;	.byte 0,0,0,0,0,0,0,0
    387 U105d							;	.byte 0,0,0,0,0,0,0,0
    388 U105d							;	.byte 0,0,0,0,0,0,0,0
    389 U105d							;
    390 U105d							;	align 32
    391 U105d							;SINE_WAVE = (* & $1fff)/32
    392 U105d							;	.byte 3,3,3,4,4,5,5,5
    393 U105d							;	.byte 5,5,5,5,4,4,3,3
    394 U105d							;	.byte 3,2,2,1,1,0,0,0
    395 U105d							;	.byte 0,0,0,0,1,1,2,2
    396 U105d							;
    397 U105d							; usage, set voice 0 to Sine Wave, set voice 1 & 2 off
    398 U105d							;	LDA #SINE_WAVE
    399 U105d							;	STA WAVEFORM0
    400 U105d							;	LDA #SOUND_OFF
    401 U105d							;	STA WAVEFORM1
    402 U105d							;	STA WAVEFORM2
    403 U105d							;----------------------------------------
    404 U105d		       00	   WAVEFORM0  DS	1	; $5D
    405 U105e		       00	   WAVEFORM1  DS	1	; $5E
    406 U105f		       00	   WAVEFORM2  DS	1	; $5F
    407 U1060
    408 U1060							;----------------------------------------
    409 U1060							; Data Fetcher Push (stack)
    410 U1060							;----------------------------------------
    411 U1060							; The Data Fetchers can also be used to update the contents of the 4K
    412 U1060							; Display Data bank.  Point the Data Fetcher to the data to change,
    413 U1060							; then Push to it.  The Data Fetcher's pointer will be decremented BEFORE
    414 U1060							; the data is written.
    415 U1060							;
    416 U1060							; point Data Fetcher 1 to the sprite data
    417 U1060							;	lda #<DisplayData
    418 U1060							;	sta DF1LOW
    419 U1060							;	lda #>DisplayData
    420 U1060							;	sta DF1HI
    421 U1060							;
    422 U1060							; then update it
    423 U1060							;	LDA #$FF
    424 U1060							;	STA DF1PUSH ; changes data at DisplayData - 1
    425 U1060							;	LDA #$81
    426 U1060							;	STA DF1OUSH ; changes data at DisplayData - 2
    427 U1060							;----------------------------------------
    428 U1060		       00	   DF0PUSH    DS	1	; $60
    429 U1061		       00	   DF1PUSH    DS	1	; $61
    430 U1062		       00	   DF2PUSH    DS	1	; $62
    431 U1063		       00	   DF3PUSH    DS	1	; $63
    432 U1064		       00	   DF4PUSH    DS	1	; $64
    433 U1065		       00	   DF5PUSH    DS	1	; $65
    434 U1066		       00	   DF6PUSH    DS	1	; $66
    435 U1067		       00	   DF7PUSH    DS	1	; $67
    436 U1068
    437 U1068							;----------------------------------------
    438 U1068							; Data Fetcher, High Pointer
    439 U1068							;----------------------------------------
    440 U1068							; These are used in conjunction with DFxLOW to point a Data Fetcher to the data
    441 U1068							; to read.  For usage, see "Data Fetcher" in SECTION 1.
    442 U1068							;----------------------------------------
    443 U1068		       00	   DF0HI      DS	1	; $68
    444 U1069		       00	   DF1HI      DS	1	; $69
    445 U106a		       00	   DF2HI      DS	1	; $6A
    446 U106b		       00	   DF3HI      DS	1	; $6B
    447 U106c		       00	   DF4HI      DS	1	; $6C
    448 U106d		       00	   DF5HI      DS	1	; $6D
    449 U106e		       00	   DF6HI      DS	1	; $6E
    450 U106f		       00	   DF7HI      DS	1	; $6F
    451 U1070
    452 U1070							;----------------------------------------
    453 U1070							; Random Number Initialization
    454 U1070							;----------------------------------------
    455 U1070							; The random number generate defaults to a value that spells out DPC+.
    456 U1070							; Store any value to RRESET to set the random number back to DPC+, or you
    457 U1070							; can use RWRITE0-3 to change the 32 bit value to anything you desire.
    458 U1070							;
    459 U1070							; reset random number
    460 U1070							;	LDA #0
    461 U1070							;	STA RRESET
    462 U1070							;
    463 U1070							; set a specific random number (spells out 2600)
    464 U1070							;	LDA #$32
    465 U1070							;	STA RWRITE0
    466 U1070							;	LDA #$36
    467 U1070							;	STA RWRITE1
    468 U1070							;	LDA #$30
    469 U1070							;	STA RWRITE2
    470 U1070							;	STA RWRITE3
    471 U1070							;
    472 U1070							; NOTE: do not set all 4 bytes to 0, as that will disable the generator.
    473 U1070							;----------------------------------------
    474 U1070		       00	   RRESET     DS	1	; $70
    475 U1071		       00	   RWRITE0    DS	1	; $71
    476 U1072		       00	   RWRITE1    DS	1	; $72
    477 U1073		       00	   RWRITE2    DS	1	; $73
    478 U1074		       00	   RWRITE3    DS	1	; $74
    479 U1075
    480 U1075							;----------------------------------------
    481 U1075							; Notes
    482 U1075							;----------------------------------------
    483 U1075							; These are used to select a value from the frequency table to play.
    484 U1075							; The default table, store in DPC_frequencies.h, only defines frequencies
    485 U1075							; for 1-88, which cover the keys of a piano.  You are free to add additional
    486 U1075							; frequencies from 88-255.  Piano keys are defined at the end of this file
    487 U1075							;
    488 U1075							; set voice 0 to middle C
    489 U1075							;	LDA #C4
    490 U1075							;	STA NOTE0
    491 U1075							;
    492 U1075							; Note: if you are using ARM USER CODE then you can only use notes to 128.
    493 U1075							;----------------------------------------
    494 U1075		       00	   NOTE0      DS	1	; $75
    495 U1076		       00	   NOTE1      DS	1	; $76
    496 U1077		       00	   NOTE2      DS	1	; $77
    497 U1078
    498 U1078							;----------------------------------------
    499 U1078							; Data Fetcher Write (queue)
    500 U1078							;----------------------------------------
    501 U1078							; The Data Fetchers can also be used to update the contents of the 4K
    502 U1078							; Display Data bank.  Point the Data Fetcher to the data to change,
    503 U1078							; then Write to it  The Data Fetcher's pointer will be incremented AFTER
    504 U1078							; the data is written.
    505 U1078							;
    506 U1078							; point Data Fetcher 1 to the sprite data
    507 U1078							;	lda #<SpriteData
    508 U1078							;	sta DF1LOW
    509 U1078							;	lda #>SpriteData
    510 U1078							;	sta DF1HI
    511 U1078							;
    512 U1078							; then update it
    513 U1078							;	LDA #$FF
    514 U1078							;	STA DF1WRITE ; changes data at SpriteData
    515 U1078							;	LDA #$81
    516 U1078							;	STA DF1WRITE ; changes data at SpriteData + 1
    517 U1078							;----------------------------------------
    518 U1078		       00	   DF0WRITE   DS	1	; $78
    519 U1079		       00	   DF1WRITE   DS	1	; $79
    520 U107a		       00	   DF2WRITE   DS	1	; $7A
    521 U107b		       00	   DF3WRITE   DS	1	; $7B
    522 U107c		       00	   DF4WRITE   DS	1	; $7C
    523 U107d		       00	   DF5WRITE   DS	1	; $7D
    524 U107e		       00	   DF6WRITE   DS	1	; $7E
    525 U107f		       00	   DF7WRITE   DS	1	; $7F
    526 U1080
    527 U1080							;-------------------------------------------------------------------------------
    528 U1080							; The following required for back-compatibility with code which does not use
    529 U1080							; segments.
    530 U1080
    531  8400 ????				      SEG
------- FILE C:\Users\Daniele\Documents\GitHub\atari-goblin\Goblin\goblin.bas.asm
------- FILE DPCplusbB.h LEVEL 2 PASS 3
      0  8400 ????				      include	"DPCplusbB.h"
      1 U00f5 ????				      SEG.U	vars
      2 U0080					      org	$80
      3 U0080		       00	   player0x   ds	1
      4 U0081		       00	   topP1x     ds	1
      5 U0082		       00	   missile0x  ds	1
      6 U0083		       00	   missile1x  ds	1
      7 U0084		       00	   ballx      ds	1
      8 U0085
      9 U0085		       00 00 00 00*SpriteGfxIndex ds	9
     10 U008e
     11 U008e		       00	   spritedisplay ds	1
     12 U008f
     13 U008f		       00	   player0xcoll ds	1	; to detect p0x colls
     14 U0090		       00	   NewSpriteX ds	1	;		X position
     15 U0090		       00 90	   player1x   =	NewSpriteX
     16 U0091		       00	   player2x   ds	1
     17 U0092		       00	   player3x   ds	1
     18 U0093		       00	   player4x   ds	1
     19 U0094		       00	   player5x   ds	1
     20 U0095		       00	   player6x   ds	1
     21 U0096		       00	   player7x   ds	1
     22 U0097		       00	   player8x   ds	1
     23 U0098		       00	   player9x   ds	1
     24 U0099
     25 U0099		       00	   player0y   ds	1
     26 U009a		       00	   NewSpriteY ds	1	;		Y position
     27 U009a		       00 9a	   player1y   =	NewSpriteY
     28 U009b		       00	   player2y   ds	1
     29 U009c		       00	   player3y   ds	1
     30 U009d		       00	   player4y   ds	1
     31 U009e		       00	   player5y   ds	1
     32 U009f		       00	   player6y   ds	1
     33 U00a0		       00	   player7y   ds	1
     34 U00a1		       00	   player8y   ds	1
     35 U00a2		       00	   player9y   ds	1
     36 U00a3
     37 U00a3		       00 00	   player0color ds	2
     38 U00a5
     39 U00a5		       00	   player0height ds	1
     40 U00a6		       00	   player1height ds	1
     41 U00a7		       00	   player2height ds	1
     42 U00a8		       00	   player3height ds	1
     43 U00a9		       00	   player4height ds	1
     44 U00aa		       00	   player5height ds	1
     45 U00ab		       00	   player6height ds	1
     46 U00ac		       00	   player7height ds	1
     47 U00ad		       00	   player8height ds	1
     48 U00ae		       00	   player9height ds	1
     49 U00af
     50 U00af		       00	   _NUSIZ1    ds	1
     51 U00b0		       00	   NUSIZ2     ds	1
     52 U00b1		       00	   NUSIZ3     ds	1
     53 U00b2		       00	   NUSIZ4     ds	1
     54 U00b3		       00	   NUSIZ5     ds	1
     55 U00b4		       00	   NUSIZ6     ds	1
     56 U00b5		       00	   NUSIZ7     ds	1
     57 U00b6		       00	   NUSIZ8     ds	1
     58 U00b7		       00	   NUSIZ9     ds	1
     59 U00b8
     60 U00b8		       00 00 00    score      ds	3
     61 U00bb		       00	   COLUM0     ds	1
     62 U00bc		       00	   COLUM1     ds	1
     63 U00bd		       00	   player0pointerlo ds	1
     64 U00be		       00	   player0pointerhi ds	1
     65 U00bf
     66 U00bf		       00 85	   RAMcopybegin =	SpriteGfxIndex
     67 U00bf		       00 3a	   RAMcopylength =	*-RAMcopybegin
     68 U00bf
     69 U00bf		       00	   missile0y  ds	1
     70 U00c0		       00	   missile1y  ds	1
     71 U00c1		       00	   bally      ds	1
     72 U00c2
     73 U00c2		       00	   missile0height ds	1
     74 U00c3		       00	   missile1height ds	1
     75 U00c4		       00	   ballheight ds	1
     76 U00c5
     77 U00c5		       00	   statusbarlength ds	1	; needed?
     78 U00c5		       00 c5	   aux3       =	statusbarlength
     79 U00c6
     80 U00c6		       00	   lifecolor  ds	1
     81 U00c6		       00 c6	   pfscorecolor =	lifecolor
     82 U00c7		       00	   aux4       ds	1
     83 U00c8
     84 U00c8		       00	   lifepointer ds	1
     85 U00c9		       00	   lives      ds	1
     86 U00c9		       00 c8	   pfscore1   =	lifepointer
     87 U00c9		       00 c9	   pfscore2   =	lives
     88 U00c9		       00 c8	   aux5       =	pfscore1
     89 U00c9		       00 c9	   aux6       =	pfscore2
     90 U00ca
     91 U00ca		       00	   playfieldpos ds	1
     92 U00cb
     93 U00cb		       00	   temp1      ds	1	; used in sprite flickering
     94 U00cc		       00	   temp2      ds	1	;are obliterated when drawscreen is called.
     95 U00cd		       00	   temp3      ds	1
     96 U00ce		       00	   temp4      ds	1
     97 U00cf		       00	   temp5      ds	1
     98 U00d0		       00	   temp6      ds	1
     99 U00d0		       00 81	   temp7      =	topP1x	; This is used to aid in bankswitching
    100 U00d1
    101 U00d1		       00	   A	      ds	1
    102 U00d1		       00 d1	   a	      =	A
    103 U00d2		       00	   B	      ds	1
    104 U00d2		       00 d2	   b	      =	B
    105 U00d3		       00	   C	      ds	1
    106 U00d3		       00 d3	   c	      =	C
    107 U00d4		       00	   D	      ds	1
    108 U00d4		       00 d4	   d	      =	D
    109 U00d5		       00	   E	      ds	1
    110 U00d5		       00 d5	   e	      =	E
    111 U00d6		       00	   F	      ds	1
    112 U00d6		       00 d6	   f	      =	F
    113 U00d7		       00	   G	      ds	1
    114 U00d7		       00 d7	   g	      =	G
    115 U00d8		       00	   H	      ds	1
    116 U00d8		       00 d8	   h	      =	H
    117 U00d9		       00	   I	      ds	1
    118 U00d9		       00 d9	   i	      =	I
    119 U00da		       00	   J	      ds	1
    120 U00da		       00 da	   j	      =	J
    121 U00db		       00	   K	      ds	1
    122 U00db		       00 db	   k	      =	K
    123 U00dc		       00	   L	      ds	1
    124 U00dc		       00 dc	   l	      =	L
    125 U00dd		       00	   M	      ds	1
    126 U00dd		       00 dd	   m	      =	M
    127 U00de		       00	   N	      ds	1
    128 U00de		       00 de	   n	      =	N
    129 U00df		       00	   O	      ds	1
    130 U00df		       00 df	   o	      =	O
    131 U00e0		       00	   P	      ds	1
    132 U00e0		       00 e0	   p	      =	P
    133 U00e1		       00	   Q	      ds	1
    134 U00e1		       00 e1	   q	      =	Q
    135 U00e2		       00	   R	      ds	1
    136 U00e2		       00 e2	   r	      =	R
    137 U00e3		       00	   S	      ds	1
    138 U00e3		       00 e3	   s	      =	S
    139 U00e4		       00	   T	      ds	1
    140 U00e4		       00 e4	   t	      =	T
    141 U00e5		       00	   U	      ds	1
    142 U00e5		       00 e5	   u	      =	U
    143 U00e6		       00	   V	      ds	1
    144 U00e6		       00 e6	   v	      =	V
    145 U00e7		       00	   W	      ds	1
    146 U00e7		       00 e7	   w	      =	W
    147 U00e8		       00	   X	      ds	1
    148 U00e8		       00 e8	   x	      =	X
    149 U00e9		       00	   Y	      ds	1
    150 U00e9		       00 e9	   y	      =	Y
    151 U00ea		       00	   Z	      ds	1
    152 U00ea		       00 ea	   z	      =	Z
    153 U00eb		       00	   scorecolor ds	1
    154 U00ec
    155 U00ec		       00	   var0       ds	1
    156 U00ed		       00	   var1       ds	1
    157 U00ee		       00	   var2       ds	1
    158 U00ef		       00	   var3       ds	1
    159 U00f0		       00	   var4       ds	1
    160 U00f1		       00	   var5       ds	1
    161 U00f2		       00	   var6       ds	1
    162 U00f3		       00	   var7       ds	1
    163 U00f4		       00	   var8       ds	1
    164 U00f5
 free ram: 0
    165 U00f5					      echo	"free ram:",($f5-*)d
    166 U00f5
    167 U00f5		       00 f6	   stack1     =	$f6
    168 U00f5		       00 f7	   stack2     =	$f7
    169 U00f5		       00 f8	   stack3     =	$f8
    170 U00f5		       00 f9	   stack4     =	$f9
    171 U00f5							; the stack bytes above may be used in the kernel
    172 U00f5							; stack = F6-F7, F8-F9, FA-FB, FC-FD, FE-FF
    173 U00f5
    174 U00f5					      MAC	return
    175 U00f5					      ifnconst	bankswitch
    176 U00f5					      rts
    177 U00f5					      else
    178 U00f5					      jmp	BS_return
    179 U00f5					      endif
    180 U00f5					      ENDM		; auto-return from either a regular or bankswitched module
    181  8400 ????				      seg
    182  8400 ????	       10 00	   rand       =	RANDOM0NEXT
    183  8400 ????	       00 d3	   KERNEL_LINES =	178*76/64	; warning: not all values will work
    184  8400 ????	       00 a7	   OVERSCAN_LINES =	128+33*76/64	; again, not all values work
    185  8400 ????	       d1 a4	   C_function =	FETCHER_BEGIN
    186  8400 ????	       d1 a8	   CcodeData  =	C_function + 4
    187  8400 ????	       d1 e2	   playerpointers =	CcodeData + RAMcopylength
    188  8400 ????	       d2 08	   P1GFX      =	playerpointers + 38
    189  8400 ????	       d3 08	   P1COLOR    =	P1GFX + 256
    190  8400 ????	       d4 08	   P0GFX      =	P1COLOR + 256
    191  8400 ????	       d5 08	   P0COLOR    =	P0GFX + 256
    192  8400 ????	       d6 08	   PF1L       =	P0COLOR + 256
    193  8400 ????	       d7 08	   PF2L       =	PF1L + 256
    194  8400 ????	       d8 08	   PF1R       =	PF2L + 256
    195  8400 ????	       d9 08	   PF2R       =	PF1R + 256
    196  8400 ????	       da 08	   PFCOLS     =	PF2R + 256
    197  8400 ????	       db 08	   JUMPTABLELO =	PFCOLS + 256
    198  8400 ????	       db 14	   JUMPTABLEHI =	JUMPTABLELO + 12
    199  8400 ????	       db 20	   P1HMP      =	JUMPTABLEHI + 12
    200  8400 ????	       db 2d	   P1SKIP     =	P1HMP + 13
    201  8400 ????	       db 39	   NUSIZREFP  =	P1SKIP + 12
    202  8400 ????	       db 45	   scoredata  =	NUSIZREFP + 12
    203  8400 ????	       db a5	   BKCOLS     =	scoredata + 96
    204  8400 ????	       dc a5	   STACKbegin =	BKCOLS + 256
    205  8400 ????	       dd a5	   USERSTACK  =	STACKbegin + 256	; stack starts here and goes down!!!!
 DPC free RAM= 603
    206  8400 ????				      echo	"DPC free RAM=",($1000-(USERSTACK&$0FFF))d
------- FILE C:\Users\Daniele\Documents\GitHub\atari-goblin\Goblin\goblin.bas.asm
------- FILE 2600basic_variable_redefs.h LEVEL 2 PASS 3
      0  8400 ????				      include	"2600basic_variable_redefs.h"
      1  8400 ????						; This file contains variable mapping and other information for the current project.
      2  8400 ????
      3  8400 ????	       00 20	   bscode_length =	32
      4  8400 ????	       00 03	   GAME_STATE_GAMEOVER =	3
      5  8400 ????
      6  8400 ????	       00 02	   GAME_STATE_PLAYING =	2
      7  8400 ????
      8  8400 ????	       00 e9	   gameStage  =	y
      9  8400 ????
     10  8400 ????	       00 e8	   gameState  =	x
     11  8400 ????
     12  8400 ????	       00 e3	   speed      =	s
     13  8400 ????
     14  8400 ????	       00 d6	   frames     =	f
     15  8400 ????
     16  8400 ????	       00 ea	   bits0_DebounceJoy0 =	z
     17  8400 ????
     18  8400 ????	       00 ea	   bits       =	z
     19  8400 ????
     20  8400 ????	       00 88	   GOBLIN_RIGHT_BOUNDARY =	GOBLIN_MAX_X
     21  8400 ????
     22  8400 ????	       00 10	   GOBLIN_LEFT_BOUNDARY =	GOBLIN_MIN_X
     23  8400 ????
     24  8400 ????	       00 a0	   GOBLIN_BOTTOM_BOUNDARY =	GOBLIN_MAX_Y
     25  8400 ????
     26  8400 ????	       00 e7	   GOBLIN_TOP_BOUNDARY =	255 - 24 + GOBLIN_MIN_Y
     27  8400 ????
     28  8400 ????	       00 10	   GOBLIN_DELTA_Y =	16
     29  8400 ????
     30  8400 ????	       00 08	   GOBLIN_DELTA_X =	8
     31  8400 ????
     32  8400 ????	       00 a0	   GOBLIN_MAX_Y =	160
     33  8400 ????
     34  8400 ????	       00 00	   GOBLIN_MIN_Y =	0
     35  8400 ????
     36  8400 ????	       00 88	   GOBLIN_MAX_X =	136
     37  8400 ????
     38  8400 ????	       00 10	   GOBLIN_MIN_X =	16
     39  8400 ????
     40  8400 ????	       00 06	   SMILE_SOUND_VOLUME =	6
     41  8400 ????
     42  8400 ????	       00 04	   SMILE_SOUND_FREQUENCY =	4
     43  8400 ????
     44  8400 ????	       00 08	   SMILE_SOUND_LENGTH =	8
     45  8400 ????
     46  8400 ????	       00 dd	   smileSound =	m
     47  8400 ????
     48  8400 ????	       00 06	   CRASH_SOUND_VOLUME =	6
     49  8400 ????
     50  8400 ????	       00 04	   CRASH_SOUND_FREQUENCY =	4
     51  8400 ????
     52  8400 ????	       00 08	   CRASH_SOUND_LENGTH =	8
     53  8400 ????
     54  8400 ????	       00 dd	   crashSound =	m
     55  8400 ????
     56  8400 ????	       00 08	   EAT_SOUND_VOLUME =	8
     57  8400 ????
     58  8400 ????	       00 19	   EAT_SOUND_FREQUENCY =	25
     59  8400 ????
     60  8400 ????	       00 0a	   EAT_SOUND_LENGTH =	10
     61  8400 ????
     62  8400 ????	       00 dd	   eatSound   =	m
     63  8400 ????
     64  8400 ????	       00 d3	   facesCounter =	c
     65  8400 ????
     66  8400 ????	       00 ba	   sc3	      =	score + 2
     67  8400 ????
     68  8400 ????	       00 b9	   sc2	      =	score + 1
     69  8400 ????
     70  8400 ????	       00 b8	   sc1	      =	score
     71  8400 ????
     72  8400 ????	       00 01	   font       =	1
     73  8400 ????
     74  8400 ????	       00 2b	   vblank_time =	43
     75  8400 ????	       00 25	   overscan_time =	37
     76  8400 ????	       00 07	   bs_mask    =	7
     77  8400 ????	       00 1c	   bankswitch =	28
     78  8400 ????	       1f f6	   bankswitch_hotspot =	$1FF6
     79  8400 ????	       00 02	   multisprite =	2
------- FILE C:\Users\Daniele\Documents\GitHub\atari-goblin\Goblin\goblin.bas.asm
      7  0400					      ORG	$400
      8  0400					      RORG	$0
      9  0400					      incbin	DPCplus.arm
     10  1000					      ORG	$1000
     11  1000					      RORG	$1000
     12  1000					      incbin	custom/bin/custom2.bin
     13  1894							; assume custom2.bin > 128 bytes
     14  1894							; repeat $80
     15  1894							; .byte 0
     16  1894							; repend
     17  1894							; feel free to modify the score graphics - just keep each digit 8 high
     18  1894							; and keep the conditional compilation stuff intact
     19  1894				  -	      ifconst	ROM2k
     20  1894				  -	      ORG	$F7AC-8
     21  1894					      else
     22  1894					      ifconst	bankswitch
     23  1894				  -	      if	bankswitch == 8
     24  1894				  -	      ORG	$2F94-bscode_length
     25  1894				  -	      RORG	$FF94-bscode_length
     26  1894					      endif
     27  1894				  -	      if	bankswitch == 16
     28  1894				  -	      ORG	$4F94-bscode_length
     29  1894				  -	      RORG	$FF94-bscode_length
     30  1894					      endif
     31  1894				  -	      if	bankswitch == 32
     32  1894				  -	      ORG	$8F94-bscode_length
     33  1894				  -	      RORG	$FF94-bscode_length
     34  1894					      endif
     35  1894				  -	      if	bankswitch == 64
     36  1894				  -	      ORG	$10F80-bscode_length
     37  1894				  -	      RORG	$1FF80-bscode_length
     38  1894					      endif
     39  1894				  -	      else
     40  1894				  -	      ORG	$FF9C
     41  1894					      endif
     42  1894					      endif
     43  1894
     44  1894							; font equates
     45  1894		       00 01	   .21stcentury =	1
     46  1894		       00 02	   alarmclock =	2
     47  1894		       00 03	   handwritten =	3
     48  1894		       00 04	   interrupted =	4
     49  1894		       00 05	   retroputer =	5
     50  1894		       00 06	   whimsey    =	6
     51  1894		       00 07	   tiny       =	7
     52  1894
     53  1894				   scoretable
     54  1894
     55  1894					      ifconst	font
     56  1894					      if	font == .21stcentury
------- FILE score_graphics.asm.21stcentury LEVEL 2 PASS 3
      0  1894					      include	"score_graphics.asm.21stcentury"
      1  1894		       3c		      .byte.b	%00111100
      2  1895		       42		      .byte.b	%01000010
      3  1896		       42		      .byte.b	%01000010
      4  1897		       42		      .byte.b	%01000010
      5  1898		       42		      .byte.b	%01000010
      6  1899		       42		      .byte.b	%01000010
      7  189a		       42		      .byte.b	%01000010
      8  189b		       3c		      .byte.b	%00111100
      9  189c
     10  189c		       08		      .byte.b	%00001000
     11  189d		       08		      .byte.b	%00001000
     12  189e		       08		      .byte.b	%00001000
     13  189f		       08		      .byte.b	%00001000
     14  18a0		       08		      .byte.b	%00001000
     15  18a1		       08		      .byte.b	%00001000
     16  18a2		       08		      .byte.b	%00001000
     17  18a3		       08		      .byte.b	%00001000
     18  18a4
     19  18a4		       7e		      .byte.b	%01111110
     20  18a5		       40		      .byte.b	%01000000
     21  18a6		       40		      .byte.b	%01000000
     22  18a7		       40		      .byte.b	%01000000
     23  18a8		       3c		      .byte.b	%00111100
     24  18a9		       02		      .byte.b	%00000010
     25  18aa		       02		      .byte.b	%00000010
     26  18ab		       1c		      .byte.b	%00011100
     27  18ac
     28  18ac		       7c		      .byte.b	%01111100
     29  18ad		       02		      .byte.b	%00000010
     30  18ae		       02		      .byte.b	%00000010
     31  18af		       02		      .byte.b	%00000010
     32  18b0		       7c		      .byte.b	%01111100
     33  18b1		       02		      .byte.b	%00000010
     34  18b2		       02		      .byte.b	%00000010
     35  18b3		       1c		      .byte.b	%00011100
     36  18b4
     37  18b4		       02		      .byte.b	%00000010
     38  18b5		       02		      .byte.b	%00000010
     39  18b6		       02		      .byte.b	%00000010
     40  18b7		       7e		      .byte.b	%01111110
     41  18b8		       42		      .byte.b	%01000010
     42  18b9		       42		      .byte.b	%01000010
     43  18ba		       42		      .byte.b	%01000010
     44  18bb		       42		      .byte.b	%01000010
     45  18bc
     46  18bc		       7c		      .byte.b	%01111100
     47  18bd		       02		      .byte.b	%00000010
     48  18be		       02		      .byte.b	%00000010
     49  18bf		       02		      .byte.b	%00000010
     50  18c0		       7c		      .byte.b	%01111100
     51  18c1		       40		      .byte.b	%01000000
     52  18c2		       40		      .byte.b	%01000000
     53  18c3		       78		      .byte.b	%01111000
     54  18c4
     55  18c4		       3c		      .byte.b	%00111100
     56  18c5		       42		      .byte.b	%01000010
     57  18c6		       42		      .byte.b	%01000010
     58  18c7		       42		      .byte.b	%01000010
     59  18c8		       7c		      .byte.b	%01111100
     60  18c9		       40		      .byte.b	%01000000
     61  18ca		       40		      .byte.b	%01000000
     62  18cb		       30		      .byte.b	%00110000
     63  18cc
     64  18cc		       10		      .byte.b	%00010000
     65  18cd		       10		      .byte.b	%00010000
     66  18ce		       08		      .byte.b	%00001000
     67  18cf		       08		      .byte.b	%00001000
     68  18d0		       04		      .byte.b	%00000100
     69  18d1		       04		      .byte.b	%00000100
     70  18d2		       02		      .byte.b	%00000010
     71  18d3		       7e		      .byte.b	%01111110
     72  18d4
     73  18d4		       3c		      .byte.b	%00111100
     74  18d5		       42		      .byte.b	%01000010
     75  18d6		       42		      .byte.b	%01000010
     76  18d7		       42		      .byte.b	%01000010
     77  18d8		       3c		      .byte.b	%00111100
     78  18d9		       42		      .byte.b	%01000010
     79  18da		       42		      .byte.b	%01000010
     80  18db		       3c		      .byte.b	%00111100
     81  18dc
     82  18dc		       0c		      .byte.b	%00001100
     83  18dd		       02		      .byte.b	%00000010
     84  18de		       02		      .byte.b	%00000010
     85  18df		       02		      .byte.b	%00000010
     86  18e0		       3e		      .byte.b	%00111110
     87  18e1		       42		      .byte.b	%01000010
     88  18e2		       42		      .byte.b	%01000010
     89  18e3		       3c		      .byte.b	%00111100
     90  18e4
     91  18e4				  -	      ifnconst	DPC_kernel_options
     92  18e4				  -
     93  18e4				  -	      .byte	%00000000
     94  18e4				  -	      .byte	%00000000
     95  18e4				  -	      .byte	%00000000
     96  18e4				  -	      .byte	%00000000
     97  18e4				  -	      .byte	%00000000
     98  18e4				  -	      .byte	%00000000
     99  18e4				  -	      .byte	%00000000
    100  18e4				  -	      .byte	%00000000
    101  18e4				  -
    102  18e4					      endif
------- FILE C:\Users\Daniele\Documents\GitHub\atari-goblin\Goblin\goblin.bas.asm
     58  18e4					      endif
     59  18e4				  -	      if	font == alarmclock
     60  18e4				  -	      include	"score_graphics.asm.alarmclock"
     61  18e4					      endif
     62  18e4				  -	      if	font == handwritten
     63  18e4				  -	      include	"score_graphics.asm.handwritten"
     64  18e4					      endif
     65  18e4				  -	      if	font == interrupted
     66  18e4				  -	      include	"score_graphics.asm.interrupted"
     67  18e4					      endif
     68  18e4				  -	      if	font == retroputer
     69  18e4				  -	      include	"score_graphics.asm.retroputer"
     70  18e4					      endif
     71  18e4				  -	      if	font == whimsey
     72  18e4				  -	      include	"score_graphics.asm.whimsey"
     73  18e4					      endif
     74  18e4				  -	      if	font == tiny
     75  18e4				  -	      include	"score_graphics.asm.tiny"
     76  18e4					      endif
     77  18e4				  -	      else		; default font
     78  18e4				  -
     79  18e4				  -	      .byte	%00111100
     80  18e4				  -	      .byte	%01100110
     81  18e4				  -	      .byte	%01100110
     82  18e4				  -	      .byte	%01100110
     83  18e4				  -	      .byte	%01100110
     84  18e4				  -	      .byte	%01100110
     85  18e4				  -	      .byte	%01100110
     86  18e4				  -	      .byte	%00111100
     87  18e4				  -
     88  18e4				  -	      .byte	%01111110
     89  18e4				  -	      .byte	%00011000
     90  18e4				  -	      .byte	%00011000
     91  18e4				  -	      .byte	%00011000
     92  18e4				  -	      .byte	%00011000
     93  18e4				  -	      .byte	%00111000
     94  18e4				  -	      .byte	%00011000
     95  18e4				  -	      .byte	%00001000
     96  18e4				  -
     97  18e4				  -	      .byte	%01111110
     98  18e4				  -	      .byte	%01100000
     99  18e4				  -	      .byte	%01100000
    100  18e4				  -	      .byte	%00111100
    101  18e4				  -	      .byte	%00000110
    102  18e4				  -	      .byte	%00000110
    103  18e4				  -	      .byte	%01000110
    104  18e4				  -	      .byte	%00111100
    105  18e4				  -
    106  18e4				  -	      .byte	%00111100
    107  18e4				  -	      .byte	%01000110
    108  18e4				  -	      .byte	%00000110
    109  18e4				  -	      .byte	%00000110
    110  18e4				  -	      .byte	%00011100
    111  18e4				  -	      .byte	%00000110
    112  18e4				  -	      .byte	%01000110
    113  18e4				  -	      .byte	%00111100
    114  18e4				  -
    115  18e4				  -	      .byte	%00001100
    116  18e4				  -	      .byte	%00001100
    117  18e4				  -	      .byte	%01111110
    118  18e4				  -	      .byte	%01001100
    119  18e4				  -	      .byte	%01001100
    120  18e4				  -	      .byte	%00101100
    121  18e4				  -	      .byte	%00011100
    122  18e4				  -	      .byte	%00001100
    123  18e4				  -
    124  18e4				  -	      .byte	%00111100
    125  18e4				  -	      .byte	%01000110
    126  18e4				  -	      .byte	%00000110
    127  18e4				  -	      .byte	%00000110
    128  18e4				  -	      .byte	%00111100
    129  18e4				  -	      .byte	%01100000
    130  18e4				  -	      .byte	%01100000
    131  18e4				  -	      .byte	%01111110
    132  18e4				  -
    133  18e4				  -	      .byte	%00111100
    134  18e4				  -	      .byte	%01100110
    135  18e4				  -	      .byte	%01100110
    136  18e4				  -	      .byte	%01100110
    137  18e4				  -	      .byte	%01111100
    138  18e4				  -	      .byte	%01100000
    139  18e4				  -	      .byte	%01100010
    140  18e4				  -	      .byte	%00111100
    141  18e4				  -
    142  18e4				  -	      .byte	%00110000
    143  18e4				  -	      .byte	%00110000
    144  18e4				  -	      .byte	%00110000
    145  18e4				  -	      .byte	%00011000
    146  18e4				  -	      .byte	%00001100
    147  18e4				  -	      .byte	%00000110
    148  18e4				  -	      .byte	%01000010
    149  18e4				  -	      .byte	%00111110
    150  18e4				  -
    151  18e4				  -	      .byte	%00111100
    152  18e4				  -	      .byte	%01100110
    153  18e4				  -	      .byte	%01100110
    154  18e4				  -	      .byte	%01100110
    155  18e4				  -	      .byte	%00111100
    156  18e4				  -	      .byte	%01100110
    157  18e4				  -	      .byte	%01100110
    158  18e4				  -	      .byte	%00111100
    159  18e4				  -
    160  18e4				  -	      .byte	%00111100
    161  18e4				  -	      .byte	%01000110
    162  18e4				  -	      .byte	%00000110
    163  18e4				  -	      .byte	%00111110
    164  18e4				  -	      .byte	%01100110
    165  18e4				  -	      .byte	%01100110
    166  18e4				  -	      .byte	%01100110
    167  18e4				  -	      .byte	%00111100
    168  18e4				  -
    169  18e4				  -	      ifnconst	DPC_kernel_options
    170  18e4				  -
    171  18e4				  -	      .byte	%00000000
    172  18e4				  -	      .byte	%00000000
    173  18e4				  -	      .byte	%00000000
    174  18e4				  -	      .byte	%00000000
    175  18e4				  -	      .byte	%00000000
    176  18e4				  -	      .byte	%00000000
    177  18e4				  -	      .byte	%00000000
    178  18e4				  -	      .byte	%00000000
    179  18e4				  -
    180  18e4				  -	      endif
    181  18e4				  -
    182  18e4					      endif
    183  18e4
    184  18e4				  -	      ifconst	ROM2k
    185  18e4				  -	      ORG	$F7FC
    186  18e4					      else
    187  18e4					      ifconst	bankswitch
    188  18e4				  -	      if	bankswitch == 8
    189  18e4				  -	      ORG	$2FF4-bscode_length
    190  18e4				  -	      RORG	$FFF4-bscode_length
    191  18e4					      endif
    192  18e4				  -	      if	bankswitch == 16
    193  18e4				  -	      ORG	$4FF4-bscode_length
    194  18e4				  -	      RORG	$FFF4-bscode_length
    195  18e4					      endif
    196  18e4				  -	      if	bankswitch == 32
    197  18e4				  -	      ORG	$8FF4-bscode_length
    198  18e4				  -	      RORG	$FFF4-bscode_length
    199  18e4					      endif
    200  18e4				  -	      if	bankswitch == 64
    201  18e4				  -	      ORG	$10FE0-bscode_length
    202  18e4				  -	      RORG	$1FFE0-bscode_length
    203  18e4					      endif
    204  18e4				  -	      else
    205  18e4				  -	      ORG	$FFFC
    206  18e4					      endif
    207  18e4					      endif
    208  18e4				   start
    209  18e4		       78		      sei
    210  18e5		       d8		      cld
    211  18e6		       a0 00		      ldy	#0
    212  18e8		       a5 d0		      lda	$D0
    213  18ea		       c9 2c		      cmp	#$2C	;check RAM location #1
    214  18ec		       d0 07		      bne	MachineIs2600
    215  18ee		       a5 d1		      lda	$D1
    216  18f0		       c9 a9		      cmp	#$A9	;check RAM location #2
    217  18f2		       d0 01		      bne	MachineIs2600
    218  18f4		       88		      dey
    219  18f5				   MachineIs2600
    220  18f5		       a2 00		      ldx	#0
    221  18f7		       8a		      txa
    222  18f8				   clearmem
    223  18f8		       e8		      inx
    224  18f9		       9a		      txs
    225  18fa		       48		      pha
    226  18fb		       d0 fb		      bne	clearmem
    227  18fd		       84 cb		      sty	temp1
    228  18ff		       a2 08		      ldx	#8
    229  1901		       86 ca		      stx	playfieldpos
    230  1903		       8e 58 10 	      stx	FASTFETCH
    231  1906		       a2 08		      ldx	#8
    232  1908		       a9 e0		      lda	#224
    233  190a				   inityloop
    234  190a		       95 9a		      sta	player1y,x
    235  190c		       ca		      dex
    236  190d		       10 fb		      bpl	inityloop
    237  190f
    238  190f		       a9 01		      lda	#1
    239  1911		       85 0a		      sta	CTRLPF
    240  1913		       ad 84 02 	      lda	INTIM
    241  1916		       8d 71 10 	      sta	RWRITE0
    242  1919		       a9 00		      lda	#0
    243  191b		       8d 38 10 	      STA	DF0FRACINC
    244  191e		       8d 39 10 	      STA	DF1FRACINC
    245  1921		       8d 3a 10 	      STA	DF2FRACINC
    246  1924		       8d 3b 10 	      STA	DF3FRACINC
    247  1927		       8d 3c 10 	      STA	DF4FRACINC
    248  192a		       8d 3e 10 	      STA	DF6FRACINC
    249  192d		       a9 a5		      lda	#<USERSTACK
    250  192f		       8d 57 10 	      STA	DF7LOW
    251  1932		       a9 0d		      lda	#(>USERSTACK) & $0F
    252  1934		       8d 6f 10 	      STA	DF7HI
    253  1937		       a9 ff		      lda	#255
    254  1939		       8d 5a 10 	      sta	CALLFUNCTION	; zero-fill fetcher
    255  193c
    256  193c		       a9 1f		      lda	#>(game-1)
    257  193e		       48		      pha
    258  193f		       a9 85		      lda	#<(game-1)
    259  1941		       48		      pha
    260  1942		       48		      pha
    261  1943		       48		      pha
    262  1944		       a2 01		      ldx	#1
    263  1946		       4c ee df 	      jmp	BS_jsr
    264  1949				   drawscreen
    265  1949		       a9 01		      lda	#1
    266  194b		       85 2c		      sta	CXCLR
    267  194d		       85 09		      sta	COLUBK	; REVENG - don't start with the lastline color
    268  194f
    269  194f				   fufu
    270  194f		       ad 84 02 	      lda	INTIM
    271  1952		       30 fb		      bmi	fufu
    272  1954
      0  1954					      VERTICAL_SYNC
      1  1954		       a9 02		      LDA	#$02
      2  1956		       85 02		      STA	WSYNC
      3  1958		       85 00		      STA	VSYNC
      4  195a		       85 02		      STA	WSYNC
      5  195c		       85 02		      STA	WSYNC
      6  195e		       4a		      LSR
      7  195f		       85 02		      STA	WSYNC
      8  1961		       85 00		      STA	VSYNC
    274  1963
    275  1963		       a9 a9		      lda	#41+128	;was 37 - do more w/c code
    276  1965		       8d 96 02 	      sta	TIM64T
    277  1968
    278  1968							; run possible vblank bB code
    279  1968				  -	      ifconst	vblank_bB_code
    280  1968				  -	      jsr	vblank_bB_code
    281  1968					      endif
    282  1968
    283  1968							; adjust for pfpos?
    284  1968
    285  1968							; set zero to properly enter C code
    286  1968		       a9 a4		      lda	#<C_function
    287  196a		       8d 50 10 	      sta	DF0LOW
    288  196d		       a9 01		      lda	#(>C_function) & $0F
    289  196f		       8d 68 10 	      sta	DF0HI
    290  1972		       a9 00		      lda	#0
    291  1974		       8d 78 10 	      sta	DF0WRITE
    292  1977
    293  1977							; REVENG - pass the number of vsprites we want...
    294  1977					      ifnconst	dpcspritemax
    295  1977		       a9 09		      lda	#9
    296  1979				  -	      else
    297  1979				  -	      lda	#dpcspritemax
    298  1979					      endif
    299  1979		       8d 78 10 	      sta	DF0WRITE
    300  197c
    301  197c		       a5 80		      lda	player0x
    302  197e		       85 8f		      sta	player0xcoll	; detect p0x colls
    303  1980
    304  1980							; copy RAM to fetcher for C-code
    305  1980		       a9 e2		      lda	#<(CcodeData + RAMcopylength)
    306  1982		       8d 50 10 	      sta	DF0LOW
    307  1985		       a9 01		      lda	#(>(CcodeData + RAMcopylength)) & $0F
    308  1987		       8d 68 10 	      sta	DF0HI
    309  198a		       a2 39		      ldx	#RAMcopylength-1
    310  198c				   copy2fetcherloop
    311  198c		       b5 85		      lda	RAMcopybegin,x
    312  198e		       8d 60 10 	      sta	DF0PUSH
    313  1991		       ca		      dex
    314  1992		       10 f8		      bpl	copy2fetcherloop
    315  1994
    316  1994		       a9 ff		      lda	#255
    317  1996		       8d 5a 10 	      sta	CALLFUNCTION
    318  1999
    319  1999							; copy modified data back (just need first 6 bytes, which is sprite sort data)
    320  1999		       a2 ed		      ldx	#256-19
    321  199b				   copyfromfetcherloop
    322  199b		       ad 08 10 	      lda	DF0DATA
    323  199e		       95 98		      sta	RAMcopybegin+19,x
    324  19a0		       e8		      inx
    325  19a1		       30 f8		      bmi	copyfromfetcherloop
    326  19a3
    327  19a3		       20 2f 1e 	      jsr	kernel_setup
    328  19a6
    329  19a6		       20 f7 1c 	      jsr	set_fetchers
    330  19a9
    331  19a9		       a2 07		      ldx	#7
    332  19ab				   setloopfrac
    333  19ab		       bd 72 1d 	      lda	dffraclow,x
    334  19ae		       9d 28 10 	      sta	DF0FRACLOW,x
    335  19b1		       bd 7a 1d 	      lda	dffrachi,x
    336  19b4		       9d 30 10 	      sta	DF0FRACHI,x
    337  19b7		       ca		      dex
    338  19b8		       10 f1		      bpl	setloopfrac
    339  19ba							; lda #255
    340  19ba		       8e 3d 10 	      STx	DF5FRACINC	; x=255 right now
    341  19bd		       8e 3f 10 	      STx	DF7FRACINC
    342  19c0		       ad 1d 10 	      lda	DF5FRACDATA	; priming read
    343  19c3		       ad 1f 10 	      lda	DF7FRACDATA	; priming read
    344  19c6
    345  19c6		       a6 85		      ldx	SpriteGfxIndex
    346  19c8		       b5 af		      lda	_NUSIZ1,x	; top NUSIZ/REFP
    347  19ca		       85 05		      sta	NUSIZ1
    348  19cc		       85 0c		      sta	REFP1
    349  19ce
    350  19ce							;REVENG - allow P0 to wrap at the top
    351  19ce				   startwrapfix
    352  19ce		       a9 ff		      lda	#255
    353  19d0		       85 cc		      sta	temp2
    354  19d2		       18		      clc
    355  19d3		       a5 99		      lda	player0y
    356  19d5		       65 a5		      adc	player0height
    357  19d7		       38		      sec
    358  19d8		       c5 a5		      cmp	player0height
    359  19da		       90 04		      bcc	skipwrapfix
    360  19dc		       a9 00		      lda	#0
    361  19de		       85 cc		      sta	temp2
    362  19e0				   skipwrapfix
    363  19e0
    364  19e0		       38		      sec
    365  19e1		       a9 08		      lda	#<P0GFX
    366  19e3		       e5 99		      sbc	player0y
    367  19e5		       8d 52 10 	      sta	DF2LOW
    368  19e8		       a9 d4		      lda	#>P0GFX
    369  19ea							;sbc #0
    370  19ea		       e5 cc		      sbc	temp2
    371  19ec		       8d 6a 10 	      sta	DF2HI
    372  19ef		       a9 07		      lda	#<(P0GFX-1)
    373  19f1		       8d 42 10 	      sta	DF2TOP
    374  19f4		       38		      sec
    375  19f5		       65 a5		      adc	player0height
    376  19f7		       8d 4a 10 	      sta	DF2BOT
    377  19fa
    378  19fa							;REVENG - 1/2 of the COLUM0 fix. the rest is in main.c
    379  19fa		       a9 08		      lda	#<(P0COLOR)
    380  19fc		       8d 50 10 	      sta	DF0LOW
    381  19ff		       85 cc		      sta	temp2
    382  1a01		       a9 d5		      lda	#>(P0COLOR)
    383  1a03		       8d 68 10 	      sta	DF0HI
    384  1a06
    385  1a06							; ball
    386  1a06		       a9 07		      lda	#<(P1GFX-1)
    387  1a08		       18		      clc
    388  1a09		       65 c1		      adc	bally
    389  1a0b		       8d 43 10 	      sta	DF3TOP
    390  1a0e		       38		      sec
    391  1a0f		       65 c4		      adc	ballheight
    392  1a11		       8d 4b 10 	      sta	DF3BOT
    393  1a14
    394  1a14							; missile0
    395  1a14		       a5 cc		      lda	temp2
    396  1a16		       18		      clc
    397  1a17		       65 bf		      adc	missile0y
    398  1a19		       8d 40 10 	      sta	DF0TOP
    399  1a1c		       38		      sec
    400  1a1d		       65 c2		      adc	missile0height
    401  1a1f		       8d 48 10 	      sta	DF0BOT
    402  1a22
    403  1a22
    404  1a22				   fuu
    405  1a22		       ad 84 02 	      lda	INTIM
    406  1a25		       30 fb		      bmi	fuu
    407  1a27		       85 02		      sta	WSYNC
    408  1a29		       a0 80		      ldy	#$80
    409  1a2b		       84 20		      sty	HMP0
    410  1a2d		       84 21		      sty	HMP1
    411  1a2f		       84 22		      sty	HMM0
    412  1a31		       84 23		      sty	HMM1
    413  1a33		       84 24		      sty	HMBL
    414  1a35		       a9 d3		      lda	#KERNEL_LINES
    415  1a37		       8d 96 02 	      sta	TIM64T
    416  1a3a		       a9 01		      lda	#1
    417  1a3c		       85 27		      sta	VDELBL
    418  1a3e		       85 25		      sta	VDELP0
    419  1a40
    420  1a40							; missile1
    421  1a40		       a9 07		      lda	#<(P1COLOR-1)
    422  1a42		       18		      clc
    423  1a43		       65 c0		      adc	missile1y
    424  1a45		       8d 41 10 	      sta	DF1TOP
    425  1a48		       38		      sec
    426  1a49		       65 c3		      adc	missile1height
    427  1a4b		       8d 49 10 	      sta	DF1BOT
    428  1a4e
    429  1a4e		       a9 00		      lda	#0
    430  1a50		       85 01		      sta	VBLANK
    431  1a52		       8d 58 10 	      sta	FASTFETCH
    432  1a55							;sleep 7
    433  1a55		       a9 12		      lda	#<DF2DATAW	; REVENG - added so GRP0 is at TOP
    434  1a57		       85 1b		      STA	GRP0	; 36 (VDEL)   ; ""
      0  1a59					      sleep	2	; ""
      1  1a59				   .CYCLES    SET	2
      2  1a59
      3  1a59				  -	      IF	.CYCLES < 2
      4  1a59				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1a59				  -	      ERR
      6  1a59					      ENDIF
      7  1a59
      8  1a59				  -	      IF	.CYCLES & 1
      9  1a59				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1a59				  -	      nop	0
     11  1a59				  -	      ELSE
     12  1a59				  -	      bit	VSYNC
     13  1a59				  -	      ENDIF
     14  1a59				  -.CYCLES    SET	.CYCLES - 3
     15  1a59					      ENDIF
     16  1a59
     17  1a59					      REPEAT	.CYCLES / 2
     18  1a59		       ea		      nop
     19  1a5a					      REPEND
    436  1a5a
    437  1a5a		       a9 18		      lda	#<DF0FRACDATA
    438  1a5c		       85 0e		      sta	PF1	; (PF1L)
    439  1a5e
    440  1a5e							; enter at cycle ??
    441  1a5e				   loop
    442  1a5e		       a9 08		      lda	#<DF0DATA	;74
    443  1a60		       85 06		      STA	COLUP0	; 1
    444  1a62		       a9 09		      lda	#<DF1DATA	;3
    445  1a64				   loop2
    446  1a64		       85 07		      STA	COLUP1	; 6
    447  1a66		       a9 0b		      lda	#<DF3DATA
    448  1a68		       85 1c		      STA	GRP1	; 11
    449  1a6a		       a9 20		      lda	#<DF0FLAG
    450  1a6c		       85 1d		      STA	ENAM0	; 16
    451  1a6e
    452  1a6e		       a9 1e		      lda	#<DF6FRACDATA
    453  1a70		       85 09		      sta	COLUBK	; 21
    454  1a72		       a9 1c		      lda	#<DF4FRACDATA
    455  1a74		       85 08		      sta	COLUPF	; 26
    456  1a76		       a9 19		      lda	#<DF1FRACDATA
    457  1a78		       85 0f		      sta	PF2	; 31 (PF2L)
    458  1a7a				   loop3
    459  1a7a		       a9 12		      lda	#<DF2DATAW
    460  1a7c		       85 1b		      STA	GRP0	; 36 (VDEL)
    461  1a7e		       a9 23		      lda	#<DF3FLAG
    462  1a80		       85 1f		      STA	ENABL	; 41 (VDEL)
    463  1a82		       a2 70		      ldx	#$70	;in case we get kernel 6
    464  1a84		       a9 1a		      lda	#<DF2FRACDATA	;45
    465  1a86		       85 0f		      sta	PF2	; 48
    466  1a88		       84 21		      sty	HMP1	; 51 ; from prev. cycle: $80=nomove
    467  1a8a		       a9 1b		      lda	#<DF3FRACDATA	;53
    468  1a8c		       85 0e		      sta	PF1	; 56
    469  1a8e		       a9 0c		      lda	#<DF4DATA	; 58 this is the repos info
    470  1a90		       f0 4d		      beq	repo	;60/61
    471  1a92				   norepo		; 60
    472  1a92		       a8		      tay		; 62
    473  1a93		       a9 08		      lda	#<DF0DATA	; 64
    474  1a95
    475  1a95		       ae 84 02 	      ldx	INTIM	; 68 timed for 192 lines
    476  1a98		       f0 60		      beq	exitkernel	; 70/71
    477  1a9a		       85 2a		      sta	HMOVE	; 73
    478  1a9c
    479  1a9c		       85 06		      STA	COLUP0	; 0
    480  1a9e		       a9 09		      lda	#<DF1DATA	;2
    481  1aa0		       85 07		      STA	COLUP1	;5
    482  1aa2		       a9 0b		      lda	#<DF3DATA
    483  1aa4		       85 1c		      STA	GRP1	; 10
    484  1aa6		       a9 21		      lda	#<DF1FLAG
    485  1aa8		       85 1e		      STA	ENAM1	; 15
    486  1aaa		       a9 18		      lda	#<DF0FRACDATA
    487  1aac		       85 0e		      sta	PF1	; 20 (PF1L)
    488  1aae		       a9 19		      lda	#<DF1FRACDATA
    489  1ab0		       85 0f		      sta	PF2	; 25 (PF2L)
    490  1ab2		       a9 12		      lda	#<DF2DATAW
    491  1ab4		       85 1b		      STA	GRP0	; 30 (VDEL)
    492  1ab6		       a9 23		      lda	#<DF3FLAG
    493  1ab8		       85 1f		      STA	ENABL	; 35 (VDEL)
    494  1aba		       88		      dey		; 37
    495  1abb		       8c 64 10 	      STY	DF4PUSH	; 41
    496  1abe		       a0 80		      ldy	#$80	; 43 no movement next line
    497  1ac0		       a9 1a		      lda	#<DF2FRACDATA	;45
    498  1ac2		       85 0f		      sta	PF2	; 48
    499  1ac4		       84 21		      sty	HMP1	; 51 ; from prev. cycle: $80=nomove
    500  1ac6		       a9 1b		      lda	#<DF3FRACDATA	;53
    501  1ac8		       85 0e		      sta	PF1	; 56
    502  1aca				  -	      ifnconst	DPC_kernel_options
    503  1aca				  -			;sleep 8 ; REVENG - timing is off - results in a garbled screen
    504  1aca				  -	      sleep	5	; this is better
    505  1aca					      else
    506  1aca		       24 43		      bit	DPC_kernel_options
    507  1acc					      if	(DPC_kernel_options > $3F)
    508  1acc		       30 09		      bmi	COLfound
    509  1ace				  -	      else
    510  1ace				  -	      bpl	COLfound
    511  1ace					      endif
    512  1ace					      endif
    513  1ace		       86 ce		      stx	temp4	; +3
    514  1ad0
    515  1ad0				   getbackearly
    516  1ad0		       a9 18		      lda	#<DF0FRACDATA	; +2
    517  1ad2		       85 0e		      sta	PF1	; 69 (PF1L) too early?
    518  1ad4		       4c 5e 5a 	      JMP	loop+$4000	; 72
    519  1ad7
    520  1ad7					      ifconst	DPC_kernel_options
    521  1ad7				   COLfound
    522  1ad7		       ad 18 10 	      lda	DF0FRACDATA
    523  1ada		       85 0e		      sta	PF1	; 69 (PF1L) too early?
    524  1adc		       4c 5e 5a 	      JMP	loop+$4000	; 72
    525  1adf					      endif
    526  1adf
    527  1adf				   repo
    528  1adf		       ac 1f 10 	      ldy	DF7FRACDATA	; 65
    529  1ae2		       a9 18		      lda	#<DF0FRACDATA	; 67 preload PF1L for next line
    530  1ae4				  -	      if	((>repo) > (>norepo))
    531  1ae4				  -	      STA	PF1
    532  1ae4					      else
    533  1ae4		       8d 0e 00 	      STA.w	PF1	; 71 ; sta.w if page doesn't wrap
    534  1ae7					      endif
    535  1ae7		       a9 08		      lda	#<DF0DATA	;73
    536  1ae9		       85 06		      STA	COLUP0	; 0
    537  1aeb		       a9 09		      lda	#<DF1DATA
    538  1aed		       85 07		      STA	COLUP1	;5
    539  1aef		       a9 0b		      lda	#<DF3DATA
    540  1af1		       85 1c		      STA	GRP1	; 10
    541  1af3		       a9 21		      lda	#<DF1FLAG
    542  1af5		       85 1e		      STA	ENAM1	; 15
    543  1af7							; repos info holds HMMx
    544  1af7		       6c 0d 10 	      jmp	(DF5DATA)	; 20 grabs df6/df7=lo/hi
    545  1afa
    546  1afa				   exitkernel		; exit the kernel
    547  1afa		       20 be 5e 	      jsr	scorekernel+$4000	; 1
    548  1afd				   exit
    549  1afd		       a2 ff		      ldx	#255
    550  1aff		       8e 58 10 	      stx	FASTFETCH
    551  1b02		       85 02		      sta	WSYNC
    552  1b04		       a9 02		      lda	#2
    553  1b06		       85 01		      STA	VBLANK
    554  1b08		       a9 a7		      lda	#OVERSCAN_LINES
    555  1b0a		       8d 96 02 	      sta	TIM64T
    556  1b0d		       38		      sec
    557  1b0e		       a9 d3		      lda	#KERNEL_LINES
    558  1b10		       e5 ce		      sbc	temp4
    559  1b12		       aa		      tax
    560  1b13		       4a		      lsr
    561  1b14		       4a		      lsr
    562  1b15		       85 cd		      sta	temp3	; div4
    563  1b17		       4a		      lsr
    564  1b18		       4a		      lsr
    565  1b19		       85 cc		      sta	temp2	; div16
    566  1b1b		       4a		      lsr
    567  1b1c		       85 cb		      sta	temp1	; div32
    568  1b1e		       18		      clc
    569  1b1f		       8a		      txa
    570  1b20		       65 cc		      adc	temp2
    571  1b22		       65 cb		      adc	temp1
    572  1b24		       38		      sec
    573  1b25		       e5 cd		      sbc	temp3
    574  1b27		       85 ce		      sta	temp4	; approx line of first pf coll
      0  1b29					      RETURN
      1  1b29				  -	      ifnconst	bankswitch
      2  1b29				  -	      rts
      3  1b29					      else
      4  1b29		       4c e0 df 	      jmp	BS_return
      5  1b2c					      endif
    576  1b2c
    577  1b2c							; jmp exit
    578  1b2c
    579  1b2c							; kernels resp1 23/28/33/38/43/48/53/58/63/68/73
    580  1b2c
    581  1b2c				   kernel1
    582  1b2c		       85 11		      sta	RESP1	; 23
    583  1b2e		       a9 12		      lda	#<DF2DATAW
    584  1b30		       85 1b		      STA	GRP0	; 28 (VDEL)
    585  1b32		       a9 23		      lda	#<DF3FLAG
    586  1b34		       85 1f		      STA	ENABL	; 33 (VDEL)
    587  1b36		       a9 19		      lda	#<DF1FRACDATA
    588  1b38		       85 0f		      STA	PF2	; 38
      0  1b3a					      sleep	5
      1  1b3a				   .CYCLES    SET	5
      2  1b3a
      3  1b3a				  -	      IF	.CYCLES < 2
      4  1b3a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1b3a				  -	      ERR
      6  1b3a					      ENDIF
      7  1b3a
      8  1b3a					      IF	.CYCLES & 1
      9  1b3a					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1b3a		       04 00		      nop	0
     11  1b3c				  -	      ELSE
     12  1b3c				  -	      bit	VSYNC
     13  1b3c					      ENDIF
     14  1b3c				   .CYCLES    SET	.CYCLES - 3
     15  1b3c					      ENDIF
     16  1b3c
     17  1b3c					      REPEAT	.CYCLES / 2
     18  1b3c		       ea		      nop
     19  1b3d					      REPEND
    590  1b3d		       a9 1a		      lda	#<DF2FRACDATA	;45
    591  1b3f		       85 0f		      sta	PF2	; 48
    592  1b41		       a9 1b		      lda	#<DF3FRACDATA	;50
    593  1b43		       85 0e		      sta	PF1	; 53
    594  1b45		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    595  1b47		       85 05		      STA	NUSIZ1	; 58
    596  1b49		       85 0c		      STA	REFP1	; 61
    597  1b4b		       4c d0 1a 	      jmp	getbackearly	;64
    598  1b4e
    599  1b4e				   kernel2
    600  1b4e		       a9 12		      lda	#<DF2DATAW
    601  1b50		       85 1b		      STA	GRP0	; 25 (VDEL)
    602  1b52		       85 11		      sta	RESP1	;28
    603  1b54		       a9 23		      lda	#<DF3FLAG
    604  1b56		       85 1f		      STA	ENABL	; 33 (VDEL)
    605  1b58		       a9 19		      lda	#<DF1FRACDATA
    606  1b5a		       85 0f		      STA	PF2	; 38
      0  1b5c					      sleep	5
      1  1b5c				   .CYCLES    SET	5
      2  1b5c
      3  1b5c				  -	      IF	.CYCLES < 2
      4  1b5c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1b5c				  -	      ERR
      6  1b5c					      ENDIF
      7  1b5c
      8  1b5c					      IF	.CYCLES & 1
      9  1b5c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1b5c		       04 00		      nop	0
     11  1b5e				  -	      ELSE
     12  1b5e				  -	      bit	VSYNC
     13  1b5e					      ENDIF
     14  1b5e				   .CYCLES    SET	.CYCLES - 3
     15  1b5e					      ENDIF
     16  1b5e
     17  1b5e					      REPEAT	.CYCLES / 2
     18  1b5e		       ea		      nop
     19  1b5f					      REPEND
    608  1b5f		       a9 1a		      lda	#<DF2FRACDATA	;45
    609  1b61		       85 0f		      sta	PF2	; 48
    610  1b63		       a9 1b		      lda	#<DF3FRACDATA	;50
    611  1b65		       85 0e		      sta	PF1	; 53
    612  1b67		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    613  1b69		       85 05		      STA	NUSIZ1
    614  1b6b		       85 0c		      STA	REFP1
    615  1b6d		       4c d0 1a 	      jmp	getbackearly	;64
    616  1b70
    617  1b70				   kernel3
    618  1b70		       a9 12		      lda	#<DF2DATAW
    619  1b72		       85 1b		      STA	GRP0	; 25 (VDEL)
    620  1b74		       a9 23		      lda	#<DF3FLAG
    621  1b76		       85 1f		      STA	ENABL	; 30 (VDEL)
    622  1b78		       85 11		      sta	RESP1	;33
    623  1b7a		       a9 19		      lda	#<DF1FRACDATA
    624  1b7c		       85 0f		      STA	PF2	; 38
      0  1b7e					      sleep	5
      1  1b7e				   .CYCLES    SET	5
      2  1b7e
      3  1b7e				  -	      IF	.CYCLES < 2
      4  1b7e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1b7e				  -	      ERR
      6  1b7e					      ENDIF
      7  1b7e
      8  1b7e					      IF	.CYCLES & 1
      9  1b7e					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1b7e		       04 00		      nop	0
     11  1b80				  -	      ELSE
     12  1b80				  -	      bit	VSYNC
     13  1b80					      ENDIF
     14  1b80				   .CYCLES    SET	.CYCLES - 3
     15  1b80					      ENDIF
     16  1b80
     17  1b80					      REPEAT	.CYCLES / 2
     18  1b80		       ea		      nop
     19  1b81					      REPEND
    626  1b81		       a9 1a		      lda	#<DF2FRACDATA	;45
    627  1b83		       85 0f		      sta	PF2	; 48
    628  1b85		       a9 1b		      lda	#<DF3FRACDATA	;50
    629  1b87		       85 0e		      sta	PF1	; 53
    630  1b89		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    631  1b8b		       85 05		      STA	NUSIZ1
    632  1b8d		       85 0c		      STA	REFP1
    633  1b8f		       4c d0 1a 	      JMP	getbackearly	; 64
    634  1b92
    635  1b92				   kernel4
    636  1b92		       a9 12		      lda	#<DF2DATAW
    637  1b94		       85 1b		      STA	GRP0	; 25 (VDEL)
    638  1b96		       a9 23		      lda	#<DF3FLAG
    639  1b98		       85 1f		      STA	ENABL	; 30(VDEL)
    640  1b9a		       a9 19		      lda	#<DF1FRACDATA
    641  1b9c		       85 0f		      STA	PF2	; 35
    642  1b9e		       85 11		      sta	RESP1	;38
      0  1ba0					      sleep	5
      1  1ba0				   .CYCLES    SET	5
      2  1ba0
      3  1ba0				  -	      IF	.CYCLES < 2
      4  1ba0				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1ba0				  -	      ERR
      6  1ba0					      ENDIF
      7  1ba0
      8  1ba0					      IF	.CYCLES & 1
      9  1ba0					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1ba0		       04 00		      nop	0
     11  1ba2				  -	      ELSE
     12  1ba2				  -	      bit	VSYNC
     13  1ba2					      ENDIF
     14  1ba2				   .CYCLES    SET	.CYCLES - 3
     15  1ba2					      ENDIF
     16  1ba2
     17  1ba2					      REPEAT	.CYCLES / 2
     18  1ba2		       ea		      nop
     19  1ba3					      REPEND
    644  1ba3		       a9 1a		      lda	#<DF2FRACDATA	;45
    645  1ba5		       85 0f		      sta	PF2	; 48
    646  1ba7		       a9 1b		      lda	#<DF3FRACDATA	;50
    647  1ba9		       85 0e		      sta	PF1	; 53
    648  1bab		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    649  1bad		       85 05		      STA	NUSIZ1	; 58
    650  1baf		       85 0c		      STA	REFP1	; 61
    651  1bb1		       4c d0 1a 	      JMP	getbackearly	; 64
    652  1bb4
    653  1bb4				   kernel5
    654  1bb4		       a9 12		      lda	#<DF2DATAW
    655  1bb6		       85 1b		      STA	GRP0	; (VDEL)
    656  1bb8		       a9 23		      lda	#<DF3FLAG
    657  1bba		       85 1f		      STA	ENABL	; (VDEL)
    658  1bbc		       a9 19		      lda	#<DF1FRACDATA
    659  1bbe		       85 0f		      STA	PF2	; 35
      0  1bc0					      sleep	5
      1  1bc0				   .CYCLES    SET	5
      2  1bc0
      3  1bc0				  -	      IF	.CYCLES < 2
      4  1bc0				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1bc0				  -	      ERR
      6  1bc0					      ENDIF
      7  1bc0
      8  1bc0					      IF	.CYCLES & 1
      9  1bc0					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1bc0		       04 00		      nop	0
     11  1bc2				  -	      ELSE
     12  1bc2				  -	      bit	VSYNC
     13  1bc2					      ENDIF
     14  1bc2				   .CYCLES    SET	.CYCLES - 3
     15  1bc2					      ENDIF
     16  1bc2
     17  1bc2					      REPEAT	.CYCLES / 2
     18  1bc2		       ea		      nop
     19  1bc3					      REPEND
    661  1bc3		       85 11		      sta	RESP1	;43
    662  1bc5		       a9 1a		      lda	#<DF2FRACDATA	;45
    663  1bc7		       85 0f		      sta	PF2	; 48
    664  1bc9		       a9 1b		      lda	#<DF3FRACDATA	;50
    665  1bcb		       85 0e		      sta	PF1	; 53
    666  1bcd		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    667  1bcf		       85 05		      STA	NUSIZ1
    668  1bd1		       85 0c		      STA	REFP1
    669  1bd3		       4c d0 1a 	      JMP	getbackearly	; 64
    670  1bd6
    671  1bd6				   kernel6
    672  1bd6		       a9 12		      lda	#<DF2DATAW
    673  1bd8		       85 1b		      STA	GRP0	; 25 (VDEL)
    674  1bda		       a9 23		      lda	#<DF3FLAG
    675  1bdc		       85 1f		      STA	ENABL	; 30 (VDEL)
    676  1bde		       a9 19		      lda	#<DF1FRACDATA
    677  1be0		       85 0f		      STA	PF2	; 35
    678  1be2		       a9 1d		      lda	#<DF5FRACDATA	; 37 NUSIZ/RESP info (OK here, GRP1 off)
    679  1be4		       85 05		      STA	NUSIZ1	; 40
    680  1be6		       85 0c		      STA	REFP1	; 43
    681  1be8		       a9 1a		      lda	#<DF2FRACDATA	;45
    682  1bea		       85 0f		      sta	PF2	; 48
    683  1bec		       a9 1b		      lda	#<DF3FRACDATA	;50
    684  1bee		       85 11		      sta	RESP1	;53
    685  1bf0							; do a move right by 15
    686  1bf0		       85 0e		      sta	PF1	; 56
    687  1bf2		       86 21		      stx	HMP1	; 59
    688  1bf4		       a9 19		      lda	#<DF1FRACDATA
    689  1bf6		       85 0f		      sta	PF2	; 64 (PF2L)
    690  1bf8		       a9 18		      lda	#<DF0FRACDATA
    691  1bfa		       85 0e		      sta	PF1	; 69 (PF1L) too early?
    692  1bfc		       a9 08		      lda	#<DF0DATA	; 71
    693  1bfe		       85 2a		      sta	HMOVE	; 74 adjust to +15 right
    694  1c00
    695  1c00		       85 06		      STA	COLUP0	; 1
    696  1c02		       a9 09		      lda	#<DF1DATA
    697  1c04		       85 07		      sta	COLUP1	; 6
    698  1c06		       a9 0b		      lda	#<DF3DATA
    699  1c08		       85 1c		      STA	GRP1	; 11
    700  1c0a		       a9 20		      lda	#<DF0FLAG
    701  1c0c		       85 1d		      STA	ENAM0	; 16
    702  1c0e		       a9 1e		      lda	#<DF6FRACDATA
    703  1c10		       85 09		      STA	COLUBK	; 21
    704  1c12		       a9 1c		      lda	#<DF4FRACDATA
    705  1c14		       85 08		      sta	COLUPF	; 26
      0  1c16					      sleep	2
      1  1c16				   .CYCLES    SET	2
      2  1c16
      3  1c16				  -	      IF	.CYCLES < 2
      4  1c16				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c16				  -	      ERR
      6  1c16					      ENDIF
      7  1c16
      8  1c16				  -	      IF	.CYCLES & 1
      9  1c16				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c16				  -	      nop	0
     11  1c16				  -	      ELSE
     12  1c16				  -	      bit	VSYNC
     13  1c16				  -	      ENDIF
     14  1c16				  -.CYCLES    SET	.CYCLES - 3
     15  1c16					      ENDIF
     16  1c16
     17  1c16					      REPEAT	.CYCLES / 2
     18  1c16		       ea		      nop
     19  1c17					      REPEND
    707  1c17		       4c 7a 1a 	      jmp	loop3	; 31
    708  1c1a
    709  1c1a				   kernel7
    710  1c1a		       a9 12		      lda	#<DF2DATAW
    711  1c1c		       85 1b		      STA	GRP0	; 25 (VDEL)
    712  1c1e		       a9 23		      lda	#<DF3FLAG
    713  1c20		       85 1f		      STA	ENABL	; 30 (VDEL)
    714  1c22		       a9 19		      lda	#<DF1FRACDATA
    715  1c24		       85 0f		      STA	PF2	; 35
    716  1c26		       a9 1d		      lda	#<DF5FRACDATA	; 37 NUSIZ/RESP info (OK here, GRP1 off)
    717  1c28		       85 05		      STA	NUSIZ1	; 40
    718  1c2a		       85 0c		      STA	REFP1	; 43
    719  1c2c		       a9 1a		      lda	#<DF2FRACDATA	;45
    720  1c2e		       85 0f		      sta	PF2	; 48
      0  1c30					      sleep	2
      1  1c30				   .CYCLES    SET	2
      2  1c30
      3  1c30				  -	      IF	.CYCLES < 2
      4  1c30				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c30				  -	      ERR
      6  1c30					      ENDIF
      7  1c30
      8  1c30				  -	      IF	.CYCLES & 1
      9  1c30				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c30				  -	      nop	0
     11  1c30				  -	      ELSE
     12  1c30				  -	      bit	VSYNC
     13  1c30				  -	      ENDIF
     14  1c30				  -.CYCLES    SET	.CYCLES - 3
     15  1c30					      ENDIF
     16  1c30
     17  1c30					      REPEAT	.CYCLES / 2
     18  1c30		       ea		      nop
     19  1c31					      REPEND
    722  1c31		       85 11		      sta	RESP1	;53
    723  1c33		       a9 1b		      lda	#<DF3FRACDATA	;55
    724  1c35		       85 0e		      sta	PF1	; 58
      0  1c37					      sleep	3
      1  1c37				   .CYCLES    SET	3
      2  1c37
      3  1c37				  -	      IF	.CYCLES < 2
      4  1c37				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c37				  -	      ERR
      6  1c37					      ENDIF
      7  1c37
      8  1c37					      IF	.CYCLES & 1
      9  1c37					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c37		       04 00		      nop	0
     11  1c39				  -	      ELSE
     12  1c39				  -	      bit	VSYNC
     13  1c39					      ENDIF
     14  1c39				   .CYCLES    SET	.CYCLES - 3
     15  1c39					      ENDIF
     16  1c39
     17  1c39				  -	      REPEAT	.CYCLES / 2
     18  1c39				  -	      nop
     19  1c39					      REPEND
    726  1c39		       4c d0 1a 	      JMP	getbackearly	; 64
    727  1c3c
    728  1c3c				   kernel8
    729  1c3c		       a9 12		      lda	#<DF2DATAW
    730  1c3e		       85 1b		      STA	GRP0	; (VDEL)
    731  1c40		       a9 23		      lda	#<DF3FLAG
    732  1c42		       85 1f		      STA	ENABL	; (VDEL)
    733  1c44		       a9 19		      lda	#<DF1FRACDATA
    734  1c46		       85 0f		      STA	PF2	; 35
    735  1c48		       a9 1d		      lda	#<DF5FRACDATA	; 37 NUSIZ/RESP info (OK here, GRP1 off)
    736  1c4a		       85 05		      STA	NUSIZ1	; 40
    737  1c4c		       85 0c		      STA	REFP1	; 43
    738  1c4e		       a9 1a		      lda	#<DF2FRACDATA	;45
    739  1c50		       85 0f		      sta	PF2	; 48
    740  1c52		       a9 1b		      lda	#<DF3FRACDATA	;50
    741  1c54		       85 0e		      sta	PF1	; 53
      0  1c56					      sleep	2
      1  1c56				   .CYCLES    SET	2
      2  1c56
      3  1c56				  -	      IF	.CYCLES < 2
      4  1c56				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c56				  -	      ERR
      6  1c56					      ENDIF
      7  1c56
      8  1c56				  -	      IF	.CYCLES & 1
      9  1c56				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c56				  -	      nop	0
     11  1c56				  -	      ELSE
     12  1c56				  -	      bit	VSYNC
     13  1c56				  -	      ENDIF
     14  1c56				  -.CYCLES    SET	.CYCLES - 3
     15  1c56					      ENDIF
     16  1c56
     17  1c56					      REPEAT	.CYCLES / 2
     18  1c56		       ea		      nop
     19  1c57					      REPEND
    743  1c57		       85 11		      sta	RESP1	;58
      0  1c59					      sleep	3
      1  1c59				   .CYCLES    SET	3
      2  1c59
      3  1c59				  -	      IF	.CYCLES < 2
      4  1c59				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c59				  -	      ERR
      6  1c59					      ENDIF
      7  1c59
      8  1c59					      IF	.CYCLES & 1
      9  1c59					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c59		       04 00		      nop	0
     11  1c5b				  -	      ELSE
     12  1c5b				  -	      bit	VSYNC
     13  1c5b					      ENDIF
     14  1c5b				   .CYCLES    SET	.CYCLES - 3
     15  1c5b					      ENDIF
     16  1c5b
     17  1c5b				  -	      REPEAT	.CYCLES / 2
     18  1c5b				  -	      nop
     19  1c5b					      REPEND
    745  1c5b		       4c d0 1a 	      JMP	getbackearly	; 64
    746  1c5e
    747  1c5e				   kernel9
    748  1c5e		       a9 12		      lda	#<DF2DATAW
    749  1c60		       85 1b		      STA	GRP0	; (VDEL)
    750  1c62		       a9 23		      lda	#<DF3FLAG
    751  1c64		       85 1f		      STA	ENABL	; (VDEL)
    752  1c66		       a9 19		      lda	#<DF1FRACDATA
    753  1c68		       85 0f		      STA	PF2	; 35
    754  1c6a		       a9 1d		      lda	#<DF5FRACDATA	; 37 NUSIZ/RESP info (OK here, GRP1 off)
    755  1c6c		       85 05		      STA	NUSIZ1	; 40
    756  1c6e		       85 0c		      STA	REFP1	; 43
    757  1c70		       a9 1a		      lda	#<DF2FRACDATA	;45
    758  1c72		       85 0f		      sta	PF2	; 48
    759  1c74		       a9 1b		      lda	#<DF3FRACDATA	;50
    760  1c76		       85 0e		      sta	PF1	; 53
      0  1c78					      sleep	5
      1  1c78				   .CYCLES    SET	5
      2  1c78
      3  1c78				  -	      IF	.CYCLES < 2
      4  1c78				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c78				  -	      ERR
      6  1c78					      ENDIF
      7  1c78
      8  1c78					      IF	.CYCLES & 1
      9  1c78					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c78		       04 00		      nop	0
     11  1c7a				  -	      ELSE
     12  1c7a				  -	      bit	VSYNC
     13  1c7a					      ENDIF
     14  1c7a				   .CYCLES    SET	.CYCLES - 3
     15  1c7a					      ENDIF
     16  1c7a
     17  1c7a					      REPEAT	.CYCLES / 2
     18  1c7a		       ea		      nop
     19  1c7b					      REPEND
    762  1c7b		       a9 18		      lda	#<DF0FRACDATA
    763  1c7d		       85 11		      sta	RESP1	;63
      0  1c7f					      sleep	3
      1  1c7f				   .CYCLES    SET	3
      2  1c7f
      3  1c7f				  -	      IF	.CYCLES < 2
      4  1c7f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c7f				  -	      ERR
      6  1c7f					      ENDIF
      7  1c7f
      8  1c7f					      IF	.CYCLES & 1
      9  1c7f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c7f		       04 00		      nop	0
     11  1c81				  -	      ELSE
     12  1c81				  -	      bit	VSYNC
     13  1c81					      ENDIF
     14  1c81				   .CYCLES    SET	.CYCLES - 3
     15  1c81					      ENDIF
     16  1c81
     17  1c81				  -	      REPEAT	.CYCLES / 2
     18  1c81				  -	      nop
     19  1c81					      REPEND
    765  1c81		       85 0e		      sta	PF1	; 69 (PF1L) too early?
    766  1c83		       4c 5e 1a 	      jmp	loop	;72
    767  1c86
    768  1c86				   kernel10
    769  1c86		       a9 12		      lda	#<DF2DATAW
    770  1c88		       85 1b		      STA	GRP0	; 25 (VDEL)
    771  1c8a		       a9 23		      lda	#<DF3FLAG
    772  1c8c		       85 1f		      STA	ENABL	; 30 (VDEL)
    773  1c8e		       a9 19		      lda	#<DF1FRACDATA
    774  1c90		       85 0f		      STA	PF2	; 35
    775  1c92		       a9 1d		      lda	#<DF5FRACDATA	; 37 NUSIZ/RESP info (OK here, GRP1 off)
    776  1c94		       85 05		      STA	NUSIZ1	; 40
    777  1c96		       85 0c		      STA	REFP1	; 43
    778  1c98		       a9 1a		      lda	#<DF2FRACDATA	;45
    779  1c9a		       85 0f		      sta	PF2	; 48
    780  1c9c		       a9 1b		      lda	#<DF3FRACDATA	;50
    781  1c9e		       85 0e		      sta	PF1	; 53
      0  1ca0					      sleep	6
      1  1ca0				   .CYCLES    SET	6
      2  1ca0
      3  1ca0				  -	      IF	.CYCLES < 2
      4  1ca0				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1ca0				  -	      ERR
      6  1ca0					      ENDIF
      7  1ca0
      8  1ca0				  -	      IF	.CYCLES & 1
      9  1ca0				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1ca0				  -	      nop	0
     11  1ca0				  -	      ELSE
     12  1ca0				  -	      bit	VSYNC
     13  1ca0				  -	      ENDIF
     14  1ca0				  -.CYCLES    SET	.CYCLES - 3
     15  1ca0					      ENDIF
     16  1ca0
     17  1ca0					      REPEAT	.CYCLES / 2
     18  1ca0		       ea		      nop
     17  1ca0					      REPEND
     18  1ca1		       ea		      nop
     17  1ca1					      REPEND
     18  1ca2		       ea		      nop
     19  1ca3					      REPEND
    783  1ca3		       a9 18		      lda	#<DF0FRACDATA
    784  1ca5		       ae 08 10 	      LDX	DF0DATA	; 65
    785  1ca8		       85 11		      sta	RESP1	; 68
    786  1caa		       85 0e		      STA	PF1	; 71
    787  1cac		       a9 09		      lda	#<DF1DATA	; 74
    788  1cae		       86 06		      STX	COLUP0	; 0
    789  1cb0		       4c 64 1a 	      jmp	loop2	; 3
    790  1cb3
    791  1cb3				   kernel11
    792  1cb3		       a9 12		      lda	#<DF2DATAW
    793  1cb5		       85 1b		      STA	GRP0	; (VDEL)
    794  1cb7		       a9 23		      lda	#<DF3FLAG
    795  1cb9		       85 1f		      STA	ENABL	; (VDEL)
    796  1cbb		       a9 19		      lda	#<DF1FRACDATA
    797  1cbd		       85 0f		      STA	PF2	; 35
    798  1cbf		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    799  1cc1		       85 05		      STA	NUSIZ1
    800  1cc3		       85 0c		      STA	REFP1
    801  1cc5		       a9 1a		      lda	#<DF2FRACDATA	;45
    802  1cc7		       85 0f		      sta	PF2	; 48
    803  1cc9		       a9 1b		      lda	#<DF3FRACDATA	;50
    804  1ccb		       85 0e		      sta	PF1	; 53
      0  1ccd					      sleep	3
      1  1ccd				   .CYCLES    SET	3
      2  1ccd
      3  1ccd				  -	      IF	.CYCLES < 2
      4  1ccd				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1ccd				  -	      ERR
      6  1ccd					      ENDIF
      7  1ccd
      8  1ccd					      IF	.CYCLES & 1
      9  1ccd					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1ccd		       04 00		      nop	0
     11  1ccf				  -	      ELSE
     12  1ccf				  -	      bit	VSYNC
     13  1ccf					      ENDIF
     14  1ccf				   .CYCLES    SET	.CYCLES - 3
     15  1ccf					      ENDIF
     16  1ccf
     17  1ccf				  -	      REPEAT	.CYCLES / 2
     18  1ccf				  -	      nop
     19  1ccf					      REPEND
    806  1ccf		       a9 19		      lda	#<DF1FRACDATA	;45
    807  1cd1		       85 0f		      sta	PF2	; 61
    808  1cd3		       ae 08 10 	      LDX	DF0DATA	; 65
    809  1cd6
    810  1cd6		       a9 18		      lda	#<DF0FRACDATA	; 67
    811  1cd8		       85 0e		      sta	PF1	; 70
    812  1cda		       85 11		      sta	RESP1	; 73
    813  1cdc		       86 06		      STX	COLUP0	; 0
    814  1cde		       a9 09		      lda	#<DF1DATA	; 2
    815  1ce0		       85 07		      sta	COLUP1	; 5
    816  1ce2		       a9 0b		      lda	#<DF3DATA
    817  1ce4		       85 1c		      STA	GRP1	; 10
    818  1ce6		       a9 20		      lda	#<DF0FLAG
    819  1ce8		       85 1d		      STA	ENAM0	; 25
    820  1cea		       a9 1e		      lda	#<DF6FRACDATA
    821  1cec		       85 09		      STA	COLUBK	; 20
    822  1cee		       a9 1c		      lda	#<DF4FRACDATA
    823  1cf0		       85 08		      sta	COLUPF	; 25
      0  1cf2					      sleep	3
      1  1cf2				   .CYCLES    SET	3
      2  1cf2
      3  1cf2				  -	      IF	.CYCLES < 2
      4  1cf2				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1cf2				  -	      ERR
      6  1cf2					      ENDIF
      7  1cf2
      8  1cf2					      IF	.CYCLES & 1
      9  1cf2					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1cf2		       04 00		      nop	0
     11  1cf4				  -	      ELSE
     12  1cf4				  -	      bit	VSYNC
     13  1cf4					      ENDIF
     14  1cf4				   .CYCLES    SET	.CYCLES - 3
     15  1cf4					      ENDIF
     16  1cf4
     17  1cf4				  -	      REPEAT	.CYCLES / 2
     18  1cf4				  -	      nop
     19  1cf4					      REPEND
    825  1cf4		       4c 7a 1a 	      jmp	loop3	; 31
    826  1cf7
    827  1cf7				   set_fetchers
    828  1cf7		       ad 62 1d 	      lda	dflow
    829  1cfa		       8d 50 10 	      sta	DF0LOW
    830  1cfd		       ad 6a 1d 	      lda	dfhigh
    831  1d00		       8d 68 10 	      sta	DF0HI
    832  1d03
    833  1d03		       ad 63 1d 	      lda	dflow+1
    834  1d06		       8d 51 10 	      sta	DF1LOW
    835  1d09		       ad 6b 1d 	      lda	dfhigh+1
    836  1d0c		       8d 69 10 	      sta	DF1HI
    837  1d0f
    838  1d0f		       ad 64 1d 	      lda	dflow+2
    839  1d12		       8d 52 10 	      sta	DF2LOW
    840  1d15		       ad 6c 1d 	      lda	dfhigh+2
    841  1d18		       8d 6a 10 	      sta	DF2HI
    842  1d1b
    843  1d1b				   set_fetchers36		; sets just 3-6
    844  1d1b		       ad 65 1d 	      lda	dflow+3
    845  1d1e		       8d 53 10 	      sta	DF3LOW
    846  1d21		       ad 6d 1d 	      lda	dfhigh+3
    847  1d24		       8d 6b 10 	      sta	DF3HI
    848  1d27
    849  1d27		       ad 66 1d 	      lda	dflow+4
    850  1d2a		       8d 54 10 	      sta	DF4LOW
    851  1d2d		       ad 6e 1d 	      lda	dfhigh+4
    852  1d30		       8d 6c 10 	      sta	DF4HI
    853  1d33
    854  1d33		       ad 67 1d 	      lda	dflow+5
    855  1d36		       8d 55 10 	      sta	DF5LOW
    856  1d39		       ad 6f 1d 	      lda	dfhigh+5
    857  1d3c		       8d 6d 10 	      sta	DF5HI
    858  1d3f
    859  1d3f		       ad 68 1d 	      lda	dflow+6
    860  1d42		       8d 56 10 	      sta	DF6LOW
    861  1d45		       ad 70 1d 	      lda	dfhigh+6
    862  1d48		       8d 6e 10 	      sta	DF6HI
    863  1d4b
    864  1d4b		       60		      rts
    865  1d4c
    866  1d4c							;9d bad
    867  1d4c							; the below isn't quite right
    868  1d4c							;DF0DATA: COLUP0
    869  1d4c							;DF1DATA: COLUP1
    870  1d4c							;DF2DATAW: GRP0
    871  1d4c							;DF3DATA: GRP1
    872  1d4c							;DF4DATA: 2lk lines until repos/HMP1
    873  1d4c							;DF5DATA: low byte of repo kernels (xpos mod 15)
    874  1d4c							;DF6DATA: High byte of repo kernels (x pos div 15)
    875  1d4c							;DF7DATA: Programmer's stack
    876  1d4c							;DF0FRACDATA: PF1L
    877  1d4c							;DF1FRACDATA: PF2L
    878  1d4c							;DF4FRACDATA: COLUPF
    879  1d4c							;DF2FRACDATA: PF2R
    880  1d4c							;DF3FRACDATA: PF2L
    881  1d4c							;DF5FRACDATA: Sprite NUSIZ1/REFP1 (only during repos)
    882  1d4c							;DF6FRACDATA: COLUBK
    883  1d4c							;DF7FRACDATA: HMP1
    884  1d4c							;DF3FLAG: kernel exit loop ?? (use flags instead?)
    885  1d4c							;DF0FLAG: ENAM0
    886  1d4c							;DF1FLAG: ENAM1
    887  1d4c							;DF3FLAG: ENABL
    888  1d4c
    889  1d4c				   fetcher_address_table
    890  1d4c				   kernello
    891  1d4c		       2c		      .byte.b	<kernel1
    892  1d4d		       4e		      .byte.b	<kernel2
    893  1d4e		       70		      .byte.b	<kernel3
    894  1d4f		       92		      .byte.b	<kernel4
    895  1d50		       b4		      .byte.b	<kernel5
    896  1d51		       d6		      .byte.b	<kernel6
    897  1d52		       1a		      .byte.b	<kernel7
    898  1d53		       3c		      .byte.b	<kernel8
    899  1d54		       5e		      .byte.b	<kernel9
    900  1d55		       86		      .byte.b	<kernel10
    901  1d56		       b3		      .byte.b	<kernel11
    902  1d57				   kernelhi
    903  1d57		       1b		      .byte.b	>kernel1
    904  1d58		       1b		      .byte.b	>kernel2
    905  1d59		       1b		      .byte.b	>kernel3
    906  1d5a		       1b		      .byte.b	>kernel4
    907  1d5b		       1b		      .byte.b	>kernel5
    908  1d5c		       1b		      .byte.b	>kernel6
    909  1d5d		       1c		      .byte.b	>kernel7
    910  1d5e		       1c		      .byte.b	>kernel8
    911  1d5f		       1c		      .byte.b	>kernel9
    912  1d60		       1c		      .byte.b	>kernel10
    913  1d61		       1c		      .byte.b	>kernel11
    914  1d62				   dflow
    915  1d62		       08		      .byte.b	<P0COLOR
    916  1d63		       08		      .byte.b	<P1COLOR
    917  1d64		       08		      .byte.b	<P0GFX
    918  1d65		       08		      .byte.b	<P1GFX
    919  1d66		       2d		      .byte.b	<P1SKIP
    920  1d67		       08		      .byte.b	<JUMPTABLELO
    921  1d68		       14		      .byte.b	<JUMPTABLEHI
    922  1d69		       a5		      .byte.b	<USERSTACK
    923  1d6a				   dfhigh
    924  1d6a		       05		      .byte.b	(>P0COLOR) & $0F
    925  1d6b		       03		      .byte.b	(>P1COLOR) & $0F
    926  1d6c		       04		      .byte.b	(>P0GFX) & $0F
    927  1d6d		       02		      .byte.b	(>P1GFX) & $0F
    928  1d6e		       0b		      .byte.b	(>P1SKIP) & $0F
    929  1d6f		       0b		      .byte.b	(>JUMPTABLELO) & $0F
    930  1d70		       0b		      .byte.b	(>JUMPTABLEHI) & $0F
    931  1d71		       0d		      .byte.b	(>USERSTACK) & $0F
    932  1d72				   dffraclow
    933  1d72		       08		      .byte.b	<PF1L
    934  1d73		       08		      .byte.b	<PF2L
    935  1d74		       08		      .byte.b	<PF1R
    936  1d75		       08		      .byte.b	<PF2R
    937  1d76		       08		      .byte.b	<PFCOLS
    938  1d77		       39		      .byte.b	<NUSIZREFP
    939  1d78		       a5		      .byte.b	<BKCOLS
    940  1d79		       20		      .byte.b	<P1HMP
    941  1d7a				   dffrachi
    942  1d7a		       06		      .byte.b	(>PF1L) & $0F
    943  1d7b		       07		      .byte.b	(>PF2L) & $0F
    944  1d7c		       08		      .byte.b	(>PF1R) & $0F
    945  1d7d		       09		      .byte.b	(>PF2R) & $0F
    946  1d7e		       0a		      .byte.b	(>PFCOLS) & $0F
    947  1d7f		       0b		      .byte.b	(>NUSIZREFP) & $0F
    948  1d80		       0b		      .byte.b	(>BKCOLS) & $0F
    949  1d81		       0b		      .byte.b	(>P1HMP) & $0F
    950  1d82				   scorepointer
    951  1d82		       94		      .byte.b	<scoretable
    952  1d83		       08		      .byte.b	((>scoretable) & $0f) | (((>scoretable) / 2) & $70)
    953  1d84				   scoresetup		; pointers to digit graphics
    954  1d84		       45		      .byte.b	<scoredata
    955  1d85		       0b		      .byte.b	(>scoredata) & $0F
    956  1d86				   Hmval		; 112 wuz first
    957  1d86		       60 50 40 30*	      .byte.b	96, 80, 64, 48, 32, 16, 1, 240
    958  1d8e				   Hmval74
    959  1d8e		       e0 d0 c0 b0*	      .byte.b	224, 208, 192, 176, 160, 144, 128
    960  1d95		       60 50 40 30*	      .byte.b	96, 80, 64, 48, 32, 16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96
    961  1da5		       50 40 30 20*	      .byte.b	80, 64, 48, 32, 16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80
    962  1db5		       40 30 20 10*	      .byte.b	64, 48, 32, 16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64
    963  1dc5		       30 20 10 01*	      .byte.b	48, 32, 16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48
    964  1dd5		       20 10 01 f0*	      .byte.b	32, 16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48, 32
    965  1de5		       10 01 f0 e0*	      .byte.b	16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48, 32, 16
    966  1df5		       01 f0 e0 d0*	      .byte.b	1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48, 32, 16, 1
    967  1e05		       f0 e0 d0 c0*	      .byte.b	240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48, 32, 16, 1, 240
    968  1e15		       e0 d0 c0 b0*	      .byte.b	224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48, 32, 16, 1, 240, 224, 208, 192
    969  1e27		       b0 a0 90 80*	      .byte.b	176,160,144,128,16,1,240,224
    970  1e2f
    971  1e2f
    972  1e2f				   kernel_setup
    973  1e2f							;--position P0, top P1, M0, M1, BL
    974  1e2f		       a2 00		      ldx	#0	; first sprite displayed
    975  1e31		       b5 85		      lda	SpriteGfxIndex,x
    976  1e33		       aa		      tax
    977  1e34		       b5 90		      lda	player1x,x
    978  1e36		       c9 a0		      cmp	#160
    979  1e38		       90 0a		      bcc	nostorep1
    980  1e3a		       c9 d0		      cmp	#208
    981  1e3c		       b0 02		      bcs	ksadjustdown
    982  1e3e							; 160-208: minus 160
    983  1e3e							;add 160 is like minus 96
    984  1e3e							; so minus 64
    985  1e3e		       e9 3f		      sbc	#63	;cc
    986  1e40				   ksadjustdown
    987  1e40							; 209-255: add 160
    988  1e40		       69 9f		      adc	#159	; cs
    989  1e42		       95 90		      sta	player1x,x
    990  1e44				   nostorep1
    991  1e44		       85 02		      sta	WSYNC
    992  1e46		       a2 04		      ldx	#4
    993  1e48		       85 81		      sta	topP1x	; cache top p1
    994  1e4a				   HorPosLoop
    995  1e4a		       b5 80		      lda	player0x,X
    996  1e4c		       38		      sec
    997  1e4d				   DivideLoop
    998  1e4d		       e9 0f		      sbc	#15
    999  1e4f		       b0 fc		      bcs	DivideLoop
      0  1e51					      sleep	4
      1  1e51				   .CYCLES    SET	4
      2  1e51
      3  1e51				  -	      IF	.CYCLES < 2
      4  1e51				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1e51				  -	      ERR
      6  1e51					      ENDIF
      7  1e51
      8  1e51				  -	      IF	.CYCLES & 1
      9  1e51				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1e51				  -	      nop	0
     11  1e51				  -	      ELSE
     12  1e51				  -	      bit	VSYNC
     13  1e51				  -	      ENDIF
     14  1e51				  -.CYCLES    SET	.CYCLES - 3
     15  1e51					      ENDIF
     16  1e51
     17  1e51					      REPEAT	.CYCLES / 2
     18  1e51		       ea		      nop
     17  1e51					      REPEND
     18  1e52		       ea		      nop
     19  1e53					      REPEND
   1001  1e53		       95 10		      sta	RESP0,X
   1002  1e55		       85 02		      sta	WSYNC
   1003  1e57		       ca		      dex		;2
   1004  1e58		       10 f0		      bpl	HorPosLoop	;4/5
   1005  1e5a
   1006  1e5a		       a4 80		      ldy	player0x	; 7
   1007  1e5c		       b9 86 1d 	      lda	Hmval,y	; 11
   1008  1e5f		       85 20		      sta	HMP0	; 14
   1009  1e61
   1010  1e61		       a4 81		      ldy	player0x+1
   1011  1e63		       b9 86 1d 	      lda	Hmval,y
   1012  1e66		       85 21		      sta	HMP0+1	; 24
   1013  1e68
   1014  1e68		       a4 82		      ldy	player0x+2
   1015  1e6a		       b9 86 1d 	      lda	Hmval,y
   1016  1e6d		       85 22		      sta	HMP0+2	; 34
   1017  1e6f
   1018  1e6f		       a4 83		      ldy	player0x+3
   1019  1e71		       b9 86 1d 	      lda	Hmval,y
   1020  1e74		       85 23		      sta	HMP0+3	; 44
   1021  1e76
   1022  1e76		       a4 84		      ldy	player0x+4
   1023  1e78		       b9 86 1d 	      lda	Hmval,y
   1024  1e7b		       85 24		      sta	HMP0+4	; 54
   1025  1e7d
   1026  1e7d		       85 02		      sta	WSYNC
   1027  1e7f		       85 2a		      sta	HMOVE
   1028  1e81
   1029  1e81				   myrts
   1030  1e81		       60		      rts
   1031  1e82
   1032  1e82
   1033  1e82				   pfsetup
   1034  1e82
   1035  1e82		       84 cb		      sty	temp1
   1036  1e84		       85 cc		      sta	temp2
   1037  1e86		       86 cd		      stx	temp3
   1038  1e88		       a2 03		      ldx	#3
   1039  1e8a				   pfsetupp
   1040  1e8a		       bd 72 1d 	      lda	dffraclow,x
   1041  1e8d		       9d 50 10 	      sta	DF0LOW,x
   1042  1e90		       bd 7a 1d 	      lda	dffrachi,x
   1043  1e93		       9d 68 10 	      sta	DF0HI,x
   1044  1e96		       a5 cc		      lda	temp2
   1045  1e98		       8d 59 10 	      sta	PARAMETER
   1046  1e9b		       a5 cd		      lda	temp3
   1047  1e9d		       8d 59 10 	      sta	PARAMETER
   1048  1ea0		       8e 59 10 	      stx	PARAMETER
   1049  1ea3		       8c 59 10 	      sty	PARAMETER
   1050  1ea6		       a9 01		      LDA	#1
   1051  1ea8		       8d 5a 10 	      sta	CALLFUNCTION
   1052  1eab		       18		      clc
   1053  1eac		       a5 cc		      lda	temp2
   1054  1eae		       65 cb		      adc	temp1
   1055  1eb0		       85 cc		      sta	temp2
   1056  1eb2		       a5 cd		      lda	temp3
   1057  1eb4		       69 00		      adc	#0
   1058  1eb6		       85 cd		      sta	temp3
   1059  1eb8		       ca		      dex
   1060  1eb9		       10 cf		      bpl	pfsetupp
      0  1ebb					      RETURN
      1  1ebb				  -	      ifnconst	bankswitch
      2  1ebb				  -	      rts
      3  1ebb					      else
      4  1ebb		       4c e0 df 	      jmp	BS_return
      5  1ebe					      endif
   1062  1ebe
   1063  1ebe
   1064  1ebe				   scorekernel
   1065  1ebe				  -	      ifconst	minikernel
   1066  1ebe				  -			;; disable fast fetch, call the minikernel, and re-enable fast fetch
   1067  1ebe				  -	      lda	#255
   1068  1ebe				  -	      sta	FASTFETCH
   1069  1ebe				  -	      jsr	minikernel
   1070  1ebe				  -	      lda	#0
   1071  1ebe				  -	      sta.w	FASTFETCH
   1072  1ebe					      endif
   1073  1ebe		       a6 eb		      ldx	scorecolor
   1074  1ec0		       86 06		      stx	COLUP0
   1075  1ec2		       86 07		      stx	COLUP1
   1076  1ec4		       a2 00		      ldx	#0
   1077  1ec6		       86 0e		      STx	PF1
   1078  1ec8		       86 0b		      stx	REFP0
   1079  1eca		       86 0c		      stx	REFP1
   1080  1ecc		       86 1b		      STx	GRP0
   1081  1ece		       86 1c		      STx	GRP1
   1082  1ed0		       86 0f		      STx	PF2
   1083  1ed2		       86 2b		      stx	HMCLR
   1084  1ed4		       86 1d		      stx	ENAM0
   1085  1ed6		       86 1e		      stx	ENAM1
   1086  1ed8		       86 1f		      stx	ENABL
   1087  1eda
   1088  1eda
   1089  1eda				  -	      ifconst	pfscore
   1090  1eda				  -	      lda	pfscorecolor
   1091  1eda				  -	      sta	COLUPF
   1092  1eda					      endif
   1093  1eda
   1094  1eda				  -	      ifconst	noscore
   1095  1eda				  -	      rts
   1096  1eda					      endif
   1097  1eda
   1098  1eda		       85 2b		      sta	HMCLR
   1099  1edc		       a2 f0		      ldx	#$f0
   1100  1ede		       86 20		      stx	HMP0
   1101  1ee0
   1102  1ee0							; set up fetchers 0-5 to handle score digits
   1103  1ee0		       a2 45		      ldx	#<(scoredata)
   1104  1ee2		       8e 56 10 	      stx	DF6LOW
   1105  1ee5		       a2 0b		      ldx	#(>(scoredata)) & $0F
   1106  1ee7		       8e 6e 10 	      stx	DF6HI
   1107  1eea		       a2 4d		      ldx	#<(scoredata+8)
   1108  1eec		       8e 50 10 	      stx	DF0LOW
   1109  1eef		       a2 0b		      ldx	#(>(scoredata+8)) & $0F
   1110  1ef1		       8e 68 10 	      stx	DF0HI
   1111  1ef4		       a2 55		      ldx	#<(scoredata+16)
   1112  1ef6		       8e 51 10 	      stx	DF1LOW
   1113  1ef9							; cycle 0??
   1114  1ef9		       a2 0b		      ldx	#(>(scoredata+16)) & $0F
   1115  1efb		       8e 69 10 	      stx	DF1HI
   1116  1efe		       a2 5d		      ldx	#<(scoredata+24)
   1117  1f00		       8e 52 10 	      stx	DF2LOW
   1118  1f03		       a2 0b		      ldx	#(>(scoredata+24)) & $0F
   1119  1f05		       8e 6a 10 	      stx	DF2HI
   1120  1f08
   1121  1f08		       85 02		      sta	WSYNC
   1122  1f0a		       a2 00		      ldx	#0
   1123  1f0c		       86 1b		      STx	GRP0
   1124  1f0e		       86 1c		      STx	GRP1	; seems to be needed because of vdel
   1125  1f10
   1126  1f10		       a2 65		      ldx	#<(scoredata+32)
   1127  1f12		       8e 53 10 	      stx	DF3LOW
   1128  1f15		       a2 0b		      ldx	#(>(scoredata+32)) & $0F
   1129  1f17		       8e 6b 10 	      stx	DF3HI
   1130  1f1a		       a2 6d		      ldx	#<(scoredata+40)
   1131  1f1c		       8e 54 10 	      stx	DF4LOW
   1132  1f1f		       a2 0b		      ldx	#(>(scoredata+40)) & $0F
   1133  1f21		       8e 6c 10 	      stx	DF4HI
   1134  1f24
   1135  1f24		       a0 07		      LDY	#7
   1136  1f26		       a2 03		      LDx	#$03
   1137  1f28		       84 25		      STY	VDELP0
   1138  1f2a		       85 10		      STA	RESP0
   1139  1f2c		       85 11		      STA	RESP1
   1140  1f2e		       84 cb		      sty	temp1
   1141  1f30
   1142  1f30		       86 04		      STx	NUSIZ0
   1143  1f32		       86 05		      STx	NUSIZ1
   1144  1f34		       86 26		      STx	VDELP1
   1145  1f36		       a2 75		      ldx	#<(scoredata+48)
   1146  1f38		       8e 55 10 	      stx	DF5LOW
   1147  1f3b		       a2 0b		      ldx	#(>(scoredata+48)) & $0F
   1148  1f3d		       8e 6d 10 	      stx	DF5HI
   1149  1f40		       8d 2a 00 	      STA.w	HMOVE	; cycle 73 ?
   1150  1f43				   scoreloop
   1151  1f43		       a9 0e		      lda	#<DF6DATA	;59
   1152  1f45		       85 06		      sta	COLUP0	;62
   1153  1f47		       85 07		      sta	COLUP1	;65
   1154  1f49		       a9 09		      lda	#<DF1DATA	;75
   1155  1f4b		       85 1b		      sta	GRP0	;2
   1156  1f4d		       a9 08		      lda	#<DF0DATA	;4
   1157  1f4f		       85 1c		      sta	GRP1	;7
   1158  1f51		       a9 0b		      lda	#<DF3DATA	;9
   1159  1f53		       85 1b		      sta	GRP0	;12
   1160  1f55
   1161  1f55							; REVENG - rearranged to correct pf write timing and A register overwrite
   1162  1f55				  -	      ifconst	pfscore
   1163  1f55				  -	      lda	pfscore1
   1164  1f55				  -	      sta	PF1
   1165  1f55					      else
      0  1f55					      sleep	6
      1  1f55				   .CYCLES    SET	6
      2  1f55
      3  1f55				  -	      IF	.CYCLES < 2
      4  1f55				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1f55				  -	      ERR
      6  1f55					      ENDIF
      7  1f55
      8  1f55				  -	      IF	.CYCLES & 1
      9  1f55				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1f55				  -	      nop	0
     11  1f55				  -	      ELSE
     12  1f55				  -	      bit	VSYNC
     13  1f55				  -	      ENDIF
     14  1f55				  -.CYCLES    SET	.CYCLES - 3
     15  1f55					      ENDIF
     16  1f55
     17  1f55					      REPEAT	.CYCLES / 2
     18  1f55		       ea		      nop
     17  1f55					      REPEND
     18  1f56		       ea		      nop
     17  1f56					      REPEND
     18  1f57		       ea		      nop
     19  1f58					      REPEND
   1167  1f58					      endif
      0  1f58					      sleep	5
      1  1f58				   .CYCLES    SET	5
      2  1f58
      3  1f58				  -	      IF	.CYCLES < 2
      4  1f58				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1f58				  -	      ERR
      6  1f58					      ENDIF
      7  1f58
      8  1f58					      IF	.CYCLES & 1
      9  1f58					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1f58		       04 00		      nop	0
     11  1f5a				  -	      ELSE
     12  1f5a				  -	      bit	VSYNC
     13  1f5a					      ENDIF
     14  1f5a				   .CYCLES    SET	.CYCLES - 3
     15  1f5a					      ENDIF
     16  1f5a
     17  1f5a					      REPEAT	.CYCLES / 2
     18  1f5a		       ea		      nop
     19  1f5b					      REPEND
   1169  1f5b		       ae 0a 10 	      ldx	DF2DATA	;16
   1170  1f5e		       ac 0d 10 	      ldy	DF5DATA	;20
   1171  1f61		       a9 0c		      lda	#<DF4DATA	;22
   1172  1f63
   1173  1f63		       86 1c		      stx	GRP1	;40
   1174  1f65		       84 1b		      sty	GRP0	;43
   1175  1f67		       85 1c		      sta	GRP1	;46
   1176  1f69		       85 1b		      sta	GRP0	;49
   1177  1f6b				  -	      ifconst	pfscore
   1178  1f6b				  -	      lda	pfscore2
   1179  1f6b				  -	      sta	PF1
   1180  1f6b					      else
      0  1f6b					      sleep	6
      1  1f6b				   .CYCLES    SET	6
      2  1f6b
      3  1f6b				  -	      IF	.CYCLES < 2
      4  1f6b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1f6b				  -	      ERR
      6  1f6b					      ENDIF
      7  1f6b
      8  1f6b				  -	      IF	.CYCLES & 1
      9  1f6b				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1f6b				  -	      nop	0
     11  1f6b				  -	      ELSE
     12  1f6b				  -	      bit	VSYNC
     13  1f6b				  -	      ENDIF
     14  1f6b				  -.CYCLES    SET	.CYCLES - 3
     15  1f6b					      ENDIF
     16  1f6b
     17  1f6b					      REPEAT	.CYCLES / 2
     18  1f6b		       ea		      nop
     17  1f6b					      REPEND
     18  1f6c		       ea		      nop
     17  1f6c					      REPEND
     18  1f6d		       ea		      nop
     19  1f6e					      REPEND
   1182  1f6e					      endif
   1183  1f6e							; sleep 2 ;57
      0  1f6e					      sleep	6
      1  1f6e				   .CYCLES    SET	6
      2  1f6e
      3  1f6e				  -	      IF	.CYCLES < 2
      4  1f6e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1f6e				  -	      ERR
      6  1f6e					      ENDIF
      7  1f6e
      8  1f6e				  -	      IF	.CYCLES & 1
      9  1f6e				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1f6e				  -	      nop	0
     11  1f6e				  -	      ELSE
     12  1f6e				  -	      bit	VSYNC
     13  1f6e				  -	      ENDIF
     14  1f6e				  -.CYCLES    SET	.CYCLES - 3
     15  1f6e					      ENDIF
     16  1f6e
     17  1f6e					      REPEAT	.CYCLES / 2
     18  1f6e		       ea		      nop
     17  1f6e					      REPEND
     18  1f6f		       ea		      nop
     17  1f6f					      REPEND
     18  1f70		       ea		      nop
     19  1f71					      REPEND
   1185  1f71		       c6 cb		      dec	temp1	;70
   1186  1f73		       10 ce		      bpl	scoreloop	;72/73
   1187  1f75		       a2 00		      LDx	#0
   1188  1f77		       86 0e		      stx	PF1
   1189  1f79		       86 1b		      STx	GRP0
   1190  1f7b		       86 1c		      STx	GRP1
   1191  1f7d		       86 25		      STx	VDELP0
   1192  1f7f		       86 26		      STx	VDELP1	;do we need these
   1193  1f81		       86 04		      STx	NUSIZ0
   1194  1f83		       86 05		      STx	NUSIZ1
   1195  1f85
   1196  1f85		       60		      rts
   1197  1f86
   1198  1f86
   1199  1f86				   game
   1200  1f86				   .L00 		;  bank 1
   1201  1f86
   1202  1f86				   .L01 		;  temp1  =  temp1
   1203  1f86
   1204  1f86		       a5 cb		      LDA	temp1
   1205  1f88		       85 cb		      STA	temp1
   1206  1f8a				   .
   1207  1f8a							;
   1208  1f8a
   1209  1f8a				   .L02 		;  set kernel DPC +
   1210  1f8a
   1211  1f8a				   .
   1212  1f8a							;
   1213  1f8a
   1214  1f8a				   .L03 		;  set tv ntsc
   1215  1f8a
   1216  1f8a				   .L04 		;  set kernel_options collision(playfield,player1)
   1217  1f8a
   1218  1f8a		       00 43	   DPC_kernel_options =	CXP1FB+$40
   1219  1f8a				   .
   1220  1f8a							;
   1221  1f8a
   1222  1f8a				   .L05 		;  const font	=  1
   1223  1f8a
   1224  1f8a				   .
   1225  1f8a							;
   1226  1f8a
   1227  1f8a				   .L06 		;  dim sc1  =	score
   1228  1f8a
   1229  1f8a				   .L07 		;  dim sc2  =	score + 1
   1230  1f8a
   1231  1f8a				   .L08 		;  dim sc3  =	score + 2
   1232  1f8a
   1233  1f8a				   .
   1234  1f8a							;
   1235  1f8a
   1236  1f8a				   .L09 		;  dim facesCounter  =  c
   1237  1f8a
   1238  1f8a				   .
   1239  1f8a							;
   1240  1f8a
   1241  1f8a				   .L010		;  dim eatSound  =  m
   1242  1f8a
   1243  1f8a				   .L011		;  const EAT_SOUND_LENGTH  =  10
   1244  1f8a
   1245  1f8a				   .L012		;  const EAT_SOUND_FREQUENCY  =  25
   1246  1f8a
   1247  1f8a				   .L013		;  const EAT_SOUND_VOLUME  =  8
   1248  1f8a
   1249  1f8a				   .
   1250  1f8a							;
   1251  1f8a
   1252  1f8a				   .L014		;  dim crashSound  =  m
   1253  1f8a
   1254  1f8a				   .L015		;  const CRASH_SOUND_LENGTH  =  8
   1255  1f8a
   1256  1f8a				   .L016		;  const CRASH_SOUND_FREQUENCY  =  4
   1257  1f8a
   1258  1f8a				   .L017		;  const CRASH_SOUND_VOLUME  =  6
   1259  1f8a
   1260  1f8a				   .
   1261  1f8a							;
   1262  1f8a
   1263  1f8a				   .L018		;  dim smileSound  =  m
   1264  1f8a
   1265  1f8a				   .L019		;  const SMILE_SOUND_LENGTH  =  8
   1266  1f8a
   1267  1f8a				   .L020		;  const SMILE_SOUND_FREQUENCY  =  4
   1268  1f8a
   1269  1f8a				   .L021		;  const SMILE_SOUND_VOLUME  =  6
   1270  1f8a
   1271  1f8a				   .
   1272  1f8a							;
   1273  1f8a
   1274  1f8a				   .L022		;  const GOBLIN_MIN_X	=  16
   1275  1f8a
   1276  1f8a				   .L023		;  const GOBLIN_MAX_X	=  136
   1277  1f8a
   1278  1f8a				   .L024		;  const GOBLIN_MIN_Y	=  0
   1279  1f8a
   1280  1f8a				   .L025		;  const GOBLIN_MAX_Y	=  160
   1281  1f8a
   1282  1f8a				   .L026		;  const GOBLIN_DELTA_X  =  8
   1283  1f8a
   1284  1f8a				   .L027		;  const GOBLIN_DELTA_Y  =  16
   1285  1f8a
   1286  1f8a				   .
   1287  1f8a							;
   1288  1f8a
   1289  1f8a				   .L028		;  const GOBLIN_TOP_BOUNDARY  =  255 - 24 + GOBLIN_MIN_Y
   1290  1f8a
   1291  1f8a				   .L029		;  const GOBLIN_BOTTOM_BOUNDARY  =  GOBLIN_MAX_Y
   1292  1f8a
   1293  1f8a				   .L030		;  const GOBLIN_LEFT_BOUNDARY	=  GOBLIN_MIN_X
   1294  1f8a
   1295  1f8a				   .L031		;  const GOBLIN_RIGHT_BOUNDARY  =  GOBLIN_MAX_X
   1296  1f8a
   1297  1f8a				   .
   1298  1f8a							;
   1299  1f8a
   1300  1f8a				   .
   1301  1f8a							;
   1302  1f8a
   1303  1f8a				   .L032		;  dim bits  =  z
   1304  1f8a
   1305  1f8a				   .L033		;  dim bits0_DebounceJoy0  =  z
   1306  1f8a
   1307  1f8a				   .
   1308  1f8a							;
   1309  1f8a
   1310  1f8a				   .L034		;  dim frames	=  f
   1311  1f8a
   1312  1f8a				   .L035		;  dim speed  =  s
   1313  1f8a
   1314  1f8a				   .
   1315  1f8a							;
   1316  1f8a
   1317  1f8a				   .L036		;  dim gameState  =  x
   1318  1f8a
   1319  1f8a				   .L037		;  dim gameStage  =  y
   1320  1f8a
   1321  1f8a				   .
   1322  1f8a							;
   1323  1f8a
   1324  1f8a				   .L038		;  const GAME_STATE_PLAYING  =  2
   1325  1f8a
   1326  1f8a				   .L039		;  const GAME_STATE_GAMEOVER  =  3
   1327  1f8a
   1328  1f8a				   .
   1329  1f8a							;
   1330  1f8a
   1331  1f8a				   .L040		;  goto _MAIN bank2
   1332  1f8a
   1333  1f8a		       85 81		      sta	temp7
   1334  1f8c		       a9 30		      lda	#>(._MAIN-1)
   1335  1f8e		       48		      pha
   1336  1f8f		       a9 a3		      lda	#<(._MAIN-1)
   1337  1f91		       48		      pha
   1338  1f92		       a5 81		      lda	temp7
   1339  1f94		       48		      pha
   1340  1f95		       8a		      txa
   1341  1f96		       48		      pha
   1342  1f97		       a2 02		      ldx	#2
   1343  1f99		       4c ee df 	      jmp	BS_jsr
   1344  1f9c				   .
   1345  1f9c							;
   1346  1f9c
   1347  1f9c				   .
   1348  1f9c							;
   1349  1f9c
   1350  1f9c				   .
   1351  1f9c							;
   1352  1f9c
   1353  1f9c				   .
   1354  1f9c							;
   1355  1f9c
   1356  1f9c				   .
   1357  1f9c							;
   1358  1f9c
   1359  1f9c				   .L041		;  bank 2
   1360  1f9c
   1361  1f9c					      if	ECHO1
      56 bytes of ROM space left in bank 1
   1362  1f9c					      echo	"    ",[(start_bank1 - *)]d , "bytes of ROM space left in bank 1")
   1363  1f9c					      endif
   1364  1f9c		       00 01	   ECHO1      =	1
   1365  1fd4					      ORG	$1FF4-bscode_length
   1366  1fd4					      RORG	$1FF4-bscode_length
   1367  1fd4		       a2 ff	   start_bank1 ldx	#$ff
   1368  1fd6					      ifconst	FASTFETCH	; using DPC+
   1369  1fd6		       8e 58 10 	      stx	FASTFETCH
   1370  1fd9					      endif
   1371  1fd9		       9a		      txs
   1372  1fda				  -	      if	bankswitch == 64
   1373  1fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1374  1fda					      else
   1375  1fda		       a9 18		      lda	#>(start-1)
   1376  1fdc					      endif
   1377  1fdc		       48		      pha
   1378  1fdd		       a9 e3		      lda	#<(start-1)
   1379  1fdf		       48		      pha
   1380  1fe0		       48		      pha
   1381  1fe1		       8a		      txa
   1382  1fe2		       48		      pha
   1383  1fe3		       ba		      tsx
   1384  1fe4					      if	bankswitch != 64
   1385  1fe4		       b5 04		      lda	4,x	; get high byte of return address
   1386  1fe6		       2a		      rol
   1387  1fe7		       2a		      rol
   1388  1fe8		       2a		      rol
   1389  1fe9		       2a		      rol
   1390  1fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1391  1fec		       aa		      tax
   1392  1fed		       e8		      inx
   1393  1fee				  -	      else
   1394  1fee				  -	      lda	4,x	; get high byte of return address
   1395  1fee				  -	      tay
   1396  1fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1397  1fee				  -	      sta	4,x
   1398  1fee				  -	      tya
   1399  1fee				  -	      lsr
   1400  1fee				  -	      lsr
   1401  1fee				  -	      lsr
   1402  1fee				  -	      lsr
   1403  1fee				  -	      tax
   1404  1fee				  -	      inx
   1405  1fee					      endif
   1406  1fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   1407  1ff1		       68		      pla
   1408  1ff2		       aa		      tax
   1409  1ff3		       68		      pla
   1410  1ff4		       60		      rts
   1411  1ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1412  1ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1413  1ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1414  1ff5					      endif
   1415  1ffc					      ORG	$1FFC
   1416  1ffc					      RORG	$1FFC
   1417  1ffc		       d4 1f		      .word.w	start_bank1
   1418  1ffe		       d4 1f		      .word.w	start_bank1
   1419  2000					      ORG	$2000
   1420  2000					      RORG	$3000
   1421  2000				   HMdiv
   1422  2000		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, 0, 0
   1423  2007		       01 01 01 01*	      .byte.b	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2
   1424  2017		       02 02 02 02*	      .byte.b	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3
   1425  2027		       03 03 03 03*	      .byte.b	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4
   1426  2037		       04 04 04 04*	      .byte.b	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5
   1427  2047		       05 05 05 05*	      .byte.b	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6
   1428  2057		       06 06 06 06*	      .byte.b	6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7
   1429  2067		       07 07 07 07*	      .byte.b	7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8
   1430  2077		       08 08 08 08*	      .byte.b	8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9
   1431  2087		       09 09 09 09*	      .byte.b	9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10
   1432  2097		       0a 0a 0a 0a*	      .byte.b	10,10,10,10,10,10,0,0,0
   1433  20a0				   .L042		;  temp1  =  temp1
   1434  20a0
   1435  20a0		       a5 cb		      LDA	temp1
   1436  20a2		       85 cb		      STA	temp1
   1437  20a4				   .
   1438  20a4							;
   1439  20a4
   1440  20a4				   ._MAIN
   1441  20a4							; _MAIN
   1442  20a4
   1443  20a4				   .
   1444  20a4							;
   1445  20a4
   1446  20a4				   ._GameInit
   1447  20a4							; _GameInit
   1448  20a4
   1449  20a4				   .
   1450  20a4							;
   1451  20a4
   1452  20a4				   .L043		;  scorecolors:
   1453  20a4
   1454  20a4		       a9 45		      lda	#<scoredata
   1455  20a6		       8d 50 10 	      STA	DF0LOW
   1456  20a9		       a9 0b		      lda	#((>scoredata) & $0f)
   1457  20ab		       8d 68 10 	      STA	DF0HI
   1458  20ae		       a9 3e		      lda	#$3E
   1459  20b0
   1460  20b0		       8d 78 10 	      sta	DF0WRITE
   1461  20b3		       a9 3c		      lda	#$3C
   1462  20b5
   1463  20b5		       8d 78 10 	      sta	DF0WRITE
   1464  20b8		       a9 3a		      lda	#$3A
   1465  20ba
   1466  20ba		       8d 78 10 	      sta	DF0WRITE
   1467  20bd		       a9 38		      lda	#$38
   1468  20bf
   1469  20bf		       8d 78 10 	      sta	DF0WRITE
   1470  20c2		       a9 36		      lda	#$36
   1471  20c4
   1472  20c4		       8d 78 10 	      sta	DF0WRITE
   1473  20c7		       a9 36		      lda	#$36
   1474  20c9
   1475  20c9		       8d 78 10 	      sta	DF0WRITE
   1476  20cc		       a9 34		      lda	#$34
   1477  20ce
   1478  20ce		       8d 78 10 	      sta	DF0WRITE
   1479  20d1		       a9 32		      lda	#$32
   1480  20d3
   1481  20d3		       8d 78 10 	      sta	DF0WRITE
   1482  20d6				   .
   1483  20d6							;
   1484  20d6
   1485  20d6				   .
   1486  20d6							;
   1487  20d6
   1488  20d6				   ._Player0Setup
   1489  20d6							; _Player0Setup
   1490  20d6
   1491  20d6				   .
   1492  20d6							;
   1493  20d6
   1494  20d6				   .L044		;  missile1height  =  4
   1495  20d6
   1496  20d6		       a9 04		      LDA	#4
   1497  20d8		       85 c3		      STA	missile1height
   1498  20da				   .
   1499  20da							;
   1500  20da
   1501  20da				   .L045		;  COLUM1  =  $1E
   1502  20da
   1503  20da		       a9 1e		      LDA	#$1E
   1504  20dc		       85 bc		      STA	COLUM1
   1505  20de				   .L046		;  _NUSIZ1  =	$30
   1506  20de
   1507  20de		       a9 30		      LDA	#$30
   1508  20e0		       85 af		      STA	_NUSIZ1
   1509  20e2				   .
   1510  20e2							;
   1511  20e2
   1512  20e2				   .L047		;  NUSIZ2  =  _NUSIZ1
   1513  20e2
   1514  20e2		       a5 af		      LDA	_NUSIZ1
   1515  20e4		       85 b0		      STA	NUSIZ2
   1516  20e6				   .L048		;  NUSIZ3  =  _NUSIZ1
   1517  20e6
   1518  20e6		       a5 af		      LDA	_NUSIZ1
   1519  20e8		       85 b1		      STA	NUSIZ3
   1520  20ea				   .L049		;  NUSIZ4  =  _NUSIZ1
   1521  20ea
   1522  20ea		       a5 af		      LDA	_NUSIZ1
   1523  20ec		       85 b2		      STA	NUSIZ4
   1524  20ee				   .L050		;  NUSIZ5  =  _NUSIZ1
   1525  20ee
   1526  20ee		       a5 af		      LDA	_NUSIZ1
   1527  20f0		       85 b3		      STA	NUSIZ5
   1528  20f2				   .L051		;  NUSIZ6  =  _NUSIZ1
   1529  20f2
   1530  20f2		       a5 af		      LDA	_NUSIZ1
   1531  20f4		       85 b4		      STA	NUSIZ6
   1532  20f6				   .L052		;  NUSIZ7  =  _NUSIZ1
   1533  20f6
   1534  20f6		       a5 af		      LDA	_NUSIZ1
   1535  20f8		       85 b5		      STA	NUSIZ7
   1536  20fa				   .L053		;  NUSIZ8  =  _NUSIZ1
   1537  20fa
   1538  20fa		       a5 af		      LDA	_NUSIZ1
   1539  20fc		       85 b6		      STA	NUSIZ8
   1540  20fe				   .L054		;  NUSIZ9  =  _NUSIZ1
   1541  20fe
   1542  20fe		       a5 af		      LDA	_NUSIZ1
   1543  2100		       85 b7		      STA	NUSIZ9
   1544  2102				   .
   1545  2102							;
   1546  2102
   1547  2102				   .L055		;  player0:
   1548  2102
   1549  2102		       a2 a8		      LDX	#<playerL055_0
   1550  2104		       86 bd		      STX	player0pointerlo
   1551  2106		       a9 61		      LDA	#((>playerL055_0) & $0f) | (((>playerL055_0) / 2) & $70)
   1552  2108		       85 be		      STA	player0pointerhi
   1553  210a		       a9 0e		      LDA	#14
   1554  210c		       85 a5		      STA	player0height
   1555  210e				   .
   1556  210e							;
   1557  210e
   1558  210e				   .L056		;  player0color:
   1559  210e
   1560  210e		       a2 b6		      LDX	#<playercolorL056_0
   1561  2110		       86 a3		      STX	player0color
   1562  2112		       a9 61		      LDA	#((>playercolorL056_0) & $0f) | (((>playercolorL056_0) / 2) & $70)
   1563  2114		       85 a4		      STA	player0color+1
   1564  2116				   .
   1565  2116							;
   1566  2116
   1567  2116				   .L057		;  bits0_DebounceJoy0{0}  =  0
   1568  2116
   1569  2116		       a5 ea		      LDA	bits0_DebounceJoy0
   1570  2118		       29 fe		      AND	#254
   1571  211a		       85 ea		      STA	bits0_DebounceJoy0
   1572  211c				   .
   1573  211c							;
   1574  211c
   1575  211c				   .L058		;  frames  =  0
   1576  211c
   1577  211c		       a9 00		      LDA	#0
   1578  211e		       85 d6		      STA	frames
   1579  2120				   .L059		;  speed  =  50
   1580  2120
   1581  2120		       a9 32		      LDA	#50
   1582  2122		       85 e3		      STA	speed
   1583  2124				   .
   1584  2124							;
   1585  2124
   1586  2124				   .L060		;  facesCounter  =  0
   1587  2124
   1588  2124		       a9 00		      LDA	#0
   1589  2126		       85 d3		      STA	facesCounter
   1590  2128				   .
   1591  2128							;
   1592  2128
   1593  2128				   ._GameLoop
   1594  2128							; _GameLoop
   1595  2128
   1596  2128				   .
   1597  2128							;
   1598  2128
   1599  2128				   .
   1600  2128							;
   1601  2128
   1602  2128				   .L061		;  DF0FRACINC	=  32
   1603  2128
   1604  2128		       a9 20		      LDA	#32
   1605  212a		       8d 38 10 	      STA	DF0FRACINC
   1606  212d				   .L062		;  DF1FRACINC	=  32
   1607  212d
   1608  212d		       a9 20		      LDA	#32
   1609  212f		       8d 39 10 	      STA	DF1FRACINC
   1610  2132				   .L063		;  DF2FRACINC	=  32
   1611  2132
   1612  2132		       a9 20		      LDA	#32
   1613  2134		       8d 3a 10 	      STA	DF2FRACINC
   1614  2137				   .L064		;  DF3FRACINC	=  32
   1615  2137
   1616  2137		       a9 20		      LDA	#32
   1617  2139		       8d 3b 10 	      STA	DF3FRACINC
   1618  213c				   .
   1619  213c							;
   1620  213c
   1621  213c				   .
   1622  213c							;
   1623  213c
   1624  213c				   .L065		;  DF4FRACINC	=  0
   1625  213c
   1626  213c		       a9 00		      LDA	#0
   1627  213e		       8d 3c 10 	      STA	DF4FRACINC
   1628  2141				   .
   1629  2141							;
   1630  2141
   1631  2141				   .L066		;  pfcolors:
   1632  2141
   1633  2141		       a9 08		      LDA	#<PFCOLS
   1634  2143		       8d 50 10 	      STA	DF0LOW
   1635  2146		       a9 0a		      LDA	#(>PFCOLS) & $0F
   1636  2148		       8d 68 10 	      STA	DF0HI
   1637  214b		       a9 ca		      LDA	#<playfieldcolorL066
   1638  214d		       8d 59 10 	      STA	PARAMETER
   1639  2150		       a9 61		      LDA	#((>playfieldcolorL066) & $0f) | (((>playfieldcolorL066) / 2) & $70)
   1640  2152		       8d 59 10 	      STA	PARAMETER
   1641  2155		       a9 00		      LDA	#0
   1642  2157		       8d 59 10 	      STA	PARAMETER
   1643  215a		       a9 01		      LDA	#1
   1644  215c		       8d 59 10 	      STA	PARAMETER
   1645  215f		       a9 01		      LDA	#1
   1646  2161		       8d 5a 10 	      STA	CALLFUNCTION
   1647  2164				   .
   1648  2164							;
   1649  2164
   1650  2164				   .
   1651  2164							;
   1652  2164
   1653  2164				   .L067		;  DF6FRACINC	=  0
   1654  2164
   1655  2164		       a9 00		      LDA	#0
   1656  2166		       8d 3e 10 	      STA	DF6FRACINC
   1657  2169				   .
   1658  2169							;
   1659  2169
   1660  2169				   .L068		;  bkcolors:
   1661  2169
   1662  2169		       a9 a5		      LDA	#<BKCOLS
   1663  216b		       8d 50 10 	      STA	DF0LOW
   1664  216e		       a9 0b		      LDA	#(>BKCOLS) & $0F
   1665  2170		       8d 68 10 	      STA	DF0HI
   1666  2173		       a9 cb		      LDA	#<backgroundcolorL068
   1667  2175		       8d 59 10 	      STA	PARAMETER
   1668  2178		       a9 61		      LDA	#((>backgroundcolorL068) & $0f) | (((>backgroundcolorL068) / 2) & $70)
   1669  217a		       8d 59 10 	      STA	PARAMETER
   1670  217d		       a9 00		      LDA	#0
   1671  217f		       8d 59 10 	      STA	PARAMETER
   1672  2182		       a9 01		      LDA	#1
   1673  2184		       8d 59 10 	      STA	PARAMETER
   1674  2187		       a9 01		      LDA	#1
   1675  2189		       8d 5a 10 	      STA	CALLFUNCTION
   1676  218c				   .
   1677  218c							;
   1678  218c
   1679  218c				   .L069		;  if gameState  =  GAME_STATE_GAMEOVER then gosub _GameOverLoop bank3  :  drawscreen :  goto _GameLoop
   1680  218c
   1681  218c		       a5 e8		      LDA	gameState
   1682  218e		       c9 03		      CMP	#GAME_STATE_GAMEOVER
   1683  2190		       d0 33		      BNE	.skipL069
   1684  2192				   .condpart0
   1685  2192		       85 81		      sta	temp7
   1686  2194		       a9 31		      lda	#>(ret_point1-1)
   1687  2196		       48		      pha
   1688  2197		       a9 a9		      lda	#<(ret_point1-1)
   1689  2199		       48		      pha
   1690  219a		       a9 54		      lda	#>(._GameOverLoop-1)
   1691  219c		       48		      pha
   1692  219d		       a9 52		      lda	#<(._GameOverLoop-1)
   1693  219f		       48		      pha
   1694  21a0		       a5 81		      lda	temp7
   1695  21a2		       48		      pha
   1696  21a3		       8a		      txa
   1697  21a4		       48		      pha
   1698  21a5		       a2 03		      ldx	#3
   1699  21a7		       4c ee df 	      jmp	BS_jsr
   1700  21aa				   ret_point1
   1701  21aa		       85 81		      sta	temp7
   1702  21ac		       a9 31		      lda	#>(ret_point2-1)
   1703  21ae		       48		      pha
   1704  21af		       a9 c1		      lda	#<(ret_point2-1)
   1705  21b1		       48		      pha
   1706  21b2		       a9 19		      lda	#>(drawscreen-1)
   1707  21b4		       48		      pha
   1708  21b5		       a9 48		      lda	#<(drawscreen-1)
   1709  21b7		       48		      pha
   1710  21b8		       a5 81		      lda	temp7
   1711  21ba		       48		      pha
   1712  21bb		       8a		      txa
   1713  21bc		       48		      pha
   1714  21bd		       a2 01		      ldx	#1
   1715  21bf		       4c ee df 	      jmp	BS_jsr
   1716  21c2				   ret_point2
   1717  21c2		       4c 28 31 	      jmp	._GameLoop
   1718  21c5
   1719  21c5				   .skipL069
   1720  21c5				   .
   1721  21c5							;
   1722  21c5
   1723  21c5				   .L070		;  if !eatSound then goto _SkipEatSound
   1724  21c5
   1725  21c5		       a5 dd		      LDA	eatSound
   1726  21c7		       d0 03		      BNE	.skipL070
   1727  21c9				   .condpart1
   1728  21c9		       4c e2 31 	      jmp	._SkipEatSound
   1729  21cc
   1730  21cc				   .skipL070
   1731  21cc				   .L071		;  AUDV0  =  EAT_SOUND_VOLUME
   1732  21cc
   1733  21cc		       a9 08		      LDA	#EAT_SOUND_VOLUME
   1734  21ce		       85 19		      STA	AUDV0
   1735  21d0				   .L072		;  AUDC0  =  4
   1736  21d0
   1737  21d0		       a9 04		      LDA	#4
   1738  21d2		       85 15		      STA	AUDC0
   1739  21d4				   .L073		;  AUDF0  =  EAT_SOUND_FREQUENCY
   1740  21d4
   1741  21d4		       a9 19		      LDA	#EAT_SOUND_FREQUENCY
   1742  21d6		       85 17		      STA	AUDF0
   1743  21d8				   .L074		;  eatSound  =  eatSound  -  1
   1744  21d8
   1745  21d8		       c6 dd		      DEC	eatSound
   1746  21da				   .L075		;  if !eatSound then AUDV0  =	0
   1747  21da
   1748  21da		       a5 dd		      LDA	eatSound
   1749  21dc		       d0 04		      BNE	.skipL075
   1750  21de				   .condpart2
   1751  21de		       a9 00		      LDA	#0
   1752  21e0		       85 19		      STA	AUDV0
   1753  21e2				   .skipL075
   1754  21e2				   ._SkipEatSound
   1755  21e2							; _SkipEatSound
   1756  21e2
   1757  21e2				   .
   1758  21e2							;
   1759  21e2
   1760  21e2				   .L076		;  if facesCounter  >	0 then goto _SkipPlayFieldSetup
   1761  21e2
   1762  21e2		       a9 00		      LDA	#0
   1763  21e4		       c5 d3		      CMP	facesCounter
   1764  21e6		       b0 03		      BCS	.skipL076
   1765  21e8				   .condpart3
   1766  21e8		       4c 1b 32 	      jmp	._SkipPlayFieldSetup
   1767  21eb
   1768  21eb				   .skipL076
   1769  21eb				   .L077		;  gosub _PlayFieldSetup bank3
   1770  21eb
   1771  21eb		       85 81		      sta	temp7
   1772  21ed		       a9 32		      lda	#>(ret_point3-1)
   1773  21ef		       48		      pha
   1774  21f0		       a9 02		      lda	#<(ret_point3-1)
   1775  21f2		       48		      pha
   1776  21f3		       a9 53		      lda	#>(._PlayFieldSetup-1)
   1777  21f5		       48		      pha
   1778  21f6		       a9 ea		      lda	#<(._PlayFieldSetup-1)
   1779  21f8		       48		      pha
   1780  21f9		       a5 81		      lda	temp7
   1781  21fb		       48		      pha
   1782  21fc		       8a		      txa
   1783  21fd		       48		      pha
   1784  21fe		       a2 03		      ldx	#3
   1785  2200		       4c ee df 	      jmp	BS_jsr
   1786  2203				   ret_point3
   1787  2203				   .L078		;  gosub _OtherPlayersSetup bank3
   1788  2203
   1789  2203		       85 81		      sta	temp7
   1790  2205		       a9 32		      lda	#>(ret_point4-1)
   1791  2207		       48		      pha
   1792  2208		       a9 1a		      lda	#<(ret_point4-1)
   1793  220a		       48		      pha
   1794  220b		       a9 51		      lda	#>(._OtherPlayersSetup-1)
   1795  220d		       48		      pha
   1796  220e		       a9 84		      lda	#<(._OtherPlayersSetup-1)
   1797  2210		       48		      pha
   1798  2211		       a5 81		      lda	temp7
   1799  2213		       48		      pha
   1800  2214		       8a		      txa
   1801  2215		       48		      pha
   1802  2216		       a2 03		      ldx	#3
   1803  2218		       4c ee df 	      jmp	BS_jsr
   1804  221b				   ret_point4
   1805  221b				   ._SkipPlayFieldSetup
   1806  221b							; _SkipPlayFieldSetup
   1807  221b
   1808  221b				   .
   1809  221b							;
   1810  221b
   1811  221b				   .
   1812  221b							;
   1813  221b
   1814  221b				   .L079		;  if !joy0left  &&  !joy0right then goto _SkipHMove
   1815  221b
   1816  221b		       2c 80 02 	      bit	SWCHA
   1817  221e		       50 08		      BVC	.skipL079
   1818  2220				   .condpart4
   1819  2220		       2c 80 02 	      bit	SWCHA
   1820  2223		       10 03		      BPL	.skip4then
   1821  2225				   .condpart5
   1822  2225		       4c 68 32 	      jmp	._SkipHMove
   1823  2228
   1824  2228				   .skip4then
   1825  2228				   .skipL079
   1826  2228				   .
   1827  2228							;
   1828  2228
   1829  2228				   .L080		;  if bits0_DebounceJoy0{0} then goto _SkipDebounceReset
   1830  2228
   1831  2228		       a5 ea		      LDA	bits0_DebounceJoy0
   1832  222a		       4a		      LSR
   1833  222b		       90 03		      BCC	.skipL080
   1834  222d				   .condpart6
   1835  222d		       4c 6e 32 	      jmp	._SkipDebounceReset
   1836  2230
   1837  2230				   .skipL080
   1838  2230				   .
   1839  2230							;
   1840  2230
   1841  2230				   .L081		;  bits0_DebounceJoy0{0}  =  1
   1842  2230
   1843  2230		       a5 ea		      LDA	bits0_DebounceJoy0
   1844  2232		       09 01		      ORA	#1
   1845  2234		       85 ea		      STA	bits0_DebounceJoy0
   1846  2236				   .L082		;  if joy0left then player0x = player0x - GOBLIN_DELTA_X
   1847  2236
   1848  2236		       2c 80 02 	      bit	SWCHA
   1849  2239		       70 07		      BVS	.skipL082
   1850  223b				   .condpart7
   1851  223b		       a5 80		      LDA	player0x
   1852  223d		       38		      SEC
   1853  223e		       e9 08		      SBC	#GOBLIN_DELTA_X
   1854  2240		       85 80		      STA	player0x
   1855  2242				   .skipL082
   1856  2242				   .L083		;  if joy0right then player0x = player0x + GOBLIN_DELTA_X
   1857  2242
   1858  2242		       2c 80 02 	      bit	SWCHA
   1859  2245		       30 07		      BMI	.skipL083
   1860  2247				   .condpart8
   1861  2247		       a5 80		      LDA	player0x
   1862  2249		       18		      CLC
   1863  224a		       69 08		      ADC	#GOBLIN_DELTA_X
   1864  224c		       85 80		      STA	player0x
   1865  224e				   .skipL083
   1866  224e				   .
   1867  224e							;
   1868  224e
   1869  224e				   .L084		;  if player0x  <  GOBLIN_LEFT_BOUNDARY then player0x = GOBLIN_MAX_X  :  goto _SkipWrapCheck
   1870  224e
   1871  224e		       a5 80		      LDA	player0x
   1872  2250		       c9 10		      CMP	#GOBLIN_LEFT_BOUNDARY
   1873  2252		       b0 07		      BCS	.skipL084
   1874  2254				   .condpart9
   1875  2254		       a9 88		      LDA	#GOBLIN_MAX_X
   1876  2256		       85 80		      STA	player0x
   1877  2258		       4c 65 32 	      jmp	._SkipWrapCheck
   1878  225b
   1879  225b				   .skipL084
   1880  225b				   .L085		;  if player0x  >  GOBLIN_RIGHT_BOUNDARY then player0x = GOBLIN_MIN_X
   1881  225b
   1882  225b		       a9 88		      LDA	#GOBLIN_RIGHT_BOUNDARY
   1883  225d		       c5 80		      CMP	player0x
   1884  225f		       b0 04		      BCS	.skipL085
   1885  2261				   .condpart10
   1886  2261		       a9 10		      LDA	#GOBLIN_MIN_X
   1887  2263		       85 80		      STA	player0x
   1888  2265				   .skipL085
   1889  2265				   ._SkipWrapCheck
   1890  2265							; _SkipWrapCheck
   1891  2265
   1892  2265				   .
   1893  2265							;
   1894  2265
   1895  2265				   .L086		;  goto _SkipDebounceReset
   1896  2265
   1897  2265		       4c 6e 32 	      jmp	._SkipDebounceReset
   1898  2268
   1899  2268				   .
   1900  2268							;
   1901  2268
   1902  2268				   ._SkipHMove
   1903  2268							; _SkipHMove
   1904  2268
   1905  2268				   .L087		;  bits0_DebounceJoy0{0}  =  0
   1906  2268
   1907  2268		       a5 ea		      LDA	bits0_DebounceJoy0
   1908  226a		       29 fe		      AND	#254
   1909  226c		       85 ea		      STA	bits0_DebounceJoy0
   1910  226e				   ._SkipDebounceReset
   1911  226e							; _SkipDebounceReset
   1912  226e
   1913  226e				   .
   1914  226e							;
   1915  226e
   1916  226e				   .L088		;  if frames  <  speed then goto _SkipMoveUp
   1917  226e
   1918  226e		       a5 d6		      LDA	frames
   1919  2270		       c5 e3		      CMP	speed
   1920  2272		       b0 03		      BCS	.skipL088
   1921  2274				   .condpart11
   1922  2274		       4c 8c 32 	      jmp	._SkipMoveUp
   1923  2277
   1924  2277				   .skipL088
   1925  2277				   .L089		;  frames = 0
   1926  2277
   1927  2277		       a9 00		      LDA	#0
   1928  2279		       85 d6		      STA	frames
   1929  227b				   .L090		;  player0y  =  player0y - GOBLIN_DELTA_Y
   1930  227b
   1931  227b		       a5 99		      LDA	player0y
   1932  227d		       38		      SEC
   1933  227e		       e9 10		      SBC	#GOBLIN_DELTA_Y
   1934  2280		       85 99		      STA	player0y
   1935  2282				   .L091		;  if player0y  >  GOBLIN_TOP_BOUNDARY then player0y  =  GOBLIN_MAX_Y
   1936  2282
   1937  2282		       a9 e7		      LDA	#GOBLIN_TOP_BOUNDARY
   1938  2284		       c5 99		      CMP	player0y
   1939  2286		       b0 04		      BCS	.skipL091
   1940  2288				   .condpart12
   1941  2288		       a9 a0		      LDA	#GOBLIN_MAX_Y
   1942  228a		       85 99		      STA	player0y
   1943  228c				   .skipL091
   1944  228c				   ._SkipMoveUp
   1945  228c							; _SkipMoveUp
   1946  228c
   1947  228c				   .
   1948  228c							;
   1949  228c
   1950  228c				   .
   1951  228c							;
   1952  228c
   1953  228c				   .L092		;  missile1x  =  player0x + 1
   1954  228c
   1955  228c		       a5 80		      LDA	player0x
   1956  228e		       18		      CLC
   1957  228f		       69 01		      ADC	#1
   1958  2291		       85 83		      STA	missile1x
   1959  2293				   .L093		;  missile1y  =  player0y + 4
   1960  2293
   1961  2293		       a5 99		      LDA	player0y
   1962  2295		       18		      CLC
   1963  2296		       69 04		      ADC	#4
   1964  2298		       85 c0		      STA	missile1y
   1965  229a				   .
   1966  229a							;
   1967  229a
   1968  229a				   .L094		;  drawscreen
   1969  229a
   1970  229a		       85 81		      sta	temp7
   1971  229c		       a9 32		      lda	#>(ret_point5-1)
   1972  229e		       48		      pha
   1973  229f		       a9 b1		      lda	#<(ret_point5-1)
   1974  22a1		       48		      pha
   1975  22a2		       a9 19		      lda	#>(drawscreen-1)
   1976  22a4		       48		      pha
   1977  22a5		       a9 48		      lda	#<(drawscreen-1)
   1978  22a7		       48		      pha
   1979  22a8		       a5 81		      lda	temp7
   1980  22aa		       48		      pha
   1981  22ab		       8a		      txa
   1982  22ac		       48		      pha
   1983  22ad		       a2 01		      ldx	#1
   1984  22af		       4c ee df 	      jmp	BS_jsr
   1985  22b2				   ret_point5
   1986  22b2				   .L095		;  frames  =  frames + 1
   1987  22b2
   1988  22b2		       e6 d6		      INC	frames
   1989  22b4				   .
   1990  22b4							;
   1991  22b4
   1992  22b4				   .L096		;  gosub _CheckPlayersCollision bank3
   1993  22b4
   1994  22b4		       85 81		      sta	temp7
   1995  22b6		       a9 32		      lda	#>(ret_point6-1)
   1996  22b8		       48		      pha
   1997  22b9		       a9 cb		      lda	#<(ret_point6-1)
   1998  22bb		       48		      pha
   1999  22bc		       a9 50		      lda	#>(._CheckPlayersCollision-1)
   2000  22be		       48		      pha
   2001  22bf		       a9 84		      lda	#<(._CheckPlayersCollision-1)
   2002  22c1		       48		      pha
   2003  22c2		       a5 81		      lda	temp7
   2004  22c4		       48		      pha
   2005  22c5		       8a		      txa
   2006  22c6		       48		      pha
   2007  22c7		       a2 03		      ldx	#3
   2008  22c9		       4c ee df 	      jmp	BS_jsr
   2009  22cc				   ret_point6
   2010  22cc				   .
   2011  22cc							;
   2012  22cc
   2013  22cc				   .L097		;  goto _GameLoop
   2014  22cc
   2015  22cc		       4c 28 31 	      jmp	._GameLoop
   2016  22cf
   2017  22cf				   .
   2018  22cf							;
   2019  22cf
   2020  22cf				   .
   2021  22cf							;
   2022  22cf
   2023  22cf				   .
   2024  22cf							;
   2025  22cf
   2026  22cf				   .
   2027  22cf							;
   2028  22cf
   2029  22cf				   .L098		;  bank 3
   2030  22cf
   2031  22cf					      if	ECHO2
      3333 bytes of ROM space left in bank 2
   2032  22cf					      echo	"    ",[(start_bank2 - *)]d , "bytes of ROM space left in bank 2")
   2033  22cf					      endif
   2034  22cf		       00 01	   ECHO2      =	1
   2035  2fd4					      ORG	$2FF4-bscode_length
   2036  2fd4					      RORG	$3FF4-bscode_length
   2037  2fd4		       a2 ff	   start_bank2 ldx	#$ff
   2038  2fd6					      ifconst	FASTFETCH	; using DPC+
   2039  2fd6		       8e 58 10 	      stx	FASTFETCH
   2040  2fd9					      endif
   2041  2fd9		       9a		      txs
   2042  2fda				  -	      if	bankswitch == 64
   2043  2fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   2044  2fda					      else
   2045  2fda		       a9 18		      lda	#>(start-1)
   2046  2fdc					      endif
   2047  2fdc		       48		      pha
   2048  2fdd		       a9 e3		      lda	#<(start-1)
   2049  2fdf		       48		      pha
   2050  2fe0		       48		      pha
   2051  2fe1		       8a		      txa
   2052  2fe2		       48		      pha
   2053  2fe3		       ba		      tsx
   2054  2fe4					      if	bankswitch != 64
   2055  2fe4		       b5 04		      lda	4,x	; get high byte of return address
   2056  2fe6		       2a		      rol
   2057  2fe7		       2a		      rol
   2058  2fe8		       2a		      rol
   2059  2fe9		       2a		      rol
   2060  2fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   2061  2fec		       aa		      tax
   2062  2fed		       e8		      inx
   2063  2fee				  -	      else
   2064  2fee				  -	      lda	4,x	; get high byte of return address
   2065  2fee				  -	      tay
   2066  2fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   2067  2fee				  -	      sta	4,x
   2068  2fee				  -	      tya
   2069  2fee				  -	      lsr
   2070  2fee				  -	      lsr
   2071  2fee				  -	      lsr
   2072  2fee				  -	      lsr
   2073  2fee				  -	      tax
   2074  2fee				  -	      inx
   2075  2fee					      endif
   2076  2fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   2077  2ff1		       68		      pla
   2078  2ff2		       aa		      tax
   2079  2ff3		       68		      pla
   2080  2ff4		       60		      rts
   2081  2ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   2082  2ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   2083  2ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   2084  2ff5					      endif
   2085  2ffc					      ORG	$2FFC
   2086  2ffc					      RORG	$3FFC
   2087  2ffc		       d4 3f		      .word.w	start_bank2
   2088  2ffe		       d4 3f		      .word.w	start_bank2
   2089  3000					      ORG	$3000
   2090  3000					      RORG	$5000
   2091  3000					      repeat	129
   2092  3000		       00		      .byte.b	0
   2091  3000					      repend
   2092  3001		       00		      .byte.b	0
   2091  3001					      repend
   2092  3002		       00		      .byte.b	0
   2091  3002					      repend
   2092  3003		       00		      .byte.b	0
   2091  3003					      repend
   2092  3004		       00		      .byte.b	0
   2091  3004					      repend
   2092  3005		       00		      .byte.b	0
   2091  3005					      repend
   2092  3006		       00		      .byte.b	0
   2091  3006					      repend
   2092  3007		       00		      .byte.b	0
   2091  3007					      repend
   2092  3008		       00		      .byte.b	0
   2091  3008					      repend
   2092  3009		       00		      .byte.b	0
   2091  3009					      repend
   2092  300a		       00		      .byte.b	0
   2091  300a					      repend
   2092  300b		       00		      .byte.b	0
   2091  300b					      repend
   2092  300c		       00		      .byte.b	0
   2091  300c					      repend
   2092  300d		       00		      .byte.b	0
   2091  300d					      repend
   2092  300e		       00		      .byte.b	0
   2091  300e					      repend
   2092  300f		       00		      .byte.b	0
   2091  300f					      repend
   2092  3010		       00		      .byte.b	0
   2091  3010					      repend
   2092  3011		       00		      .byte.b	0
   2091  3011					      repend
   2092  3012		       00		      .byte.b	0
   2091  3012					      repend
   2092  3013		       00		      .byte.b	0
   2091  3013					      repend
   2092  3014		       00		      .byte.b	0
   2091  3014					      repend
   2092  3015		       00		      .byte.b	0
   2091  3015					      repend
   2092  3016		       00		      .byte.b	0
   2091  3016					      repend
   2092  3017		       00		      .byte.b	0
   2091  3017					      repend
   2092  3018		       00		      .byte.b	0
   2091  3018					      repend
   2092  3019		       00		      .byte.b	0
   2091  3019					      repend
   2092  301a		       00		      .byte.b	0
   2091  301a					      repend
   2092  301b		       00		      .byte.b	0
   2091  301b					      repend
   2092  301c		       00		      .byte.b	0
   2091  301c					      repend
   2092  301d		       00		      .byte.b	0
   2091  301d					      repend
   2092  301e		       00		      .byte.b	0
   2091  301e					      repend
   2092  301f		       00		      .byte.b	0
   2091  301f					      repend
   2092  3020		       00		      .byte.b	0
   2091  3020					      repend
   2092  3021		       00		      .byte.b	0
   2091  3021					      repend
   2092  3022		       00		      .byte.b	0
   2091  3022					      repend
   2092  3023		       00		      .byte.b	0
   2091  3023					      repend
   2092  3024		       00		      .byte.b	0
   2091  3024					      repend
   2092  3025		       00		      .byte.b	0
   2091  3025					      repend
   2092  3026		       00		      .byte.b	0
   2091  3026					      repend
   2092  3027		       00		      .byte.b	0
   2091  3027					      repend
   2092  3028		       00		      .byte.b	0
   2091  3028					      repend
   2092  3029		       00		      .byte.b	0
   2091  3029					      repend
   2092  302a		       00		      .byte.b	0
   2091  302a					      repend
   2092  302b		       00		      .byte.b	0
   2091  302b					      repend
   2092  302c		       00		      .byte.b	0
   2091  302c					      repend
   2092  302d		       00		      .byte.b	0
   2091  302d					      repend
   2092  302e		       00		      .byte.b	0
   2091  302e					      repend
   2092  302f		       00		      .byte.b	0
   2091  302f					      repend
   2092  3030		       00		      .byte.b	0
   2091  3030					      repend
   2092  3031		       00		      .byte.b	0
   2091  3031					      repend
   2092  3032		       00		      .byte.b	0
   2091  3032					      repend
   2092  3033		       00		      .byte.b	0
   2091  3033					      repend
   2092  3034		       00		      .byte.b	0
   2091  3034					      repend
   2092  3035		       00		      .byte.b	0
   2091  3035					      repend
   2092  3036		       00		      .byte.b	0
   2091  3036					      repend
   2092  3037		       00		      .byte.b	0
   2091  3037					      repend
   2092  3038		       00		      .byte.b	0
   2091  3038					      repend
   2092  3039		       00		      .byte.b	0
   2091  3039					      repend
   2092  303a		       00		      .byte.b	0
   2091  303a					      repend
   2092  303b		       00		      .byte.b	0
   2091  303b					      repend
   2092  303c		       00		      .byte.b	0
   2091  303c					      repend
   2092  303d		       00		      .byte.b	0
   2091  303d					      repend
   2092  303e		       00		      .byte.b	0
   2091  303e					      repend
   2092  303f		       00		      .byte.b	0
   2091  303f					      repend
   2092  3040		       00		      .byte.b	0
   2091  3040					      repend
   2092  3041		       00		      .byte.b	0
   2091  3041					      repend
   2092  3042		       00		      .byte.b	0
   2091  3042					      repend
   2092  3043		       00		      .byte.b	0
   2091  3043					      repend
   2092  3044		       00		      .byte.b	0
   2091  3044					      repend
   2092  3045		       00		      .byte.b	0
   2091  3045					      repend
   2092  3046		       00		      .byte.b	0
   2091  3046					      repend
   2092  3047		       00		      .byte.b	0
   2091  3047					      repend
   2092  3048		       00		      .byte.b	0
   2091  3048					      repend
   2092  3049		       00		      .byte.b	0
   2091  3049					      repend
   2092  304a		       00		      .byte.b	0
   2091  304a					      repend
   2092  304b		       00		      .byte.b	0
   2091  304b					      repend
   2092  304c		       00		      .byte.b	0
   2091  304c					      repend
   2092  304d		       00		      .byte.b	0
   2091  304d					      repend
   2092  304e		       00		      .byte.b	0
   2091  304e					      repend
   2092  304f		       00		      .byte.b	0
   2091  304f					      repend
   2092  3050		       00		      .byte.b	0
   2091  3050					      repend
   2092  3051		       00		      .byte.b	0
   2091  3051					      repend
   2092  3052		       00		      .byte.b	0
   2091  3052					      repend
   2092  3053		       00		      .byte.b	0
   2091  3053					      repend
   2092  3054		       00		      .byte.b	0
   2091  3054					      repend
   2092  3055		       00		      .byte.b	0
   2091  3055					      repend
   2092  3056		       00		      .byte.b	0
   2091  3056					      repend
   2092  3057		       00		      .byte.b	0
   2091  3057					      repend
   2092  3058		       00		      .byte.b	0
   2091  3058					      repend
   2092  3059		       00		      .byte.b	0
   2091  3059					      repend
   2092  305a		       00		      .byte.b	0
   2091  305a					      repend
   2092  305b		       00		      .byte.b	0
   2091  305b					      repend
   2092  305c		       00		      .byte.b	0
   2091  305c					      repend
   2092  305d		       00		      .byte.b	0
   2091  305d					      repend
   2092  305e		       00		      .byte.b	0
   2091  305e					      repend
   2092  305f		       00		      .byte.b	0
   2091  305f					      repend
   2092  3060		       00		      .byte.b	0
   2091  3060					      repend
   2092  3061		       00		      .byte.b	0
   2091  3061					      repend
   2092  3062		       00		      .byte.b	0
   2091  3062					      repend
   2092  3063		       00		      .byte.b	0
   2091  3063					      repend
   2092  3064		       00		      .byte.b	0
   2091  3064					      repend
   2092  3065		       00		      .byte.b	0
   2091  3065					      repend
   2092  3066		       00		      .byte.b	0
   2091  3066					      repend
   2092  3067		       00		      .byte.b	0
   2091  3067					      repend
   2092  3068		       00		      .byte.b	0
   2091  3068					      repend
   2092  3069		       00		      .byte.b	0
   2091  3069					      repend
   2092  306a		       00		      .byte.b	0
   2091  306a					      repend
   2092  306b		       00		      .byte.b	0
   2091  306b					      repend
   2092  306c		       00		      .byte.b	0
   2091  306c					      repend
   2092  306d		       00		      .byte.b	0
   2091  306d					      repend
   2092  306e		       00		      .byte.b	0
   2091  306e					      repend
   2092  306f		       00		      .byte.b	0
   2091  306f					      repend
   2092  3070		       00		      .byte.b	0
   2091  3070					      repend
   2092  3071		       00		      .byte.b	0
   2091  3071					      repend
   2092  3072		       00		      .byte.b	0
   2091  3072					      repend
   2092  3073		       00		      .byte.b	0
   2091  3073					      repend
   2092  3074		       00		      .byte.b	0
   2091  3074					      repend
   2092  3075		       00		      .byte.b	0
   2091  3075					      repend
   2092  3076		       00		      .byte.b	0
   2091  3076					      repend
   2092  3077		       00		      .byte.b	0
   2091  3077					      repend
   2092  3078		       00		      .byte.b	0
   2091  3078					      repend
   2092  3079		       00		      .byte.b	0
   2091  3079					      repend
   2092  307a		       00		      .byte.b	0
   2091  307a					      repend
   2092  307b		       00		      .byte.b	0
   2091  307b					      repend
   2092  307c		       00		      .byte.b	0
   2091  307c					      repend
   2092  307d		       00		      .byte.b	0
   2091  307d					      repend
   2092  307e		       00		      .byte.b	0
   2091  307e					      repend
   2092  307f		       00		      .byte.b	0
   2091  307f					      repend
   2092  3080		       00		      .byte.b	0
   2093  3081					      repend
   2094  3081				   .L099		;  temp1  =  temp1
   2095  3081
   2096  3081		       a5 cb		      LDA	temp1
   2097  3083		       85 cb		      STA	temp1
   2098  3085				   .
   2099  3085							;
   2100  3085
   2101  3085				   ._CheckPlayersCollision
   2102  3085							; _CheckPlayersCollision
   2103  3085
   2104  3085				   .
   2105  3085							;
   2106  3085
   2107  3085				   .L0100		;  if !collision(player0,playfield) then goto _SkipPlayerCollision
   2108  3085
   2109  3085		       24 02		      bit	CXP0FB
   2110  3087		       30 03		      BMI	.skipL0100
   2111  3089				   .condpart13
   2112  3089		       4c ac 50 	      jmp	._SkipPlayerCollision
   2113  308c
   2114  308c				   .skipL0100
   2115  308c				   .L0101		;  gameState = GAME_STATE_GAMEOVER
   2116  308c
   2117  308c		       a9 03		      LDA	#GAME_STATE_GAMEOVER
   2118  308e		       85 e8		      STA	gameState
   2119  3090				   .L0102		;  gameStage = 0
   2120  3090
   2121  3090		       a9 00		      LDA	#0
   2122  3092		       85 e9		      STA	gameStage
   2123  3094				   .L0103		;  gosub _GameOverLoop bank 3
   2124  3094
   2125  3094		       85 81		      sta	temp7
   2126  3096		       a9 50		      lda	#>(ret_point7-1)
   2127  3098		       48		      pha
   2128  3099		       a9 ab		      lda	#<(ret_point7-1)
   2129  309b		       48		      pha
   2130  309c		       a9 54		      lda	#>(._GameOverLoop-1)
   2131  309e		       48		      pha
   2132  309f		       a9 52		      lda	#<(._GameOverLoop-1)
   2133  30a1		       48		      pha
   2134  30a2		       a5 81		      lda	temp7
   2135  30a4		       48		      pha
   2136  30a5		       8a		      txa
   2137  30a6		       48		      pha
   2138  30a7		       a2 d0		      ldx	#-48
   2139  30a9		       4c ee df 	      jmp	BS_jsr
   2140  30ac				   ret_point7
   2141  30ac				   ._SkipPlayerCollision
   2142  30ac							; _SkipPlayerCollision
   2143  30ac
   2144  30ac				   .
   2145  30ac							;
   2146  30ac
   2147  30ac				   .L0104		;  if !collision(player1,player0) then goto _SkipCollisionDetection
   2148  30ac
   2149  30ac		       24 07		      bit	CXPPMM
   2150  30ae		       30 03		      BMI	.skipL0104
   2151  30b0				   .condpart14
   2152  30b0		       4c 82 51 	      jmp	._SkipCollisionDetection
   2153  30b3
   2154  30b3				   .skipL0104
   2155  30b3				   .
   2156  30b3							;
   2157  30b3
   2158  30b3				   .L0105		;  if player0y  <>  player1y then goto _SkipPlayer1Reset
   2159  30b3
   2160  30b3		       a5 99		      LDA	player0y
   2161  30b5		       c5 9a		      CMP	player1y
   2162  30b7		       f0 03		      BEQ	.skipL0105
   2163  30b9				   .condpart15
   2164  30b9		       4c c7 50 	      jmp	._SkipPlayer1Reset
   2165  30bc
   2166  30bc				   .skipL0105
   2167  30bc				   .
   2168  30bc							;
   2169  30bc
   2170  30bc				   .
   2171  30bc							;
   2172  30bc
   2173  30bc				   .L0106		;  player1x = 0  :  player1y = 200
   2174  30bc
   2175  30bc		       a9 00		      LDA	#0
   2176  30be		       85 90		      STA	player1x
   2177  30c0		       a9 c8		      LDA	#200
   2178  30c2		       85 9a		      STA	player1y
   2179  30c4				   .L0107		;  goto _UpdateCollisionCheck
   2180  30c4
   2181  30c4		       4c 67 51 	      jmp	._UpdateCollisionCheck
   2182  30c7
   2183  30c7				   ._SkipPlayer1Reset
   2184  30c7							; _SkipPlayer1Reset
   2185  30c7
   2186  30c7				   .
   2187  30c7							;
   2188  30c7
   2189  30c7				   .L0108		;  if player0y  <>  player2y then goto _SkipPlayer2Reset
   2190  30c7
   2191  30c7		       a5 99		      LDA	player0y
   2192  30c9		       c5 9b		      CMP	player2y
   2193  30cb		       f0 03		      BEQ	.skipL0108
   2194  30cd				   .condpart16
   2195  30cd		       4c db 50 	      jmp	._SkipPlayer2Reset
   2196  30d0
   2197  30d0				   .skipL0108
   2198  30d0				   .L0109		;  player2x = 0  :  player2y = 200
   2199  30d0
   2200  30d0		       a9 00		      LDA	#0
   2201  30d2		       85 91		      STA	player2x
   2202  30d4		       a9 c8		      LDA	#200
   2203  30d6		       85 9b		      STA	player2y
   2204  30d8				   .L0110		;  goto _UpdateCollisionCheck
   2205  30d8
   2206  30d8		       4c 67 51 	      jmp	._UpdateCollisionCheck
   2207  30db
   2208  30db				   ._SkipPlayer2Reset
   2209  30db							; _SkipPlayer2Reset
   2210  30db
   2211  30db				   .
   2212  30db							;
   2213  30db
   2214  30db				   .L0111		;  if player0y  <>  player3y then goto _SkipPlayer3Reset
   2215  30db
   2216  30db		       a5 99		      LDA	player0y
   2217  30dd		       c5 9c		      CMP	player3y
   2218  30df		       f0 03		      BEQ	.skipL0111
   2219  30e1				   .condpart17
   2220  30e1		       4c ef 50 	      jmp	._SkipPlayer3Reset
   2221  30e4
   2222  30e4				   .skipL0111
   2223  30e4				   .L0112		;  player3x = 0  :  player3y = 200
   2224  30e4
   2225  30e4		       a9 00		      LDA	#0
   2226  30e6		       85 92		      STA	player3x
   2227  30e8		       a9 c8		      LDA	#200
   2228  30ea		       85 9c		      STA	player3y
   2229  30ec				   .L0113		;  goto _UpdateCollisionCheck
   2230  30ec
   2231  30ec		       4c 67 51 	      jmp	._UpdateCollisionCheck
   2232  30ef
   2233  30ef				   ._SkipPlayer3Reset
   2234  30ef							; _SkipPlayer3Reset
   2235  30ef
   2236  30ef				   .
   2237  30ef							;
   2238  30ef
   2239  30ef				   .L0114		;  if player0y  <>  player4y then goto _SkipPlayer4Reset
   2240  30ef
   2241  30ef		       a5 99		      LDA	player0y
   2242  30f1		       c5 9d		      CMP	player4y
   2243  30f3		       f0 03		      BEQ	.skipL0114
   2244  30f5				   .condpart18
   2245  30f5		       4c 03 51 	      jmp	._SkipPlayer4Reset
   2246  30f8
   2247  30f8				   .skipL0114
   2248  30f8				   .L0115		;  player4x = 0  :  player4y = 200
   2249  30f8
   2250  30f8		       a9 00		      LDA	#0
   2251  30fa		       85 93		      STA	player4x
   2252  30fc		       a9 c8		      LDA	#200
   2253  30fe		       85 9d		      STA	player4y
   2254  3100				   .L0116		;  goto _UpdateCollisionCheck
   2255  3100
   2256  3100		       4c 67 51 	      jmp	._UpdateCollisionCheck
   2257  3103
   2258  3103				   ._SkipPlayer4Reset
   2259  3103							; _SkipPlayer4Reset
   2260  3103
   2261  3103				   .
   2262  3103							;
   2263  3103
   2264  3103				   .L0117		;  if player0y  <>  player5y then goto _SkipPlayer5Reset
   2265  3103
   2266  3103		       a5 99		      LDA	player0y
   2267  3105		       c5 9e		      CMP	player5y
   2268  3107		       f0 03		      BEQ	.skipL0117
   2269  3109				   .condpart19
   2270  3109		       4c 17 51 	      jmp	._SkipPlayer5Reset
   2271  310c
   2272  310c				   .skipL0117
   2273  310c				   .L0118		;  player5x = 0  :  player5y = 200
   2274  310c
   2275  310c		       a9 00		      LDA	#0
   2276  310e		       85 94		      STA	player5x
   2277  3110		       a9 c8		      LDA	#200
   2278  3112		       85 9e		      STA	player5y
   2279  3114				   .L0119		;  goto _UpdateCollisionCheck
   2280  3114
   2281  3114		       4c 67 51 	      jmp	._UpdateCollisionCheck
   2282  3117
   2283  3117				   ._SkipPlayer5Reset
   2284  3117							; _SkipPlayer5Reset
   2285  3117
   2286  3117				   .
   2287  3117							;
   2288  3117
   2289  3117				   .L0120		;  if player0y  <>  player6y then goto _SkipPlayer6Reset
   2290  3117
   2291  3117		       a5 99		      LDA	player0y
   2292  3119		       c5 9f		      CMP	player6y
   2293  311b		       f0 03		      BEQ	.skipL0120
   2294  311d				   .condpart20
   2295  311d		       4c 2b 51 	      jmp	._SkipPlayer6Reset
   2296  3120
   2297  3120				   .skipL0120
   2298  3120				   .L0121		;  player6x = 0  :  player6y = 200
   2299  3120
   2300  3120		       a9 00		      LDA	#0
   2301  3122		       85 95		      STA	player6x
   2302  3124		       a9 c8		      LDA	#200
   2303  3126		       85 9f		      STA	player6y
   2304  3128				   .L0122		;  goto _UpdateCollisionCheck
   2305  3128
   2306  3128		       4c 67 51 	      jmp	._UpdateCollisionCheck
   2307  312b
   2308  312b				   ._SkipPlayer6Reset
   2309  312b							; _SkipPlayer6Reset
   2310  312b
   2311  312b				   .
   2312  312b							;
   2313  312b
   2314  312b				   .L0123		;  if player0y  <>  player7y then goto _SkipPlayer7Reset
   2315  312b
   2316  312b		       a5 99		      LDA	player0y
   2317  312d		       c5 a0		      CMP	player7y
   2318  312f		       f0 03		      BEQ	.skipL0123
   2319  3131				   .condpart21
   2320  3131		       4c 3f 51 	      jmp	._SkipPlayer7Reset
   2321  3134
   2322  3134				   .skipL0123
   2323  3134				   .L0124		;  player7x = 0  :  player7y = 200
   2324  3134
   2325  3134		       a9 00		      LDA	#0
   2326  3136		       85 96		      STA	player7x
   2327  3138		       a9 c8		      LDA	#200
   2328  313a		       85 a0		      STA	player7y
   2329  313c				   .L0125		;  goto _UpdateCollisionCheck
   2330  313c
   2331  313c		       4c 67 51 	      jmp	._UpdateCollisionCheck
   2332  313f
   2333  313f				   ._SkipPlayer7Reset
   2334  313f							; _SkipPlayer7Reset
   2335  313f
   2336  313f				   .
   2337  313f							;
   2338  313f
   2339  313f				   .L0126		;  if player0y  <>  player8y then goto _SkipPlayer8Reset
   2340  313f
   2341  313f		       a5 99		      LDA	player0y
   2342  3141		       c5 a1		      CMP	player8y
   2343  3143		       f0 03		      BEQ	.skipL0126
   2344  3145				   .condpart22
   2345  3145		       4c 53 51 	      jmp	._SkipPlayer8Reset
   2346  3148
   2347  3148				   .skipL0126
   2348  3148				   .L0127		;  player8x = 0  :  player8y = 200
   2349  3148
   2350  3148		       a9 00		      LDA	#0
   2351  314a		       85 97		      STA	player8x
   2352  314c		       a9 c8		      LDA	#200
   2353  314e		       85 a1		      STA	player8y
   2354  3150				   .L0128		;  goto _UpdateCollisionCheck
   2355  3150
   2356  3150		       4c 67 51 	      jmp	._UpdateCollisionCheck
   2357  3153
   2358  3153				   ._SkipPlayer8Reset
   2359  3153							; _SkipPlayer8Reset
   2360  3153
   2361  3153				   .
   2362  3153							;
   2363  3153
   2364  3153				   .L0129		;  if player0y  <>  player9y then goto _SkipPlayer9Reset
   2365  3153
   2366  3153		       a5 99		      LDA	player0y
   2367  3155		       c5 a2		      CMP	player9y
   2368  3157		       f0 03		      BEQ	.skipL0129
   2369  3159				   .condpart23
   2370  3159		       4c 67 51 	      jmp	._SkipPlayer9Reset
   2371  315c
   2372  315c				   .skipL0129
   2373  315c				   .L0130		;  player9x = 0  :  player9y = 200
   2374  315c
   2375  315c		       a9 00		      LDA	#0
   2376  315e		       85 98		      STA	player9x
   2377  3160		       a9 c8		      LDA	#200
   2378  3162		       85 a2		      STA	player9y
   2379  3164				   .L0131		;  goto _UpdateCollisionCheck
   2380  3164
   2381  3164		       4c 67 51 	      jmp	._UpdateCollisionCheck
   2382  3167
   2383  3167				   ._SkipPlayer9Reset
   2384  3167							; _SkipPlayer9Reset
   2385  3167
   2386  3167				   .
   2387  3167							;
   2388  3167
   2389  3167				   ._UpdateCollisionCheck
   2390  3167							; _UpdateCollisionCheck
   2391  3167
   2392  3167				   .L0132		;  score  =  score + 1
   2393  3167
   2394  3167		       f8		      SED
   2395  3168		       18		      CLC
   2396  3169		       a5 ba		      LDA	score+2
   2397  316b		       69 01		      ADC	#$01
   2398  316d		       85 ba		      STA	score+2
   2399  316f		       a5 b9		      LDA	score+1
   2400  3171		       69 00		      ADC	#$00
   2401  3173		       85 b9		      STA	score+1
   2402  3175		       a5 b8		      LDA	score
   2403  3177		       69 00		      ADC	#$00
   2404  3179		       85 b8		      STA	score
   2405  317b		       d8		      CLD
   2406  317c				   .L0133		;  facesCounter  =  facesCounter - 1
   2407  317c
   2408  317c		       c6 d3		      DEC	facesCounter
   2409  317e				   .L0134		;  eatSound  =  EAT_SOUND_LENGTH
   2410  317e
   2411  317e		       a9 0a		      LDA	#EAT_SOUND_LENGTH
   2412  3180		       85 dd		      STA	eatSound
   2413  3182				   .
   2414  3182							;
   2415  3182
   2416  3182				   ._SkipCollisionDetection
   2417  3182							; _SkipCollisionDetection
   2418  3182
   2419  3182				   .L0135		;  return otherbank
   2420  3182
   2421  3182		       4c e0 df 	      JMP	BS_return
   2422  3185				   .
   2423  3185							;
   2424  3185
   2425  3185				   .
   2426  3185							;
   2427  3185
   2428  3185				   ._OtherPlayersSetup
   2429  3185							; _OtherPlayersSetup
   2430  3185
   2431  3185				   .L0136		;  player1-9:
   2432  3185
   2433  3185		       a9 e2		      lda	#<(playerpointers+0)
   2434  3187		       8d 50 10 	      sta	DF0LOW
   2435  318a		       a9 01		      lda	#(>(playerpointers+0)) & $0F
   2436  318c		       8d 68 10 	      sta	DF0HI
   2437  318f		       a2 cc		      LDX	#<playerL0136_1
   2438  3191		       8e 78 10 	      STX	DF0WRITE
   2439  3194		       a9 61		      LDA	#((>playerL0136_1) & $0f) | (((>playerL0136_1) / 2) & $70)
   2440  3196		       8d 78 10 	      STA	DF0WRITE
   2441  3199		       8e 78 10 	      STX	DF0WRITE
   2442  319c		       8d 78 10 	      STA	DF0WRITE
   2443  319f		       8e 78 10 	      STX	DF0WRITE
   2444  31a2		       8d 78 10 	      STA	DF0WRITE
   2445  31a5		       8e 78 10 	      STX	DF0WRITE
   2446  31a8		       8d 78 10 	      STA	DF0WRITE
   2447  31ab		       8e 78 10 	      STX	DF0WRITE
   2448  31ae		       8d 78 10 	      STA	DF0WRITE
   2449  31b1		       8e 78 10 	      STX	DF0WRITE
   2450  31b4		       8d 78 10 	      STA	DF0WRITE
   2451  31b7		       8e 78 10 	      STX	DF0WRITE
   2452  31ba		       8d 78 10 	      STA	DF0WRITE
   2453  31bd		       8e 78 10 	      STX	DF0WRITE
   2454  31c0		       8d 78 10 	      STA	DF0WRITE
   2455  31c3		       8e 78 10 	      STX	DF0WRITE
   2456  31c6		       8d 78 10 	      STA	DF0WRITE
   2457  31c9		       a9 0a		      LDA	#10
   2458  31cb		       85 a6		      STA	player1height
   2459  31cd		       85 a7		      STA	player2height
   2460  31cf		       85 a8		      STA	player3height
   2461  31d1		       85 a9		      STA	player4height
   2462  31d3		       85 aa		      STA	player5height
   2463  31d5		       85 ab		      STA	player6height
   2464  31d7		       85 ac		      STA	player7height
   2465  31d9		       85 ad		      STA	player8height
   2466  31db		       85 ae		      STA	player9height
   2467  31dd				   .
   2468  31dd							;
   2469  31dd
   2470  31dd				   .L0137		;  player1-9color:
   2471  31dd
   2472  31dd		       a9 f4		      lda	#<(playerpointers+18)
   2473  31df		       8d 50 10 	      sta	DF0LOW
   2474  31e2		       a9 01		      lda	#(>(playerpointers+18)) & $0F
   2475  31e4		       8d 68 10 	      sta	DF0HI
   2476  31e7		       a2 d6		      LDX	#<playercolorL0137_1
   2477  31e9		       8e 78 10 	      STX	DF0WRITE
   2478  31ec		       a9 61		      LDA	#((>playercolorL0137_1) & $0f) | (((>playercolorL0137_1) / 2) & $70)
   2479  31ee		       8d 78 10 	      STA	DF0WRITE
   2480  31f1		       8e 78 10 	      STX	DF0WRITE
   2481  31f4		       8d 78 10 	      STA	DF0WRITE
   2482  31f7		       8e 78 10 	      STX	DF0WRITE
   2483  31fa		       8d 78 10 	      STA	DF0WRITE
   2484  31fd		       8e 78 10 	      STX	DF0WRITE
   2485  3200		       8d 78 10 	      STA	DF0WRITE
   2486  3203		       8e 78 10 	      STX	DF0WRITE
   2487  3206		       8d 78 10 	      STA	DF0WRITE
   2488  3209		       8e 78 10 	      STX	DF0WRITE
   2489  320c		       8d 78 10 	      STA	DF0WRITE
   2490  320f		       8e 78 10 	      STX	DF0WRITE
   2491  3212		       8d 78 10 	      STA	DF0WRITE
   2492  3215		       8e 78 10 	      STX	DF0WRITE
   2493  3218		       8d 78 10 	      STA	DF0WRITE
   2494  321b		       8e 78 10 	      STX	DF0WRITE
   2495  321e		       8d 78 10 	      STA	DF0WRITE
   2496  3221				   .
   2497  3221							;
   2498  3221
   2499  3221				   .L0138		;  player0x  =   ( GOBLIN_MAX_X / 2 )	+ 4
   2500  3221
   2501  3221							; complex statement detected
   2502  3221		       a9 88		      LDA	#GOBLIN_MAX_X
   2503  3223		       4a		      lsr
   2504  3224		       18		      CLC
   2505  3225		       69 04		      ADC	#4
   2506  3227		       85 80		      STA	player0x
   2507  3229				   .L0139		;  player0y  =  GOBLIN_MAX_Y
   2508  3229
   2509  3229		       a9 a0		      LDA	#GOBLIN_MAX_Y
   2510  322b		       85 99		      STA	player0y
   2511  322d				   .L0140		;  missile1x  =  player0x
   2512  322d
   2513  322d		       a5 80		      LDA	player0x
   2514  322f		       85 83		      STA	missile1x
   2515  3231				   .L0141		;  missile1y  =  player0y
   2516  3231
   2517  3231		       a5 99		      LDA	player0y
   2518  3233		       85 c0		      STA	missile1y
   2519  3235				   .
   2520  3235							;
   2521  3235
   2522  3235				   ._Player1Setup
   2523  3235							; _Player1Setup
   2524  3235
   2525  3235				   .L0142		;  player1x  =   ( rand  &  %01111000 )   +  16
   2526  3235
   2527  3235							; complex statement detected
   2528  3235		       ad 00 10 	      lda	rand
   2529  3238		       29 78		      AND	#%01111000
   2530  323a		       18		      CLC
   2531  323b		       69 10		      ADC	#16
   2532  323d		       85 90		      STA	player1x
   2533  323f				   .L0143		;  player1y  =  0
   2534  323f
   2535  323f		       a9 00		      LDA	#0
   2536  3241		       85 9a		      STA	player1y
   2537  3243				   .L0144		;  drawscreen
   2538  3243
   2539  3243		       85 81		      sta	temp7
   2540  3245		       a9 52		      lda	#>(ret_point8-1)
   2541  3247		       48		      pha
   2542  3248		       a9 5a		      lda	#<(ret_point8-1)
   2543  324a		       48		      pha
   2544  324b		       a9 19		      lda	#>(drawscreen-1)
   2545  324d		       48		      pha
   2546  324e		       a9 48		      lda	#<(drawscreen-1)
   2547  3250		       48		      pha
   2548  3251		       a5 81		      lda	temp7
   2549  3253		       48		      pha
   2550  3254		       8a		      txa
   2551  3255		       48		      pha
   2552  3256		       a2 01		      ldx	#1
   2553  3258		       4c ee df 	      jmp	BS_jsr
   2554  325b				   ret_point8
   2555  325b				   .L0145		;  if collision(playfield,player1) then goto _Player1Setup
   2556  325b
   2557  325b		       24 03		      bit	CXP1FB
   2558  325d		       10 03		      BPL	.skipL0145
   2559  325f				   .condpart24
   2560  325f		       4c 35 52 	      jmp	._Player1Setup
   2561  3262
   2562  3262				   .skipL0145
   2563  3262				   .
   2564  3262							;
   2565  3262
   2566  3262				   ._Player2Setup
   2567  3262							; _Player2Setup
   2568  3262
   2569  3262				   .L0146		;  player2x  =   ( rand  &  %01111000 )   +  16
   2570  3262
   2571  3262							; complex statement detected
   2572  3262		       ad 00 10 	      lda	rand
   2573  3265		       29 78		      AND	#%01111000
   2574  3267		       18		      CLC
   2575  3268		       69 10		      ADC	#16
   2576  326a		       85 91		      STA	player2x
   2577  326c				   .L0147		;  player2y  =  GOBLIN_DELTA_Y * 1
   2578  326c
   2579  326c		       a9 10		      LDA	#GOBLIN_DELTA_Y
   2580  326e		       85 9b		      STA	player2y
   2581  3270				   .L0148		;  drawscreen
   2582  3270
   2583  3270		       85 81		      sta	temp7
   2584  3272		       a9 52		      lda	#>(ret_point9-1)
   2585  3274		       48		      pha
   2586  3275		       a9 87		      lda	#<(ret_point9-1)
   2587  3277		       48		      pha
   2588  3278		       a9 19		      lda	#>(drawscreen-1)
   2589  327a		       48		      pha
   2590  327b		       a9 48		      lda	#<(drawscreen-1)
   2591  327d		       48		      pha
   2592  327e		       a5 81		      lda	temp7
   2593  3280		       48		      pha
   2594  3281		       8a		      txa
   2595  3282		       48		      pha
   2596  3283		       a2 01		      ldx	#1
   2597  3285		       4c ee df 	      jmp	BS_jsr
   2598  3288				   ret_point9
   2599  3288				   .L0149		;  if collision(playfield,player1) then goto _Player2Setup
   2600  3288
   2601  3288		       24 03		      bit	CXP1FB
   2602  328a		       10 03		      BPL	.skipL0149
   2603  328c				   .condpart25
   2604  328c		       4c 62 52 	      jmp	._Player2Setup
   2605  328f
   2606  328f				   .skipL0149
   2607  328f				   .
   2608  328f							;
   2609  328f
   2610  328f				   ._Player3Setup
   2611  328f							; _Player3Setup
   2612  328f
   2613  328f				   .L0150		;  player3x  =   ( rand  &  %01111000 )   +  16
   2614  328f
   2615  328f							; complex statement detected
   2616  328f		       ad 00 10 	      lda	rand
   2617  3292		       29 78		      AND	#%01111000
   2618  3294		       18		      CLC
   2619  3295		       69 10		      ADC	#16
   2620  3297		       85 92		      STA	player3x
   2621  3299				   .L0151		;  player3y  =  GOBLIN_DELTA_Y * 2
   2622  3299
   2623  3299		       a9 10		      LDA	#GOBLIN_DELTA_Y
   2624  329b		       0a		      asl
   2625  329c		       85 9c		      STA	player3y
   2626  329e				   .L0152		;  drawscreen
   2627  329e
   2628  329e		       85 81		      sta	temp7
   2629  32a0		       a9 52		      lda	#>(ret_point10-1)
   2630  32a2		       48		      pha
   2631  32a3		       a9 b5		      lda	#<(ret_point10-1)
   2632  32a5		       48		      pha
   2633  32a6		       a9 19		      lda	#>(drawscreen-1)
   2634  32a8		       48		      pha
   2635  32a9		       a9 48		      lda	#<(drawscreen-1)
   2636  32ab		       48		      pha
   2637  32ac		       a5 81		      lda	temp7
   2638  32ae		       48		      pha
   2639  32af		       8a		      txa
   2640  32b0		       48		      pha
   2641  32b1		       a2 01		      ldx	#1
   2642  32b3		       4c ee df 	      jmp	BS_jsr
   2643  32b6				   ret_point10
   2644  32b6				   .L0153		;  if collision(playfield,player1) then goto _Player3Setup
   2645  32b6
   2646  32b6		       24 03		      bit	CXP1FB
   2647  32b8		       10 03		      BPL	.skipL0153
   2648  32ba				   .condpart26
   2649  32ba		       4c 8f 52 	      jmp	._Player3Setup
   2650  32bd
   2651  32bd				   .skipL0153
   2652  32bd				   .
   2653  32bd							;
   2654  32bd
   2655  32bd				   ._Player4Setup
   2656  32bd							; _Player4Setup
   2657  32bd
   2658  32bd				   .L0154		;  player4x  =   ( rand  &  %01111000 )   +  16
   2659  32bd
   2660  32bd							; complex statement detected
   2661  32bd		       ad 00 10 	      lda	rand
   2662  32c0		       29 78		      AND	#%01111000
   2663  32c2		       18		      CLC
   2664  32c3		       69 10		      ADC	#16
   2665  32c5		       85 93		      STA	player4x
   2666  32c7				   .L0155		;  player4y  =  GOBLIN_DELTA_Y * 3
   2667  32c7
   2668  32c7		       a9 10		      LDA	#GOBLIN_DELTA_Y
   2669  32c9		       0a		      asl
   2670  32ca		       18		      clc
   2671  32cb		       69 10		      adc	#GOBLIN_DELTA_Y
   2672  32cd		       85 9d		      STA	player4y
   2673  32cf				   .L0156		;  drawscreen
   2674  32cf
   2675  32cf		       85 81		      sta	temp7
   2676  32d1		       a9 52		      lda	#>(ret_point11-1)
   2677  32d3		       48		      pha
   2678  32d4		       a9 e6		      lda	#<(ret_point11-1)
   2679  32d6		       48		      pha
   2680  32d7		       a9 19		      lda	#>(drawscreen-1)
   2681  32d9		       48		      pha
   2682  32da		       a9 48		      lda	#<(drawscreen-1)
   2683  32dc		       48		      pha
   2684  32dd		       a5 81		      lda	temp7
   2685  32df		       48		      pha
   2686  32e0		       8a		      txa
   2687  32e1		       48		      pha
   2688  32e2		       a2 01		      ldx	#1
   2689  32e4		       4c ee df 	      jmp	BS_jsr
   2690  32e7				   ret_point11
   2691  32e7				   .L0157		;  if collision(playfield,player1) then goto _Player4Setup
   2692  32e7
   2693  32e7		       24 03		      bit	CXP1FB
   2694  32e9		       10 03		      BPL	.skipL0157
   2695  32eb				   .condpart27
   2696  32eb		       4c bd 52 	      jmp	._Player4Setup
   2697  32ee
   2698  32ee				   .skipL0157
   2699  32ee				   .
   2700  32ee							;
   2701  32ee
   2702  32ee				   ._Player5Setup
   2703  32ee							; _Player5Setup
   2704  32ee
   2705  32ee				   .L0158		;  player5x  =   ( rand  &  %01111000 )   +  16
   2706  32ee
   2707  32ee							; complex statement detected
   2708  32ee		       ad 00 10 	      lda	rand
   2709  32f1		       29 78		      AND	#%01111000
   2710  32f3		       18		      CLC
   2711  32f4		       69 10		      ADC	#16
   2712  32f6		       85 94		      STA	player5x
   2713  32f8				   .L0159		;  player5y  =  GOBLIN_DELTA_Y * 4
   2714  32f8
   2715  32f8		       a9 10		      LDA	#GOBLIN_DELTA_Y
   2716  32fa		       0a		      asl
   2717  32fb		       0a		      asl
   2718  32fc		       85 9e		      STA	player5y
   2719  32fe				   .L0160		;  drawscreen
   2720  32fe
   2721  32fe		       85 81		      sta	temp7
   2722  3300		       a9 53		      lda	#>(ret_point12-1)
   2723  3302		       48		      pha
   2724  3303		       a9 15		      lda	#<(ret_point12-1)
   2725  3305		       48		      pha
   2726  3306		       a9 19		      lda	#>(drawscreen-1)
   2727  3308		       48		      pha
   2728  3309		       a9 48		      lda	#<(drawscreen-1)
   2729  330b		       48		      pha
   2730  330c		       a5 81		      lda	temp7
   2731  330e		       48		      pha
   2732  330f		       8a		      txa
   2733  3310		       48		      pha
   2734  3311		       a2 01		      ldx	#1
   2735  3313		       4c ee df 	      jmp	BS_jsr
   2736  3316				   ret_point12
   2737  3316				   .L0161		;  if collision(player1,playfield) then goto _Player5Setup
   2738  3316
   2739  3316		       24 03		      bit	CXP1FB
   2740  3318		       10 03		      BPL	.skipL0161
   2741  331a				   .condpart28
   2742  331a		       4c ee 52 	      jmp	._Player5Setup
   2743  331d
   2744  331d				   .skipL0161
   2745  331d				   .
   2746  331d							;
   2747  331d
   2748  331d				   ._Player6Setup
   2749  331d							; _Player6Setup
   2750  331d
   2751  331d				   .L0162		;  player6x  =   ( rand  &  %01111000 )   +  16
   2752  331d
   2753  331d							; complex statement detected
   2754  331d		       ad 00 10 	      lda	rand
   2755  3320		       29 78		      AND	#%01111000
   2756  3322		       18		      CLC
   2757  3323		       69 10		      ADC	#16
   2758  3325		       85 95		      STA	player6x
   2759  3327				   .L0163		;  player6y  =  GOBLIN_DELTA_Y * 5
   2760  3327
   2761  3327		       a9 10		      LDA	#GOBLIN_DELTA_Y
   2762  3329		       0a		      asl
   2763  332a		       0a		      asl
   2764  332b		       18		      clc
   2765  332c		       69 10		      adc	#GOBLIN_DELTA_Y
   2766  332e		       85 9f		      STA	player6y
   2767  3330				   .L0164		;  drawscreen
   2768  3330
   2769  3330		       85 81		      sta	temp7
   2770  3332		       a9 53		      lda	#>(ret_point13-1)
   2771  3334		       48		      pha
   2772  3335		       a9 47		      lda	#<(ret_point13-1)
   2773  3337		       48		      pha
   2774  3338		       a9 19		      lda	#>(drawscreen-1)
   2775  333a		       48		      pha
   2776  333b		       a9 48		      lda	#<(drawscreen-1)
   2777  333d		       48		      pha
   2778  333e		       a5 81		      lda	temp7
   2779  3340		       48		      pha
   2780  3341		       8a		      txa
   2781  3342		       48		      pha
   2782  3343		       a2 01		      ldx	#1
   2783  3345		       4c ee df 	      jmp	BS_jsr
   2784  3348				   ret_point13
   2785  3348				   .L0165		;  if collision(player1,playfield) then goto _Player6Setup
   2786  3348
   2787  3348		       24 03		      bit	CXP1FB
   2788  334a		       10 03		      BPL	.skipL0165
   2789  334c				   .condpart29
   2790  334c		       4c 1d 53 	      jmp	._Player6Setup
   2791  334f
   2792  334f				   .skipL0165
   2793  334f				   .
   2794  334f							;
   2795  334f
   2796  334f				   ._Player7Setup
   2797  334f							; _Player7Setup
   2798  334f
   2799  334f				   .L0166		;  player7x  =   ( rand  &  %01111000 )   +  16
   2800  334f
   2801  334f							; complex statement detected
   2802  334f		       ad 00 10 	      lda	rand
   2803  3352		       29 78		      AND	#%01111000
   2804  3354		       18		      CLC
   2805  3355		       69 10		      ADC	#16
   2806  3357		       85 96		      STA	player7x
   2807  3359				   .L0167		;  player7y  =  GOBLIN_DELTA_Y * 6
   2808  3359
   2809  3359		       a9 10		      LDA	#GOBLIN_DELTA_Y
   2810  335b		       0a		      asl
   2811  335c		       18		      clc
   2812  335d		       69 10		      adc	#GOBLIN_DELTA_Y
   2813  335f		       0a		      asl
   2814  3360		       85 a0		      STA	player7y
   2815  3362				   .L0168		;  drawscreen
   2816  3362
   2817  3362		       85 81		      sta	temp7
   2818  3364		       a9 53		      lda	#>(ret_point14-1)
   2819  3366		       48		      pha
   2820  3367		       a9 79		      lda	#<(ret_point14-1)
   2821  3369		       48		      pha
   2822  336a		       a9 19		      lda	#>(drawscreen-1)
   2823  336c		       48		      pha
   2824  336d		       a9 48		      lda	#<(drawscreen-1)
   2825  336f		       48		      pha
   2826  3370		       a5 81		      lda	temp7
   2827  3372		       48		      pha
   2828  3373		       8a		      txa
   2829  3374		       48		      pha
   2830  3375		       a2 01		      ldx	#1
   2831  3377		       4c ee df 	      jmp	BS_jsr
   2832  337a				   ret_point14
   2833  337a				   .L0169		;  if collision(player1,playfield) then goto _Player7Setup
   2834  337a
   2835  337a		       24 03		      bit	CXP1FB
   2836  337c		       10 03		      BPL	.skipL0169
   2837  337e				   .condpart30
   2838  337e		       4c 4f 53 	      jmp	._Player7Setup
   2839  3381
   2840  3381				   .skipL0169
   2841  3381				   .
   2842  3381							;
   2843  3381
   2844  3381				   ._Player8Setup
   2845  3381							; _Player8Setup
   2846  3381
   2847  3381				   .L0170		;  player8x  =   ( rand  &  %01111000 )   +  16
   2848  3381
   2849  3381							; complex statement detected
   2850  3381		       ad 00 10 	      lda	rand
   2851  3384		       29 78		      AND	#%01111000
   2852  3386		       18		      CLC
   2853  3387		       69 10		      ADC	#16
   2854  3389		       85 97		      STA	player8x
   2855  338b				   .L0171		;  player8y  =  GOBLIN_DELTA_Y * 7
   2856  338b
   2857  338b		       a9 10		      LDA	#GOBLIN_DELTA_Y
   2858  338d		       0a		      asl
   2859  338e		       0a		      asl
   2860  338f		       0a		      asl
   2861  3390		       38		      sec
   2862  3391		       e9 10		      sbc	#GOBLIN_DELTA_Y
   2863  3393		       85 a1		      STA	player8y
   2864  3395				   .L0172		;  drawscreen
   2865  3395
   2866  3395		       85 81		      sta	temp7
   2867  3397		       a9 53		      lda	#>(ret_point15-1)
   2868  3399		       48		      pha
   2869  339a		       a9 ac		      lda	#<(ret_point15-1)
   2870  339c		       48		      pha
   2871  339d		       a9 19		      lda	#>(drawscreen-1)
   2872  339f		       48		      pha
   2873  33a0		       a9 48		      lda	#<(drawscreen-1)
   2874  33a2		       48		      pha
   2875  33a3		       a5 81		      lda	temp7
   2876  33a5		       48		      pha
   2877  33a6		       8a		      txa
   2878  33a7		       48		      pha
   2879  33a8		       a2 01		      ldx	#1
   2880  33aa		       4c ee df 	      jmp	BS_jsr
   2881  33ad				   ret_point15
   2882  33ad				   .L0173		;  if collision(player1,playfield) then goto _Player8Setup
   2883  33ad
   2884  33ad		       24 03		      bit	CXP1FB
   2885  33af		       10 03		      BPL	.skipL0173
   2886  33b1				   .condpart31
   2887  33b1		       4c 81 53 	      jmp	._Player8Setup
   2888  33b4
   2889  33b4				   .skipL0173
   2890  33b4				   .
   2891  33b4							;
   2892  33b4
   2893  33b4				   ._Player9Setup
   2894  33b4							; _Player9Setup
   2895  33b4
   2896  33b4				   .L0174		;  player9x  =   ( rand  &  %01111000 )   +  16
   2897  33b4
   2898  33b4							; complex statement detected
   2899  33b4		       ad 00 10 	      lda	rand
   2900  33b7		       29 78		      AND	#%01111000
   2901  33b9		       18		      CLC
   2902  33ba		       69 10		      ADC	#16
   2903  33bc		       85 98		      STA	player9x
   2904  33be				   .L0175		;  player9y  =  GOBLIN_DELTA_Y * 8
   2905  33be
   2906  33be		       a9 10		      LDA	#GOBLIN_DELTA_Y
   2907  33c0		       0a		      asl
   2908  33c1		       0a		      asl
   2909  33c2		       0a		      asl
   2910  33c3		       85 a2		      STA	player9y
   2911  33c5				   .L0176		;  drawscreen
   2912  33c5
   2913  33c5		       85 81		      sta	temp7
   2914  33c7		       a9 53		      lda	#>(ret_point16-1)
   2915  33c9		       48		      pha
   2916  33ca		       a9 dc		      lda	#<(ret_point16-1)
   2917  33cc		       48		      pha
   2918  33cd		       a9 19		      lda	#>(drawscreen-1)
   2919  33cf		       48		      pha
   2920  33d0		       a9 48		      lda	#<(drawscreen-1)
   2921  33d2		       48		      pha
   2922  33d3		       a5 81		      lda	temp7
   2923  33d5		       48		      pha
   2924  33d6		       8a		      txa
   2925  33d7		       48		      pha
   2926  33d8		       a2 01		      ldx	#1
   2927  33da		       4c ee df 	      jmp	BS_jsr
   2928  33dd				   ret_point16
   2929  33dd				   .L0177		;  if collision(player1,playfield) then goto _Player9Setup
   2930  33dd
   2931  33dd		       24 03		      bit	CXP1FB
   2932  33df		       10 03		      BPL	.skipL0177
   2933  33e1				   .condpart32
   2934  33e1		       4c b4 53 	      jmp	._Player9Setup
   2935  33e4
   2936  33e4				   .skipL0177
   2937  33e4				   .
   2938  33e4							;
   2939  33e4
   2940  33e4				   .L0178		;  facesCounter  =  9
   2941  33e4
   2942  33e4		       a9 09		      LDA	#9
   2943  33e6		       85 d3		      STA	facesCounter
   2944  33e8				   .
   2945  33e8							;
   2946  33e8
   2947  33e8				   .L0179		;  return otherbank
   2948  33e8
   2949  33e8		       4c e0 df 	      JMP	BS_return
   2950  33eb				   .
   2951  33eb							;
   2952  33eb
   2953  33eb				   ._PlayFieldSetup
   2954  33eb							; _PlayFieldSetup
   2955  33eb
   2956  33eb				   .L0180		;  pfclear
   2957  33eb
   2958  33eb		       a9 a4		      lda	#<C_function
   2959  33ed		       8d 50 10 	      sta	DF0LOW
   2960  33f0		       a9 01		      lda	#(>C_function) & $0F
   2961  33f2		       8d 68 10 	      sta	DF0HI
   2962  33f5		       a2 1c		      ldx	#28
   2963  33f7		       8e 78 10 	      stx	DF0WRITE
   2964  33fa		       a9 00		      LDA	#0
   2965  33fc		       8d 78 10 	      sta	DF0WRITE
   2966  33ff		       a9 ff		      lda	#255
   2967  3401		       8d 5a 10 	      sta	CALLFUNCTION
   2968  3404				   .L0181		;  for i  =  0 to 18 step 2
   2969  3404
   2970  3404		       a9 00		      LDA	#0
   2971  3406		       85 d9		      STA	i
   2972  3408				   .L0181fori
   2973  3408				   .L0182		;  for c  =  1 to 3
   2974  3408
   2975  3408		       a9 01		      LDA	#1
   2976  340a		       85 d3		      STA	c
   2977  340c				   .L0182forc
   2978  340c				   .L0183		;  x  =  rand	&  %00011110
   2979  340c
   2980  340c		       ad 00 10 	      lda	rand
   2981  340f		       29 1e		      AND	#%00011110
   2982  3411		       85 e8		      STA	x
   2983  3413				   .L0184		;  z  =  x + 1
   2984  3413
   2985  3413		       a5 e8		      LDA	x
   2986  3415		       18		      CLC
   2987  3416		       69 01		      ADC	#1
   2988  3418		       85 ea		      STA	z
   2989  341a				   .L0185		;  pfhline x i z on
   2990  341a
   2991  341a		       a9 a4		      lda	#<C_function
   2992  341c		       8d 50 10 	      sta	DF0LOW
   2993  341f		       a9 01		      lda	#(>C_function) & $0F
   2994  3421		       8d 68 10 	      sta	DF0HI
   2995  3424		       a2 08		      LDX	#8
   2996  3426		       8e 78 10 	      STX	DF0WRITE
   2997  3429		       a5 ea		      LDA	z
   2998  342b		       8d 78 10 	      STA	DF0WRITE
   2999  342e		       a4 d9		      LDY	i
   3000  3430		       8c 78 10 	      STY	DF0WRITE
   3001  3433		       a5 e8		      LDA	x
   3002  3435		       8d 78 10 	      STA	DF0WRITE
   3003  3438		       a9 ff		      lda	#255
   3004  343a		       8d 5a 10 	      sta	CALLFUNCTION
   3005  343d				   .L0186		;  next
   3006  343d
   3007  343d		       a5 d3		      LDA	c
   3008  343f		       c9 03		      CMP	#3
   3009  3441
   3010  3441		       e6 d3		      INC	c
   3011  3443		       90 c7		      bcc	.L0182forc
   3012  3445				  -	      if	( (((((#>*)&$1f)*256)|(#<.L0182forc))>=bankswitch_hotspot) && (((((#>*)&$1f)*256)|(#<.L0182forc))<=(bankswitch_hotspot+bs_mask)) )
   3013  3445				  -	      echo	"WARNING: branch near the end of bank 3 may accidentally trigger a bankswitch. Reposition code there if bad things happen."
   3014  3445					      endif
   3015  3445				   .L0187		;  next
   3016  3445
   3017  3445		       a5 d9		      LDA	i
   3018  3447		       18		      CLC
   3019  3448		       69 02		      ADC	#2
   3020  344a
   3021  344a		       85 d9		      STA	i
   3022  344c		       c9 13		      CMP	#18+1
   3023  344e		       90 b8		      bcc	.L0181fori
   3024  3450				  -	      if	( (((((#>*)&$1f)*256)|(#<.L0181fori))>=bankswitch_hotspot) && (((((#>*)&$1f)*256)|(#<.L0181fori))<=(bankswitch_hotspot+bs_mask)) )
   3025  3450				  -	      echo	"WARNING: branch near the end of bank 3 may accidentally trigger a bankswitch. Reposition code there if bad things happen."
   3026  3450					      endif
   3027  3450				   .
   3028  3450							;
   3029  3450
   3030  3450				   .L0188		;  return otherbank
   3031  3450
   3032  3450		       4c e0 df 	      JMP	BS_return
   3033  3453				   .
   3034  3453							;
   3035  3453
   3036  3453				   ._GameOverLoop
   3037  3453							; _GameOverLoop
   3038  3453
   3039  3453				   .
   3040  3453							;
   3041  3453
   3042  3453				   .
   3043  3453							;
   3044  3453
   3045  3453				   ._GameOverLoopStage0
   3046  3453							; _GameOverLoopStage0
   3047  3453
   3048  3453				   .
   3049  3453							;
   3050  3453
   3051  3453				   .
   3052  3453							;
   3053  3453
   3054  3453				   .L0189		;  if gameStage  >  0 then goto _SkipGameOverLoopStage0
   3055  3453
   3056  3453		       a9 00		      LDA	#0
   3057  3455		       c5 e9		      CMP	gameStage
   3058  3457		       b0 03		      BCS	.skipL0189
   3059  3459				   .condpart33
   3060  3459		       4c 9d 54 	      jmp	._SkipGameOverLoopStage0
   3061  345c
   3062  345c				   .skipL0189
   3063  345c				   .
   3064  345c							;
   3065  345c
   3066  345c				   .
   3067  345c							;
   3068  345c
   3069  345c				   .L0190		;  player0:
   3070  345c
   3071  345c		       a2 e4		      LDX	#<playerL0190_0
   3072  345e		       86 bd		      STX	player0pointerlo
   3073  3460		       a9 61		      LDA	#((>playerL0190_0) & $0f) | (((>playerL0190_0) / 2) & $70)
   3074  3462		       85 be		      STA	player0pointerhi
   3075  3464		       a9 0e		      LDA	#14
   3076  3466		       85 a5		      STA	player0height
   3077  3468				   .
   3078  3468							;
   3079  3468
   3080  3468				   .L0191		;  missile1x  =  0
   3081  3468
   3082  3468		       a9 00		      LDA	#0
   3083  346a		       85 83		      STA	missile1x
   3084  346c				   .L0192		;  missile1y  =  200
   3085  346c
   3086  346c		       a9 c8		      LDA	#200
   3087  346e		       85 c0		      STA	missile1y
   3088  3470				   .
   3089  3470							;
   3090  3470
   3091  3470				   .L0193		;  if crashSound > 0 then goto _SkipCrashSoundSetup
   3092  3470
   3093  3470		       a9 00		      LDA	#0
   3094  3472		       c5 dd		      CMP	crashSound
   3095  3474		       b0 03		      BCS	.skipL0193
   3096  3476				   .condpart34
   3097  3476		       4c 7d 54 	      jmp	._SkipCrashSoundSetup
   3098  3479
   3099  3479				   .skipL0193
   3100  3479				   .L0194		;  crashSound	=  CRASH_SOUND_LENGTH
   3101  3479
   3102  3479		       a9 08		      LDA	#CRASH_SOUND_LENGTH
   3103  347b		       85 dd		      STA	crashSound
   3104  347d				   ._SkipCrashSoundSetup
   3105  347d							; _SkipCrashSoundSetup
   3106  347d
   3107  347d				   .
   3108  347d							;
   3109  347d
   3110  347d				   .L0195		;  AUDV0  =  CRASH_SOUND_VOLUME
   3111  347d
   3112  347d		       a9 06		      LDA	#CRASH_SOUND_VOLUME
   3113  347f		       85 19		      STA	AUDV0
   3114  3481				   .L0196		;  AUDC0  =  4
   3115  3481
   3116  3481		       a9 04		      LDA	#4
   3117  3483		       85 15		      STA	AUDC0
   3118  3485				   .L0197		;  AUDF0  =  CRASH_SOUND_FREQUENCY
   3119  3485
   3120  3485		       a9 04		      LDA	#CRASH_SOUND_FREQUENCY
   3121  3487		       85 17		      STA	AUDF0
   3122  3489				   .L0198		;  crashSound	=  crashSound - 1
   3123  3489
   3124  3489		       c6 dd		      DEC	crashSound
   3125  348b				   .
   3126  348b							;
   3127  348b
   3128  348b				   .L0199		;  if crashSound > 0 then return otherbank
   3129  348b
   3130  348b		       a9 00		      LDA	#0
   3131  348d		       c5 dd		      CMP	crashSound
   3132  348f		       b0 03		      BCS	.skipL0199
   3133  3491				   .condpart35
   3134  3491		       4c e0 df 	      JMP	BS_return
   3135  3494				   .skipL0199
   3136  3494				   .
   3137  3494							;
   3138  3494
   3139  3494				   .L0200		;  AUDV0  =  0
   3140  3494
   3141  3494		       a9 00		      LDA	#0
   3142  3496		       85 19		      STA	AUDV0
   3143  3498				   .L0201		;  gameStage  =  gameStage + 1
   3144  3498
   3145  3498		       e6 e9		      INC	gameStage
   3146  349a				   .L0202		;  return otherbank
   3147  349a
   3148  349a		       4c e0 df 	      JMP	BS_return
   3149  349d				   ._SkipGameOverLoopStage0
   3150  349d							; _SkipGameOverLoopStage0
   3151  349d
   3152  349d				   .
   3153  349d							;
   3154  349d
   3155  349d				   ._GameOverLoopStage1
   3156  349d							; _GameOverLoopStage1
   3157  349d
   3158  349d				   .L0203		;  if gameStage  >  1 then goto _SkipGameOverLoopStage1
   3159  349d
   3160  349d		       a9 01		      LDA	#1
   3161  349f		       c5 e9		      CMP	gameStage
   3162  34a1		       b0 03		      BCS	.skipL0203
   3163  34a3				   .condpart36
   3164  34a3		       4c f4 54 	      jmp	._SkipGameOverLoopStage1
   3165  34a6
   3166  34a6				   .skipL0203
   3167  34a6				   .
   3168  34a6							;
   3169  34a6
   3170  34a6				   .L0204		;  if player1y = 200 then goto _SkipNoFaceStage1
   3171  34a6
   3172  34a6		       a5 9a		      LDA	player1y
   3173  34a8		       c9 c8		      CMP	#200
   3174  34aa		       d0 03		      BNE	.skipL0204
   3175  34ac				   .condpart37
   3176  34ac		       4c eb 54 	      jmp	._SkipNoFaceStage1
   3177  34af
   3178  34af				   .skipL0204
   3179  34af				   .
   3180  34af							;
   3181  34af
   3182  34af				   .L0205		;  player1:
   3183  34af
   3184  34af		       a9 e2		      lda	#<(playerpointers+0)
   3185  34b1		       8d 50 10 	      sta	DF0LOW
   3186  34b4		       a9 01		      lda	#(>(playerpointers+0)) & $0F
   3187  34b6		       8d 68 10 	      sta	DF0HI
   3188  34b9		       a2 f2		      LDX	#<playerL0205_1
   3189  34bb		       8e 78 10 	      STX	DF0WRITE
   3190  34be		       a9 61		      LDA	#((>playerL0205_1) & $0f) | (((>playerL0205_1) / 2) & $70)
   3191  34c0		       8d 78 10 	      STA	DF0WRITE
   3192  34c3		       a9 09		      LDA	#9
   3193  34c5		       85 a6		      STA	player1height
   3194  34c7				   .
   3195  34c7							;
   3196  34c7
   3197  34c7				   .L0206		;  if smileSound > 0 then goto _SkipSmileSoundSetup1
   3198  34c7
   3199  34c7		       a9 00		      LDA	#0
   3200  34c9		       c5 dd		      CMP	smileSound
   3201  34cb		       b0 03		      BCS	.skipL0206
   3202  34cd				   .condpart38
   3203  34cd		       4c d4 54 	      jmp	._SkipSmileSoundSetup1
   3204  34d0
   3205  34d0				   .skipL0206
   3206  34d0				   .L0207		;  smileSound	=  SMILE_SOUND_LENGTH
   3207  34d0
   3208  34d0		       a9 08		      LDA	#SMILE_SOUND_LENGTH
   3209  34d2		       85 dd		      STA	smileSound
   3210  34d4				   ._SkipSmileSoundSetup1
   3211  34d4							; _SkipSmileSoundSetup1
   3212  34d4
   3213  34d4				   .
   3214  34d4							;
   3215  34d4
   3216  34d4				   .L0208		;  AUDV0  =  SMILE_SOUND_VOLUME
   3217  34d4
   3218  34d4		       a9 06		      LDA	#SMILE_SOUND_VOLUME
   3219  34d6		       85 19		      STA	AUDV0
   3220  34d8				   .L0209		;  AUDC0  =  4
   3221  34d8
   3222  34d8		       a9 04		      LDA	#4
   3223  34da		       85 15		      STA	AUDC0
   3224  34dc				   .L0210		;  AUDF0  =  SMILE_SOUND_FREQUENCY
   3225  34dc
   3226  34dc		       a9 04		      LDA	#SMILE_SOUND_FREQUENCY
   3227  34de		       85 17		      STA	AUDF0
   3228  34e0				   .L0211		;  smileSound	=  smileSound - 1
   3229  34e0
   3230  34e0		       c6 dd		      DEC	smileSound
   3231  34e2				   .
   3232  34e2							;
   3233  34e2
   3234  34e2				   .L0212		;  if smileSound > 0 then return otherbank
   3235  34e2
   3236  34e2		       a9 00		      LDA	#0
   3237  34e4		       c5 dd		      CMP	smileSound
   3238  34e6		       b0 03		      BCS	.skipL0212
   3239  34e8				   .condpart39
   3240  34e8		       4c e0 df 	      JMP	BS_return
   3241  34eb				   .skipL0212
   3242  34eb				   .
   3243  34eb							;
   3244  34eb
   3245  34eb				   ._SkipNoFaceStage1
   3246  34eb							; _SkipNoFaceStage1
   3247  34eb
   3248  34eb				   .L0213		;  AUDV0  =  0
   3249  34eb
   3250  34eb		       a9 00		      LDA	#0
   3251  34ed		       85 19		      STA	AUDV0
   3252  34ef				   .L0214		;  gameStage  =  gameStage + 1
   3253  34ef
   3254  34ef		       e6 e9		      INC	gameStage
   3255  34f1				   .L0215		;  return otherbank
   3256  34f1
   3257  34f1		       4c e0 df 	      JMP	BS_return
   3258  34f4				   ._SkipGameOverLoopStage1
   3259  34f4							; _SkipGameOverLoopStage1
   3260  34f4
   3261  34f4				   .
   3262  34f4							;
   3263  34f4
   3264  34f4				   ._GameOverLoopStage2
   3265  34f4							; _GameOverLoopStage2
   3266  34f4
   3267  34f4				   .L0216		;  if gameStage  >  2 then goto _SkipGameOverLoopStage2
   3268  34f4
   3269  34f4		       a9 02		      LDA	#2
   3270  34f6		       c5 e9		      CMP	gameStage
   3271  34f8		       b0 03		      BCS	.skipL0216
   3272  34fa				   .condpart40
   3273  34fa		       4c 4b 55 	      jmp	._SkipGameOverLoopStage2
   3274  34fd
   3275  34fd				   .skipL0216
   3276  34fd				   .
   3277  34fd							;
   3278  34fd
   3279  34fd				   .L0217		;  if player2y = 200 then goto _SkipNoFaceStage2
   3280  34fd
   3281  34fd		       a5 9b		      LDA	player2y
   3282  34ff		       c9 c8		      CMP	#200
   3283  3501		       d0 03		      BNE	.skipL0217
   3284  3503				   .condpart41
   3285  3503		       4c 42 55 	      jmp	._SkipNoFaceStage2
   3286  3506
   3287  3506				   .skipL0217
   3288  3506				   .
   3289  3506							;
   3290  3506
   3291  3506				   .L0218		;  player2:
   3292  3506
   3293  3506		       a9 e4		      lda	#<(playerpointers+2)
   3294  3508		       8d 50 10 	      sta	DF0LOW
   3295  350b		       a9 01		      lda	#(>(playerpointers+2)) & $0F
   3296  350d		       8d 68 10 	      sta	DF0HI
   3297  3510		       a2 fb		      LDX	#<playerL0218_2
   3298  3512		       8e 78 10 	      STX	DF0WRITE
   3299  3515		       a9 61		      LDA	#((>playerL0218_2) & $0f) | (((>playerL0218_2) / 2) & $70)
   3300  3517		       8d 78 10 	      STA	DF0WRITE
   3301  351a		       a9 0a		      LDA	#10
   3302  351c		       85 a7		      STA	player2height
   3303  351e				   .
   3304  351e							;
   3305  351e
   3306  351e				   .L0219		;  if smileSound > 0 then goto _SkipSmileSoundSetup2
   3307  351e
   3308  351e		       a9 00		      LDA	#0
   3309  3520		       c5 dd		      CMP	smileSound
   3310  3522		       b0 03		      BCS	.skipL0219
   3311  3524				   .condpart42
   3312  3524		       4c 2b 55 	      jmp	._SkipSmileSoundSetup2
   3313  3527
   3314  3527				   .skipL0219
   3315  3527				   .L0220		;  smileSound	=  SMILE_SOUND_LENGTH
   3316  3527
   3317  3527		       a9 08		      LDA	#SMILE_SOUND_LENGTH
   3318  3529		       85 dd		      STA	smileSound
   3319  352b				   ._SkipSmileSoundSetup2
   3320  352b							; _SkipSmileSoundSetup2
   3321  352b
   3322  352b				   .
   3323  352b							;
   3324  352b
   3325  352b				   .L0221		;  AUDV0  =  SMILE_SOUND_VOLUME
   3326  352b
   3327  352b		       a9 06		      LDA	#SMILE_SOUND_VOLUME
   3328  352d		       85 19		      STA	AUDV0
   3329  352f				   .L0222		;  AUDC0  =  4
   3330  352f
   3331  352f		       a9 04		      LDA	#4
   3332  3531		       85 15		      STA	AUDC0
   3333  3533				   .L0223		;  AUDF0  =  SMILE_SOUND_FREQUENCY
   3334  3533
   3335  3533		       a9 04		      LDA	#SMILE_SOUND_FREQUENCY
   3336  3535		       85 17		      STA	AUDF0
   3337  3537				   .L0224		;  smileSound	=  smileSound - 1
   3338  3537
   3339  3537		       c6 dd		      DEC	smileSound
   3340  3539				   .
   3341  3539							;
   3342  3539
   3343  3539				   .L0225		;  if smileSound > 0 then return otherbank
   3344  3539
   3345  3539		       a9 00		      LDA	#0
   3346  353b		       c5 dd		      CMP	smileSound
   3347  353d		       b0 03		      BCS	.skipL0225
   3348  353f				   .condpart43
   3349  353f		       4c e0 df 	      JMP	BS_return
   3350  3542				   .skipL0225
   3351  3542				   .
   3352  3542							;
   3353  3542
   3354  3542				   ._SkipNoFaceStage2
   3355  3542							; _SkipNoFaceStage2
   3356  3542
   3357  3542				   .L0226		;  AUDV0  =  0
   3358  3542
   3359  3542		       a9 00		      LDA	#0
   3360  3544		       85 19		      STA	AUDV0
   3361  3546				   .L0227		;  gameStage  =  gameStage + 1
   3362  3546
   3363  3546		       e6 e9		      INC	gameStage
   3364  3548				   .L0228		;  return otherbank
   3365  3548
   3366  3548		       4c e0 df 	      JMP	BS_return
   3367  354b				   ._SkipGameOverLoopStage2
   3368  354b							; _SkipGameOverLoopStage2
   3369  354b
   3370  354b				   .
   3371  354b							;
   3372  354b
   3373  354b				   ._GameOverLoopStage3
   3374  354b							; _GameOverLoopStage3
   3375  354b
   3376  354b				   .L0229		;  if gameStage  >  3 then goto _SkipGameOverLoopStage3
   3377  354b
   3378  354b		       a9 03		      LDA	#3
   3379  354d		       c5 e9		      CMP	gameStage
   3380  354f		       b0 03		      BCS	.skipL0229
   3381  3551				   .condpart44
   3382  3551		       4c a2 55 	      jmp	._SkipGameOverLoopStage3
   3383  3554
   3384  3554				   .skipL0229
   3385  3554				   .L0230		;  player3:
   3386  3554
   3387  3554		       a9 e6		      lda	#<(playerpointers+4)
   3388  3556		       8d 50 10 	      sta	DF0LOW
   3389  3559		       a9 01		      lda	#(>(playerpointers+4)) & $0F
   3390  355b		       8d 68 10 	      sta	DF0HI
   3391  355e		       a2 05		      LDX	#<playerL0230_3
   3392  3560		       8e 78 10 	      STX	DF0WRITE
   3393  3563		       a9 62		      LDA	#((>playerL0230_3) & $0f) | (((>playerL0230_3) / 2) & $70)
   3394  3565		       8d 78 10 	      STA	DF0WRITE
   3395  3568		       a9 0a		      LDA	#10
   3396  356a		       85 a8		      STA	player3height
   3397  356c				   .
   3398  356c							;
   3399  356c
   3400  356c				   .L0231		;  if player3y = 200 then goto _SkipGameOverLoopStage3
   3401  356c
   3402  356c		       a5 9c		      LDA	player3y
   3403  356e		       c9 c8		      CMP	#200
   3404  3570		       d0 03		      BNE	.skipL0231
   3405  3572				   .condpart45
   3406  3572		       4c a2 55 	      jmp	._SkipGameOverLoopStage3
   3407  3575
   3408  3575				   .skipL0231
   3409  3575				   .
   3410  3575							;
   3411  3575
   3412  3575				   .L0232		;  if smileSound > 0 then goto _SkipSmileSoundSetup3
   3413  3575
   3414  3575		       a9 00		      LDA	#0
   3415  3577		       c5 dd		      CMP	smileSound
   3416  3579		       b0 03		      BCS	.skipL0232
   3417  357b				   .condpart46
   3418  357b		       4c 82 55 	      jmp	._SkipSmileSoundSetup3
   3419  357e
   3420  357e				   .skipL0232
   3421  357e				   .L0233		;  smileSound	=  SMILE_SOUND_LENGTH
   3422  357e
   3423  357e		       a9 08		      LDA	#SMILE_SOUND_LENGTH
   3424  3580		       85 dd		      STA	smileSound
   3425  3582				   ._SkipSmileSoundSetup3
   3426  3582							; _SkipSmileSoundSetup3
   3427  3582
   3428  3582				   .
   3429  3582							;
   3430  3582
   3431  3582				   .L0234		;  AUDV0  =  SMILE_SOUND_VOLUME
   3432  3582
   3433  3582		       a9 06		      LDA	#SMILE_SOUND_VOLUME
   3434  3584		       85 19		      STA	AUDV0
   3435  3586				   .L0235		;  AUDC0  =  4
   3436  3586
   3437  3586		       a9 04		      LDA	#4
   3438  3588		       85 15		      STA	AUDC0
   3439  358a				   .L0236		;  AUDF0  =  SMILE_SOUND_FREQUENCY
   3440  358a
   3441  358a		       a9 04		      LDA	#SMILE_SOUND_FREQUENCY
   3442  358c		       85 17		      STA	AUDF0
   3443  358e				   .L0237		;  smileSound	=  smileSound - 1
   3444  358e
   3445  358e		       c6 dd		      DEC	smileSound
   3446  3590				   .
   3447  3590							;
   3448  3590
   3449  3590				   .L0238		;  if smileSound > 0 then return otherbank
   3450  3590
   3451  3590		       a9 00		      LDA	#0
   3452  3592		       c5 dd		      CMP	smileSound
   3453  3594		       b0 03		      BCS	.skipL0238
   3454  3596				   .condpart47
   3455  3596		       4c e0 df 	      JMP	BS_return
   3456  3599				   .skipL0238
   3457  3599				   .
   3458  3599							;
   3459  3599
   3460  3599				   .L0239		;  AUDV0  =  0
   3461  3599
   3462  3599		       a9 00		      LDA	#0
   3463  359b		       85 19		      STA	AUDV0
   3464  359d				   .L0240		;  gameStage  =  gameStage + 1
   3465  359d
   3466  359d		       e6 e9		      INC	gameStage
   3467  359f				   .L0241		;  return otherbank
   3468  359f
   3469  359f		       4c e0 df 	      JMP	BS_return
   3470  35a2				   ._SkipGameOverLoopStage3
   3471  35a2							; _SkipGameOverLoopStage3
   3472  35a2
   3473  35a2				   .
   3474  35a2							;
   3475  35a2
   3476  35a2				   ._GameOverLoopStage4
   3477  35a2							; _GameOverLoopStage4
   3478  35a2
   3479  35a2				   .L0242		;  if gameStage  >  4 then goto _SkipGameOverLoopStage4
   3480  35a2
   3481  35a2		       a9 04		      LDA	#4
   3482  35a4		       c5 e9		      CMP	gameStage
   3483  35a6		       b0 03		      BCS	.skipL0242
   3484  35a8				   .condpart48
   3485  35a8		       4c f9 55 	      jmp	._SkipGameOverLoopStage4
   3486  35ab
   3487  35ab				   .skipL0242
   3488  35ab				   .L0243		;  player4:
   3489  35ab
   3490  35ab		       a9 e8		      lda	#<(playerpointers+6)
   3491  35ad		       8d 50 10 	      sta	DF0LOW
   3492  35b0		       a9 01		      lda	#(>(playerpointers+6)) & $0F
   3493  35b2		       8d 68 10 	      sta	DF0HI
   3494  35b5		       a2 0f		      LDX	#<playerL0243_4
   3495  35b7		       8e 78 10 	      STX	DF0WRITE
   3496  35ba		       a9 62		      LDA	#((>playerL0243_4) & $0f) | (((>playerL0243_4) / 2) & $70)
   3497  35bc		       8d 78 10 	      STA	DF0WRITE
   3498  35bf		       a9 0a		      LDA	#10
   3499  35c1		       85 a9		      STA	player4height
   3500  35c3				   .
   3501  35c3							;
   3502  35c3
   3503  35c3				   .L0244		;  if player4y = 200 then goto _SkipGameOverLoopStage4
   3504  35c3
   3505  35c3		       a5 9d		      LDA	player4y
   3506  35c5		       c9 c8		      CMP	#200
   3507  35c7		       d0 03		      BNE	.skipL0244
   3508  35c9				   .condpart49
   3509  35c9		       4c f9 55 	      jmp	._SkipGameOverLoopStage4
   3510  35cc
   3511  35cc				   .skipL0244
   3512  35cc				   .
   3513  35cc							;
   3514  35cc
   3515  35cc				   .L0245		;  if smileSound > 0 then goto _SkipSmileSoundSetup4
   3516  35cc
   3517  35cc		       a9 00		      LDA	#0
   3518  35ce		       c5 dd		      CMP	smileSound
   3519  35d0		       b0 03		      BCS	.skipL0245
   3520  35d2				   .condpart50
   3521  35d2		       4c d9 55 	      jmp	._SkipSmileSoundSetup4
   3522  35d5
   3523  35d5				   .skipL0245
   3524  35d5				   .L0246		;  smileSound	=  SMILE_SOUND_LENGTH
   3525  35d5
   3526  35d5		       a9 08		      LDA	#SMILE_SOUND_LENGTH
   3527  35d7		       85 dd		      STA	smileSound
   3528  35d9				   ._SkipSmileSoundSetup4
   3529  35d9							; _SkipSmileSoundSetup4
   3530  35d9
   3531  35d9				   .
   3532  35d9							;
   3533  35d9
   3534  35d9				   .L0247		;  AUDV0  =  SMILE_SOUND_VOLUME
   3535  35d9
   3536  35d9		       a9 06		      LDA	#SMILE_SOUND_VOLUME
   3537  35db		       85 19		      STA	AUDV0
   3538  35dd				   .L0248		;  AUDC0  =  4
   3539  35dd
   3540  35dd		       a9 04		      LDA	#4
   3541  35df		       85 15		      STA	AUDC0
   3542  35e1				   .L0249		;  AUDF0  =  SMILE_SOUND_FREQUENCY
   3543  35e1
   3544  35e1		       a9 04		      LDA	#SMILE_SOUND_FREQUENCY
   3545  35e3		       85 17		      STA	AUDF0
   3546  35e5				   .L0250		;  smileSound	=  smileSound - 1
   3547  35e5
   3548  35e5		       c6 dd		      DEC	smileSound
   3549  35e7				   .
   3550  35e7							;
   3551  35e7
   3552  35e7				   .L0251		;  if smileSound > 0 then return otherbank
   3553  35e7
   3554  35e7		       a9 00		      LDA	#0
   3555  35e9		       c5 dd		      CMP	smileSound
   3556  35eb		       b0 03		      BCS	.skipL0251
   3557  35ed				   .condpart51
   3558  35ed		       4c e0 df 	      JMP	BS_return
   3559  35f0				   .skipL0251
   3560  35f0				   .
   3561  35f0							;
   3562  35f0
   3563  35f0				   .L0252		;  AUDV0  =  0
   3564  35f0
   3565  35f0		       a9 00		      LDA	#0
   3566  35f2		       85 19		      STA	AUDV0
   3567  35f4				   .L0253		;  gameStage  =  gameStage + 1
   3568  35f4
   3569  35f4		       e6 e9		      INC	gameStage
   3570  35f6				   .L0254		;  return otherbank
   3571  35f6
   3572  35f6		       4c e0 df 	      JMP	BS_return
   3573  35f9				   ._SkipGameOverLoopStage4
   3574  35f9							; _SkipGameOverLoopStage4
   3575  35f9
   3576  35f9				   .
   3577  35f9							;
   3578  35f9
   3579  35f9				   ._GameOverLoopStage5
   3580  35f9							; _GameOverLoopStage5
   3581  35f9
   3582  35f9				   .L0255		;  if gameStage  >  5 then goto _SkipGameOverLoopStage5
   3583  35f9
   3584  35f9		       a9 05		      LDA	#5
   3585  35fb		       c5 e9		      CMP	gameStage
   3586  35fd		       b0 03		      BCS	.skipL0255
   3587  35ff				   .condpart52
   3588  35ff		       4c 50 56 	      jmp	._SkipGameOverLoopStage5
   3589  3602
   3590  3602				   .skipL0255
   3591  3602				   .L0256		;  player5:
   3592  3602
   3593  3602		       a9 ea		      lda	#<(playerpointers+8)
   3594  3604		       8d 50 10 	      sta	DF0LOW
   3595  3607		       a9 01		      lda	#(>(playerpointers+8)) & $0F
   3596  3609		       8d 68 10 	      sta	DF0HI
   3597  360c		       a2 19		      LDX	#<playerL0256_5
   3598  360e		       8e 78 10 	      STX	DF0WRITE
   3599  3611		       a9 62		      LDA	#((>playerL0256_5) & $0f) | (((>playerL0256_5) / 2) & $70)
   3600  3613		       8d 78 10 	      STA	DF0WRITE
   3601  3616		       a9 0a		      LDA	#10
   3602  3618		       85 aa		      STA	player5height
   3603  361a				   .
   3604  361a							;
   3605  361a
   3606  361a				   .L0257		;  if player5y = 200 then goto _SkipGameOverLoopStage5
   3607  361a
   3608  361a		       a5 9e		      LDA	player5y
   3609  361c		       c9 c8		      CMP	#200
   3610  361e		       d0 03		      BNE	.skipL0257
   3611  3620				   .condpart53
   3612  3620		       4c 50 56 	      jmp	._SkipGameOverLoopStage5
   3613  3623
   3614  3623				   .skipL0257
   3615  3623				   .
   3616  3623							;
   3617  3623
   3618  3623				   .L0258		;  if smileSound > 0 then goto _SkipSmileSoundSetup5
   3619  3623
   3620  3623		       a9 00		      LDA	#0
   3621  3625		       c5 dd		      CMP	smileSound
   3622  3627		       b0 03		      BCS	.skipL0258
   3623  3629				   .condpart54
   3624  3629		       4c 30 56 	      jmp	._SkipSmileSoundSetup5
   3625  362c
   3626  362c				   .skipL0258
   3627  362c				   .L0259		;  smileSound	=  SMILE_SOUND_LENGTH
   3628  362c
   3629  362c		       a9 08		      LDA	#SMILE_SOUND_LENGTH
   3630  362e		       85 dd		      STA	smileSound
   3631  3630				   ._SkipSmileSoundSetup5
   3632  3630							; _SkipSmileSoundSetup5
   3633  3630
   3634  3630				   .
   3635  3630							;
   3636  3630
   3637  3630				   .L0260		;  AUDV0  =  SMILE_SOUND_VOLUME
   3638  3630
   3639  3630		       a9 06		      LDA	#SMILE_SOUND_VOLUME
   3640  3632		       85 19		      STA	AUDV0
   3641  3634				   .L0261		;  AUDC0  =  4
   3642  3634
   3643  3634		       a9 04		      LDA	#4
   3644  3636		       85 15		      STA	AUDC0
   3645  3638				   .L0262		;  AUDF0  =  SMILE_SOUND_FREQUENCY
   3646  3638
   3647  3638		       a9 04		      LDA	#SMILE_SOUND_FREQUENCY
   3648  363a		       85 17		      STA	AUDF0
   3649  363c				   .L0263		;  smileSound	=  smileSound - 1
   3650  363c
   3651  363c		       c6 dd		      DEC	smileSound
   3652  363e				   .
   3653  363e							;
   3654  363e
   3655  363e				   .L0264		;  if smileSound > 0 then return otherbank
   3656  363e
   3657  363e		       a9 00		      LDA	#0
   3658  3640		       c5 dd		      CMP	smileSound
   3659  3642		       b0 03		      BCS	.skipL0264
   3660  3644				   .condpart55
   3661  3644		       4c e0 df 	      JMP	BS_return
   3662  3647				   .skipL0264
   3663  3647				   .
   3664  3647							;
   3665  3647
   3666  3647				   .L0265		;  AUDV0  =  0
   3667  3647
   3668  3647		       a9 00		      LDA	#0
   3669  3649		       85 19		      STA	AUDV0
   3670  364b				   .L0266		;  gameStage  =  gameStage + 1
   3671  364b
   3672  364b		       e6 e9		      INC	gameStage
   3673  364d				   .L0267		;  return otherbank
   3674  364d
   3675  364d		       4c e0 df 	      JMP	BS_return
   3676  3650				   ._SkipGameOverLoopStage5
   3677  3650							; _SkipGameOverLoopStage5
   3678  3650
   3679  3650				   .
   3680  3650							;
   3681  3650
   3682  3650				   ._GameOverLoopStage6
   3683  3650							; _GameOverLoopStage6
   3684  3650
   3685  3650				   .L0268		;  if gameStage  >  6 then goto _SkipGameOverLoopStage6
   3686  3650
   3687  3650		       a9 06		      LDA	#6
   3688  3652		       c5 e9		      CMP	gameStage
   3689  3654		       b0 03		      BCS	.skipL0268
   3690  3656				   .condpart56
   3691  3656		       4c a7 56 	      jmp	._SkipGameOverLoopStage6
   3692  3659
   3693  3659				   .skipL0268
   3694  3659				   .L0269		;  player6:
   3695  3659
   3696  3659		       a9 ec		      lda	#<(playerpointers+10)
   3697  365b		       8d 50 10 	      sta	DF0LOW
   3698  365e		       a9 01		      lda	#(>(playerpointers+10)) & $0F
   3699  3660		       8d 68 10 	      sta	DF0HI
   3700  3663		       a2 23		      LDX	#<playerL0269_6
   3701  3665		       8e 78 10 	      STX	DF0WRITE
   3702  3668		       a9 62		      LDA	#((>playerL0269_6) & $0f) | (((>playerL0269_6) / 2) & $70)
   3703  366a		       8d 78 10 	      STA	DF0WRITE
   3704  366d		       a9 0a		      LDA	#10
   3705  366f		       85 ab		      STA	player6height
   3706  3671				   .
   3707  3671							;
   3708  3671
   3709  3671				   .L0270		;  if player6y = 200 then goto _SkipGameOverLoopStage6
   3710  3671
   3711  3671		       a5 9f		      LDA	player6y
   3712  3673		       c9 c8		      CMP	#200
   3713  3675		       d0 03		      BNE	.skipL0270
   3714  3677				   .condpart57
   3715  3677		       4c a7 56 	      jmp	._SkipGameOverLoopStage6
   3716  367a
   3717  367a				   .skipL0270
   3718  367a				   .
   3719  367a							;
   3720  367a
   3721  367a				   .L0271		;  if smileSound > 0 then goto _SkipSmileSoundSetup6
   3722  367a
   3723  367a		       a9 00		      LDA	#0
   3724  367c		       c5 dd		      CMP	smileSound
   3725  367e		       b0 03		      BCS	.skipL0271
   3726  3680				   .condpart58
   3727  3680		       4c 87 56 	      jmp	._SkipSmileSoundSetup6
   3728  3683
   3729  3683				   .skipL0271
   3730  3683				   .L0272		;  smileSound	=  SMILE_SOUND_LENGTH
   3731  3683
   3732  3683		       a9 08		      LDA	#SMILE_SOUND_LENGTH
   3733  3685		       85 dd		      STA	smileSound
   3734  3687				   ._SkipSmileSoundSetup6
   3735  3687							; _SkipSmileSoundSetup6
   3736  3687
   3737  3687				   .
   3738  3687							;
   3739  3687
   3740  3687				   .L0273		;  AUDV0  =  SMILE_SOUND_VOLUME
   3741  3687
   3742  3687		       a9 06		      LDA	#SMILE_SOUND_VOLUME
   3743  3689		       85 19		      STA	AUDV0
   3744  368b				   .L0274		;  AUDC0  =  4
   3745  368b
   3746  368b		       a9 04		      LDA	#4
   3747  368d		       85 15		      STA	AUDC0
   3748  368f				   .L0275		;  AUDF0  =  SMILE_SOUND_FREQUENCY
   3749  368f
   3750  368f		       a9 04		      LDA	#SMILE_SOUND_FREQUENCY
   3751  3691		       85 17		      STA	AUDF0
   3752  3693				   .L0276		;  smileSound	=  smileSound - 1
   3753  3693
   3754  3693		       c6 dd		      DEC	smileSound
   3755  3695				   .
   3756  3695							;
   3757  3695
   3758  3695				   .L0277		;  if smileSound > 0 then return otherbank
   3759  3695
   3760  3695		       a9 00		      LDA	#0
   3761  3697		       c5 dd		      CMP	smileSound
   3762  3699		       b0 03		      BCS	.skipL0277
   3763  369b				   .condpart59
   3764  369b		       4c e0 df 	      JMP	BS_return
   3765  369e				   .skipL0277
   3766  369e				   .
   3767  369e							;
   3768  369e
   3769  369e				   .L0278		;  AUDV0  =  0
   3770  369e
   3771  369e		       a9 00		      LDA	#0
   3772  36a0		       85 19		      STA	AUDV0
   3773  36a2				   .L0279		;  gameStage  =  gameStage + 1
   3774  36a2
   3775  36a2		       e6 e9		      INC	gameStage
   3776  36a4				   .L0280		;  return otherbank
   3777  36a4
   3778  36a4		       4c e0 df 	      JMP	BS_return
   3779  36a7				   ._SkipGameOverLoopStage6
   3780  36a7							; _SkipGameOverLoopStage6
   3781  36a7
   3782  36a7				   .
   3783  36a7							;
   3784  36a7
   3785  36a7				   ._GameOverLoopStage7
   3786  36a7							; _GameOverLoopStage7
   3787  36a7
   3788  36a7				   .L0281		;  if gameStage  >  7 then goto _SkipGameOverLoopStage7
   3789  36a7
   3790  36a7		       a9 07		      LDA	#7
   3791  36a9		       c5 e9		      CMP	gameStage
   3792  36ab		       b0 03		      BCS	.skipL0281
   3793  36ad				   .condpart60
   3794  36ad		       4c fe 56 	      jmp	._SkipGameOverLoopStage7
   3795  36b0
   3796  36b0				   .skipL0281
   3797  36b0				   .L0282		;  player7:
   3798  36b0
   3799  36b0		       a9 ee		      lda	#<(playerpointers+12)
   3800  36b2		       8d 50 10 	      sta	DF0LOW
   3801  36b5		       a9 01		      lda	#(>(playerpointers+12)) & $0F
   3802  36b7		       8d 68 10 	      sta	DF0HI
   3803  36ba		       a2 2d		      LDX	#<playerL0282_7
   3804  36bc		       8e 78 10 	      STX	DF0WRITE
   3805  36bf		       a9 62		      LDA	#((>playerL0282_7) & $0f) | (((>playerL0282_7) / 2) & $70)
   3806  36c1		       8d 78 10 	      STA	DF0WRITE
   3807  36c4		       a9 0a		      LDA	#10
   3808  36c6		       85 ac		      STA	player7height
   3809  36c8				   .
   3810  36c8							;
   3811  36c8
   3812  36c8				   .L0283		;  if player7y = 200 then goto _SkipGameOverLoopStage7
   3813  36c8
   3814  36c8		       a5 a0		      LDA	player7y
   3815  36ca		       c9 c8		      CMP	#200
   3816  36cc		       d0 03		      BNE	.skipL0283
   3817  36ce				   .condpart61
   3818  36ce		       4c fe 56 	      jmp	._SkipGameOverLoopStage7
   3819  36d1
   3820  36d1				   .skipL0283
   3821  36d1				   .
   3822  36d1							;
   3823  36d1
   3824  36d1				   .L0284		;  if smileSound > 0 then goto _SkipSmileSoundSetup7
   3825  36d1
   3826  36d1		       a9 00		      LDA	#0
   3827  36d3		       c5 dd		      CMP	smileSound
   3828  36d5		       b0 03		      BCS	.skipL0284
   3829  36d7				   .condpart62
   3830  36d7		       4c de 56 	      jmp	._SkipSmileSoundSetup7
   3831  36da
   3832  36da				   .skipL0284
   3833  36da				   .L0285		;  smileSound	=  SMILE_SOUND_LENGTH
   3834  36da
   3835  36da		       a9 08		      LDA	#SMILE_SOUND_LENGTH
   3836  36dc		       85 dd		      STA	smileSound
   3837  36de				   ._SkipSmileSoundSetup7
   3838  36de							; _SkipSmileSoundSetup7
   3839  36de
   3840  36de				   .
   3841  36de							;
   3842  36de
   3843  36de				   .L0286		;  AUDV0  =  SMILE_SOUND_VOLUME
   3844  36de
   3845  36de		       a9 06		      LDA	#SMILE_SOUND_VOLUME
   3846  36e0		       85 19		      STA	AUDV0
   3847  36e2				   .L0287		;  AUDC0  =  4
   3848  36e2
   3849  36e2		       a9 04		      LDA	#4
   3850  36e4		       85 15		      STA	AUDC0
   3851  36e6				   .L0288		;  AUDF0  =  SMILE_SOUND_FREQUENCY
   3852  36e6
   3853  36e6		       a9 04		      LDA	#SMILE_SOUND_FREQUENCY
   3854  36e8		       85 17		      STA	AUDF0
   3855  36ea				   .L0289		;  smileSound	=  smileSound - 1
   3856  36ea
   3857  36ea		       c6 dd		      DEC	smileSound
   3858  36ec				   .
   3859  36ec							;
   3860  36ec
   3861  36ec				   .L0290		;  if smileSound > 0 then return otherbank
   3862  36ec
   3863  36ec		       a9 00		      LDA	#0
   3864  36ee		       c5 dd		      CMP	smileSound
   3865  36f0		       b0 03		      BCS	.skipL0290
   3866  36f2				   .condpart63
   3867  36f2		       4c e0 df 	      JMP	BS_return
   3868  36f5				   .skipL0290
   3869  36f5				   .
   3870  36f5							;
   3871  36f5
   3872  36f5				   .L0291		;  AUDV0  =  0
   3873  36f5
   3874  36f5		       a9 00		      LDA	#0
   3875  36f7		       85 19		      STA	AUDV0
   3876  36f9				   .L0292		;  gameStage  =  gameStage + 1
   3877  36f9
   3878  36f9		       e6 e9		      INC	gameStage
   3879  36fb				   .L0293		;  return otherbank
   3880  36fb
   3881  36fb		       4c e0 df 	      JMP	BS_return
   3882  36fe				   ._SkipGameOverLoopStage7
   3883  36fe							; _SkipGameOverLoopStage7
   3884  36fe
   3885  36fe				   .
   3886  36fe							;
   3887  36fe
   3888  36fe				   ._GameOverLoopStage8
   3889  36fe							; _GameOverLoopStage8
   3890  36fe
   3891  36fe				   .L0294		;  if gameStage  >  8 then goto _SkipGameOverLoopStage8
   3892  36fe
   3893  36fe		       a9 08		      LDA	#8
   3894  3700		       c5 e9		      CMP	gameStage
   3895  3702		       b0 03		      BCS	.skipL0294
   3896  3704				   .condpart64
   3897  3704		       4c 55 57 	      jmp	._SkipGameOverLoopStage8
   3898  3707
   3899  3707				   .skipL0294
   3900  3707				   .L0295		;  player8:
   3901  3707
   3902  3707		       a9 f0		      lda	#<(playerpointers+14)
   3903  3709		       8d 50 10 	      sta	DF0LOW
   3904  370c		       a9 01		      lda	#(>(playerpointers+14)) & $0F
   3905  370e		       8d 68 10 	      sta	DF0HI
   3906  3711		       a2 37		      LDX	#<playerL0295_8
   3907  3713		       8e 78 10 	      STX	DF0WRITE
   3908  3716		       a9 62		      LDA	#((>playerL0295_8) & $0f) | (((>playerL0295_8) / 2) & $70)
   3909  3718		       8d 78 10 	      STA	DF0WRITE
   3910  371b		       a9 0a		      LDA	#10
   3911  371d		       85 ad		      STA	player8height
   3912  371f				   .
   3913  371f							;
   3914  371f
   3915  371f				   .L0296		;  if player8y = 200 then goto _SkipGameOverLoopStage8
   3916  371f
   3917  371f		       a5 a1		      LDA	player8y
   3918  3721		       c9 c8		      CMP	#200
   3919  3723		       d0 03		      BNE	.skipL0296
   3920  3725				   .condpart65
   3921  3725		       4c 55 57 	      jmp	._SkipGameOverLoopStage8
   3922  3728
   3923  3728				   .skipL0296
   3924  3728				   .
   3925  3728							;
   3926  3728
   3927  3728				   .L0297		;  if smileSound > 0 then goto _SkipSmileSoundSetup8
   3928  3728
   3929  3728		       a9 00		      LDA	#0
   3930  372a		       c5 dd		      CMP	smileSound
   3931  372c		       b0 03		      BCS	.skipL0297
   3932  372e				   .condpart66
   3933  372e		       4c 35 57 	      jmp	._SkipSmileSoundSetup8
   3934  3731
   3935  3731				   .skipL0297
   3936  3731				   .L0298		;  smileSound	=  SMILE_SOUND_LENGTH
   3937  3731
   3938  3731		       a9 08		      LDA	#SMILE_SOUND_LENGTH
   3939  3733		       85 dd		      STA	smileSound
   3940  3735				   ._SkipSmileSoundSetup8
   3941  3735							; _SkipSmileSoundSetup8
   3942  3735
   3943  3735				   .
   3944  3735							;
   3945  3735
   3946  3735				   .L0299		;  AUDV0  =  SMILE_SOUND_VOLUME
   3947  3735
   3948  3735		       a9 06		      LDA	#SMILE_SOUND_VOLUME
   3949  3737		       85 19		      STA	AUDV0
   3950  3739				   .L0300		;  AUDC0  =  4
   3951  3739
   3952  3739		       a9 04		      LDA	#4
   3953  373b		       85 15		      STA	AUDC0
   3954  373d				   .L0301		;  AUDF0  =  SMILE_SOUND_FREQUENCY
   3955  373d
   3956  373d		       a9 04		      LDA	#SMILE_SOUND_FREQUENCY
   3957  373f		       85 17		      STA	AUDF0
   3958  3741				   .L0302		;  smileSound	=  smileSound - 1
   3959  3741
   3960  3741		       c6 dd		      DEC	smileSound
   3961  3743				   .
   3962  3743							;
   3963  3743
   3964  3743				   .L0303		;  if smileSound > 0 then return otherbank
   3965  3743
   3966  3743		       a9 00		      LDA	#0
   3967  3745		       c5 dd		      CMP	smileSound
   3968  3747		       b0 03		      BCS	.skipL0303
   3969  3749				   .condpart67
   3970  3749		       4c e0 df 	      JMP	BS_return
   3971  374c				   .skipL0303
   3972  374c				   .
   3973  374c							;
   3974  374c
   3975  374c				   .L0304		;  AUDV0  =  0
   3976  374c
   3977  374c		       a9 00		      LDA	#0
   3978  374e		       85 19		      STA	AUDV0
   3979  3750				   .L0305		;  gameStage  =  gameStage + 1
   3980  3750
   3981  3750		       e6 e9		      INC	gameStage
   3982  3752				   .L0306		;  return otherbank
   3983  3752
   3984  3752		       4c e0 df 	      JMP	BS_return
   3985  3755				   ._SkipGameOverLoopStage8
   3986  3755							; _SkipGameOverLoopStage8
   3987  3755
   3988  3755				   .
   3989  3755							;
   3990  3755
   3991  3755				   ._GameOverLoopStage9
   3992  3755							; _GameOverLoopStage9
   3993  3755
   3994  3755				   .L0307		;  if gameStage  >  9 then goto _SkipGameOverLoopStage9
   3995  3755
   3996  3755		       a9 09		      LDA	#9
   3997  3757		       c5 e9		      CMP	gameStage
   3998  3759		       b0 03		      BCS	.skipL0307
   3999  375b				   .condpart68
   4000  375b		       4c ac 57 	      jmp	._SkipGameOverLoopStage9
   4001  375e
   4002  375e				   .skipL0307
   4003  375e				   .L0308		;  player9:
   4004  375e
   4005  375e		       a9 f2		      lda	#<(playerpointers+16)
   4006  3760		       8d 50 10 	      sta	DF0LOW
   4007  3763		       a9 01		      lda	#(>(playerpointers+16)) & $0F
   4008  3765		       8d 68 10 	      sta	DF0HI
   4009  3768		       a2 41		      LDX	#<playerL0308_9
   4010  376a		       8e 78 10 	      STX	DF0WRITE
   4011  376d		       a9 62		      LDA	#((>playerL0308_9) & $0f) | (((>playerL0308_9) / 2) & $70)
   4012  376f		       8d 78 10 	      STA	DF0WRITE
   4013  3772		       a9 0a		      LDA	#10
   4014  3774		       85 ae		      STA	player9height
   4015  3776				   .
   4016  3776							;
   4017  3776
   4018  3776				   .L0309		;  if player9y = 200 then goto _SkipGameOverLoopStage9
   4019  3776
   4020  3776		       a5 a2		      LDA	player9y
   4021  3778		       c9 c8		      CMP	#200
   4022  377a		       d0 03		      BNE	.skipL0309
   4023  377c				   .condpart69
   4024  377c		       4c ac 57 	      jmp	._SkipGameOverLoopStage9
   4025  377f
   4026  377f				   .skipL0309
   4027  377f				   .
   4028  377f							;
   4029  377f
   4030  377f				   .L0310		;  if smileSound > 0 then goto _SkipSmileSoundSetup9
   4031  377f
   4032  377f		       a9 00		      LDA	#0
   4033  3781		       c5 dd		      CMP	smileSound
   4034  3783		       b0 03		      BCS	.skipL0310
   4035  3785				   .condpart70
   4036  3785		       4c 8c 57 	      jmp	._SkipSmileSoundSetup9
   4037  3788
   4038  3788				   .skipL0310
   4039  3788				   .L0311		;  smileSound	=  SMILE_SOUND_LENGTH
   4040  3788
   4041  3788		       a9 08		      LDA	#SMILE_SOUND_LENGTH
   4042  378a		       85 dd		      STA	smileSound
   4043  378c				   ._SkipSmileSoundSetup9
   4044  378c							; _SkipSmileSoundSetup9
   4045  378c
   4046  378c				   .
   4047  378c							;
   4048  378c
   4049  378c				   .L0312		;  AUDV0  =  SMILE_SOUND_VOLUME
   4050  378c
   4051  378c		       a9 06		      LDA	#SMILE_SOUND_VOLUME
   4052  378e		       85 19		      STA	AUDV0
   4053  3790				   .L0313		;  AUDC0  =  4
   4054  3790
   4055  3790		       a9 04		      LDA	#4
   4056  3792		       85 15		      STA	AUDC0
   4057  3794				   .L0314		;  AUDF0  =  SMILE_SOUND_FREQUENCY
   4058  3794
   4059  3794		       a9 04		      LDA	#SMILE_SOUND_FREQUENCY
   4060  3796		       85 17		      STA	AUDF0
   4061  3798				   .L0315		;  smileSound	=  smileSound - 1
   4062  3798
   4063  3798		       c6 dd		      DEC	smileSound
   4064  379a				   .
   4065  379a							;
   4066  379a
   4067  379a				   .L0316		;  if smileSound > 0 then return otherbank
   4068  379a
   4069  379a		       a9 00		      LDA	#0
   4070  379c		       c5 dd		      CMP	smileSound
   4071  379e		       b0 03		      BCS	.skipL0316
   4072  37a0				   .condpart71
   4073  37a0		       4c e0 df 	      JMP	BS_return
   4074  37a3				   .skipL0316
   4075  37a3				   .
   4076  37a3							;
   4077  37a3
   4078  37a3				   .L0317		;  AUDV0  =  0
   4079  37a3
   4080  37a3		       a9 00		      LDA	#0
   4081  37a5		       85 19		      STA	AUDV0
   4082  37a7				   .L0318		;  gameStage  =  gameStage + 1
   4083  37a7
   4084  37a7		       e6 e9		      INC	gameStage
   4085  37a9				   .L0319		;  return otherbank
   4086  37a9
   4087  37a9		       4c e0 df 	      JMP	BS_return
   4088  37ac				   ._SkipGameOverLoopStage9
   4089  37ac							; _SkipGameOverLoopStage9
   4090  37ac
   4091  37ac				   .
   4092  37ac							;
   4093  37ac
   4094  37ac				   .L0320		;  return otherbank
   4095  37ac
   4096  37ac		       4c e0 df 	      JMP	BS_return
   4097  37af					      if	ECHO3
      2085 bytes of ROM space left in bank 3
   4098  37af					      echo	"    ",[(start_bank3 - *)]d , "bytes of ROM space left in bank 3")
   4099  37af					      endif
   4100  37af		       00 01	   ECHO3      =	1
   4101  3fd4					      ORG	$3FF4-bscode_length
   4102  3fd4					      RORG	$5FF4-bscode_length
   4103  3fd4		       a2 ff	   start_bank3 ldx	#$ff
   4104  3fd6					      ifconst	FASTFETCH	; using DPC+
   4105  3fd6		       8e 58 10 	      stx	FASTFETCH
   4106  3fd9					      endif
   4107  3fd9		       9a		      txs
   4108  3fda				  -	      if	bankswitch == 64
   4109  3fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   4110  3fda					      else
   4111  3fda		       a9 18		      lda	#>(start-1)
   4112  3fdc					      endif
   4113  3fdc		       48		      pha
   4114  3fdd		       a9 e3		      lda	#<(start-1)
   4115  3fdf		       48		      pha
   4116  3fe0		       48		      pha
   4117  3fe1		       8a		      txa
   4118  3fe2		       48		      pha
   4119  3fe3		       ba		      tsx
   4120  3fe4					      if	bankswitch != 64
   4121  3fe4		       b5 04		      lda	4,x	; get high byte of return address
   4122  3fe6		       2a		      rol
   4123  3fe7		       2a		      rol
   4124  3fe8		       2a		      rol
   4125  3fe9		       2a		      rol
   4126  3fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   4127  3fec		       aa		      tax
   4128  3fed		       e8		      inx
   4129  3fee				  -	      else
   4130  3fee				  -	      lda	4,x	; get high byte of return address
   4131  3fee				  -	      tay
   4132  3fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   4133  3fee				  -	      sta	4,x
   4134  3fee				  -	      tya
   4135  3fee				  -	      lsr
   4136  3fee				  -	      lsr
   4137  3fee				  -	      lsr
   4138  3fee				  -	      lsr
   4139  3fee				  -	      tax
   4140  3fee				  -	      inx
   4141  3fee					      endif
   4142  3fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   4143  3ff1		       68		      pla
   4144  3ff2		       aa		      tax
   4145  3ff3		       68		      pla
   4146  3ff4		       60		      rts
   4147  3ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   4148  3ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   4149  3ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   4150  3ff5					      endif
   4151  3ffc					      ORG	$3FFC
   4152  3ffc					      RORG	$5FFC
   4153  3ffc		       d4 5f		      .word.w	start_bank3
   4154  3ffe		       d4 5f		      .word.w	start_bank3
   4155  4000					      ORG	$4000
   4156  4000					      RORG	$7000
   4157  4000					      repeat	129
   4158  4000		       00		      .byte.b	0
   4157  4000					      repend
   4158  4001		       00		      .byte.b	0
   4157  4001					      repend
   4158  4002		       00		      .byte.b	0
   4157  4002					      repend
   4158  4003		       00		      .byte.b	0
   4157  4003					      repend
   4158  4004		       00		      .byte.b	0
   4157  4004					      repend
   4158  4005		       00		      .byte.b	0
   4157  4005					      repend
   4158  4006		       00		      .byte.b	0
   4157  4006					      repend
   4158  4007		       00		      .byte.b	0
   4157  4007					      repend
   4158  4008		       00		      .byte.b	0
   4157  4008					      repend
   4158  4009		       00		      .byte.b	0
   4157  4009					      repend
   4158  400a		       00		      .byte.b	0
   4157  400a					      repend
   4158  400b		       00		      .byte.b	0
   4157  400b					      repend
   4158  400c		       00		      .byte.b	0
   4157  400c					      repend
   4158  400d		       00		      .byte.b	0
   4157  400d					      repend
   4158  400e		       00		      .byte.b	0
   4157  400e					      repend
   4158  400f		       00		      .byte.b	0
   4157  400f					      repend
   4158  4010		       00		      .byte.b	0
   4157  4010					      repend
   4158  4011		       00		      .byte.b	0
   4157  4011					      repend
   4158  4012		       00		      .byte.b	0
   4157  4012					      repend
   4158  4013		       00		      .byte.b	0
   4157  4013					      repend
   4158  4014		       00		      .byte.b	0
   4157  4014					      repend
   4158  4015		       00		      .byte.b	0
   4157  4015					      repend
   4158  4016		       00		      .byte.b	0
   4157  4016					      repend
   4158  4017		       00		      .byte.b	0
   4157  4017					      repend
   4158  4018		       00		      .byte.b	0
   4157  4018					      repend
   4158  4019		       00		      .byte.b	0
   4157  4019					      repend
   4158  401a		       00		      .byte.b	0
   4157  401a					      repend
   4158  401b		       00		      .byte.b	0
   4157  401b					      repend
   4158  401c		       00		      .byte.b	0
   4157  401c					      repend
   4158  401d		       00		      .byte.b	0
   4157  401d					      repend
   4158  401e		       00		      .byte.b	0
   4157  401e					      repend
   4158  401f		       00		      .byte.b	0
   4157  401f					      repend
   4158  4020		       00		      .byte.b	0
   4157  4020					      repend
   4158  4021		       00		      .byte.b	0
   4157  4021					      repend
   4158  4022		       00		      .byte.b	0
   4157  4022					      repend
   4158  4023		       00		      .byte.b	0
   4157  4023					      repend
   4158  4024		       00		      .byte.b	0
   4157  4024					      repend
   4158  4025		       00		      .byte.b	0
   4157  4025					      repend
   4158  4026		       00		      .byte.b	0
   4157  4026					      repend
   4158  4027		       00		      .byte.b	0
   4157  4027					      repend
   4158  4028		       00		      .byte.b	0
   4157  4028					      repend
   4158  4029		       00		      .byte.b	0
   4157  4029					      repend
   4158  402a		       00		      .byte.b	0
   4157  402a					      repend
   4158  402b		       00		      .byte.b	0
   4157  402b					      repend
   4158  402c		       00		      .byte.b	0
   4157  402c					      repend
   4158  402d		       00		      .byte.b	0
   4157  402d					      repend
   4158  402e		       00		      .byte.b	0
   4157  402e					      repend
   4158  402f		       00		      .byte.b	0
   4157  402f					      repend
   4158  4030		       00		      .byte.b	0
   4157  4030					      repend
   4158  4031		       00		      .byte.b	0
   4157  4031					      repend
   4158  4032		       00		      .byte.b	0
   4157  4032					      repend
   4158  4033		       00		      .byte.b	0
   4157  4033					      repend
   4158  4034		       00		      .byte.b	0
   4157  4034					      repend
   4158  4035		       00		      .byte.b	0
   4157  4035					      repend
   4158  4036		       00		      .byte.b	0
   4157  4036					      repend
   4158  4037		       00		      .byte.b	0
   4157  4037					      repend
   4158  4038		       00		      .byte.b	0
   4157  4038					      repend
   4158  4039		       00		      .byte.b	0
   4157  4039					      repend
   4158  403a		       00		      .byte.b	0
   4157  403a					      repend
   4158  403b		       00		      .byte.b	0
   4157  403b					      repend
   4158  403c		       00		      .byte.b	0
   4157  403c					      repend
   4158  403d		       00		      .byte.b	0
   4157  403d					      repend
   4158  403e		       00		      .byte.b	0
   4157  403e					      repend
   4158  403f		       00		      .byte.b	0
   4157  403f					      repend
   4158  4040		       00		      .byte.b	0
   4157  4040					      repend
   4158  4041		       00		      .byte.b	0
   4157  4041					      repend
   4158  4042		       00		      .byte.b	0
   4157  4042					      repend
   4158  4043		       00		      .byte.b	0
   4157  4043					      repend
   4158  4044		       00		      .byte.b	0
   4157  4044					      repend
   4158  4045		       00		      .byte.b	0
   4157  4045					      repend
   4158  4046		       00		      .byte.b	0
   4157  4046					      repend
   4158  4047		       00		      .byte.b	0
   4157  4047					      repend
   4158  4048		       00		      .byte.b	0
   4157  4048					      repend
   4158  4049		       00		      .byte.b	0
   4157  4049					      repend
   4158  404a		       00		      .byte.b	0
   4157  404a					      repend
   4158  404b		       00		      .byte.b	0
   4157  404b					      repend
   4158  404c		       00		      .byte.b	0
   4157  404c					      repend
   4158  404d		       00		      .byte.b	0
   4157  404d					      repend
   4158  404e		       00		      .byte.b	0
   4157  404e					      repend
   4158  404f		       00		      .byte.b	0
   4157  404f					      repend
   4158  4050		       00		      .byte.b	0
   4157  4050					      repend
   4158  4051		       00		      .byte.b	0
   4157  4051					      repend
   4158  4052		       00		      .byte.b	0
   4157  4052					      repend
   4158  4053		       00		      .byte.b	0
   4157  4053					      repend
   4158  4054		       00		      .byte.b	0
   4157  4054					      repend
   4158  4055		       00		      .byte.b	0
   4157  4055					      repend
   4158  4056		       00		      .byte.b	0
   4157  4056					      repend
   4158  4057		       00		      .byte.b	0
   4157  4057					      repend
   4158  4058		       00		      .byte.b	0
   4157  4058					      repend
   4158  4059		       00		      .byte.b	0
   4157  4059					      repend
   4158  405a		       00		      .byte.b	0
   4157  405a					      repend
   4158  405b		       00		      .byte.b	0
   4157  405b					      repend
   4158  405c		       00		      .byte.b	0
   4157  405c					      repend
   4158  405d		       00		      .byte.b	0
   4157  405d					      repend
   4158  405e		       00		      .byte.b	0
   4157  405e					      repend
   4158  405f		       00		      .byte.b	0
   4157  405f					      repend
   4158  4060		       00		      .byte.b	0
   4157  4060					      repend
   4158  4061		       00		      .byte.b	0
   4157  4061					      repend
   4158  4062		       00		      .byte.b	0
   4157  4062					      repend
   4158  4063		       00		      .byte.b	0
   4157  4063					      repend
   4158  4064		       00		      .byte.b	0
   4157  4064					      repend
   4158  4065		       00		      .byte.b	0
   4157  4065					      repend
   4158  4066		       00		      .byte.b	0
   4157  4066					      repend
   4158  4067		       00		      .byte.b	0
   4157  4067					      repend
   4158  4068		       00		      .byte.b	0
   4157  4068					      repend
   4158  4069		       00		      .byte.b	0
   4157  4069					      repend
   4158  406a		       00		      .byte.b	0
   4157  406a					      repend
   4158  406b		       00		      .byte.b	0
   4157  406b					      repend
   4158  406c		       00		      .byte.b	0
   4157  406c					      repend
   4158  406d		       00		      .byte.b	0
   4157  406d					      repend
   4158  406e		       00		      .byte.b	0
   4157  406e					      repend
   4158  406f		       00		      .byte.b	0
   4157  406f					      repend
   4158  4070		       00		      .byte.b	0
   4157  4070					      repend
   4158  4071		       00		      .byte.b	0
   4157  4071					      repend
   4158  4072		       00		      .byte.b	0
   4157  4072					      repend
   4158  4073		       00		      .byte.b	0
   4157  4073					      repend
   4158  4074		       00		      .byte.b	0
   4157  4074					      repend
   4158  4075		       00		      .byte.b	0
   4157  4075					      repend
   4158  4076		       00		      .byte.b	0
   4157  4076					      repend
   4158  4077		       00		      .byte.b	0
   4157  4077					      repend
   4158  4078		       00		      .byte.b	0
   4157  4078					      repend
   4158  4079		       00		      .byte.b	0
   4157  4079					      repend
   4158  407a		       00		      .byte.b	0
   4157  407a					      repend
   4158  407b		       00		      .byte.b	0
   4157  407b					      repend
   4158  407c		       00		      .byte.b	0
   4157  407c					      repend
   4158  407d		       00		      .byte.b	0
   4157  407d					      repend
   4158  407e		       00		      .byte.b	0
   4157  407e					      repend
   4158  407f		       00		      .byte.b	0
   4157  407f					      repend
   4158  4080		       00		      .byte.b	0
   4159  4081					      repend
   4160  4081					      if	ECHO4
      3923 bytes of ROM space left in bank 4
   4161  4081					      echo	"    ",[(start_bank4 - *)]d , "bytes of ROM space left in bank 4")
   4162  4081					      endif
   4163  4081		       00 01	   ECHO4      =	1
   4164  4fd4					      ORG	$4FF4-bscode_length
   4165  4fd4					      RORG	$7FF4-bscode_length
   4166  4fd4		       a2 ff	   start_bank4 ldx	#$ff
   4167  4fd6					      ifconst	FASTFETCH	; using DPC+
   4168  4fd6		       8e 58 10 	      stx	FASTFETCH
   4169  4fd9					      endif
   4170  4fd9		       9a		      txs
   4171  4fda				  -	      if	bankswitch == 64
   4172  4fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   4173  4fda					      else
   4174  4fda		       a9 18		      lda	#>(start-1)
   4175  4fdc					      endif
   4176  4fdc		       48		      pha
   4177  4fdd		       a9 e3		      lda	#<(start-1)
   4178  4fdf		       48		      pha
   4179  4fe0		       48		      pha
   4180  4fe1		       8a		      txa
   4181  4fe2		       48		      pha
   4182  4fe3		       ba		      tsx
   4183  4fe4					      if	bankswitch != 64
   4184  4fe4		       b5 04		      lda	4,x	; get high byte of return address
   4185  4fe6		       2a		      rol
   4186  4fe7		       2a		      rol
   4187  4fe8		       2a		      rol
   4188  4fe9		       2a		      rol
   4189  4fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   4190  4fec		       aa		      tax
   4191  4fed		       e8		      inx
   4192  4fee				  -	      else
   4193  4fee				  -	      lda	4,x	; get high byte of return address
   4194  4fee				  -	      tay
   4195  4fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   4196  4fee				  -	      sta	4,x
   4197  4fee				  -	      tya
   4198  4fee				  -	      lsr
   4199  4fee				  -	      lsr
   4200  4fee				  -	      lsr
   4201  4fee				  -	      lsr
   4202  4fee				  -	      tax
   4203  4fee				  -	      inx
   4204  4fee					      endif
   4205  4fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   4206  4ff1		       68		      pla
   4207  4ff2		       aa		      tax
   4208  4ff3		       68		      pla
   4209  4ff4		       60		      rts
   4210  4ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   4211  4ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   4212  4ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   4213  4ff5					      endif
   4214  4ffc					      ORG	$4FFC
   4215  4ffc					      RORG	$7FFC
   4216  4ffc		       d4 7f		      .word.w	start_bank4
   4217  4ffe		       d4 7f		      .word.w	start_bank4
   4218  5000					      ORG	$5000
   4219  5000					      RORG	$9000
   4220  5000					      repeat	129
   4221  5000		       00		      .byte.b	0
   4220  5000					      repend
   4221  5001		       00		      .byte.b	0
   4220  5001					      repend
   4221  5002		       00		      .byte.b	0
   4220  5002					      repend
   4221  5003		       00		      .byte.b	0
   4220  5003					      repend
   4221  5004		       00		      .byte.b	0
   4220  5004					      repend
   4221  5005		       00		      .byte.b	0
   4220  5005					      repend
   4221  5006		       00		      .byte.b	0
   4220  5006					      repend
   4221  5007		       00		      .byte.b	0
   4220  5007					      repend
   4221  5008		       00		      .byte.b	0
   4220  5008					      repend
   4221  5009		       00		      .byte.b	0
   4220  5009					      repend
   4221  500a		       00		      .byte.b	0
   4220  500a					      repend
   4221  500b		       00		      .byte.b	0
   4220  500b					      repend
   4221  500c		       00		      .byte.b	0
   4220  500c					      repend
   4221  500d		       00		      .byte.b	0
   4220  500d					      repend
   4221  500e		       00		      .byte.b	0
   4220  500e					      repend
   4221  500f		       00		      .byte.b	0
   4220  500f					      repend
   4221  5010		       00		      .byte.b	0
   4220  5010					      repend
   4221  5011		       00		      .byte.b	0
   4220  5011					      repend
   4221  5012		       00		      .byte.b	0
   4220  5012					      repend
   4221  5013		       00		      .byte.b	0
   4220  5013					      repend
   4221  5014		       00		      .byte.b	0
   4220  5014					      repend
   4221  5015		       00		      .byte.b	0
   4220  5015					      repend
   4221  5016		       00		      .byte.b	0
   4220  5016					      repend
   4221  5017		       00		      .byte.b	0
   4220  5017					      repend
   4221  5018		       00		      .byte.b	0
   4220  5018					      repend
   4221  5019		       00		      .byte.b	0
   4220  5019					      repend
   4221  501a		       00		      .byte.b	0
   4220  501a					      repend
   4221  501b		       00		      .byte.b	0
   4220  501b					      repend
   4221  501c		       00		      .byte.b	0
   4220  501c					      repend
   4221  501d		       00		      .byte.b	0
   4220  501d					      repend
   4221  501e		       00		      .byte.b	0
   4220  501e					      repend
   4221  501f		       00		      .byte.b	0
   4220  501f					      repend
   4221  5020		       00		      .byte.b	0
   4220  5020					      repend
   4221  5021		       00		      .byte.b	0
   4220  5021					      repend
   4221  5022		       00		      .byte.b	0
   4220  5022					      repend
   4221  5023		       00		      .byte.b	0
   4220  5023					      repend
   4221  5024		       00		      .byte.b	0
   4220  5024					      repend
   4221  5025		       00		      .byte.b	0
   4220  5025					      repend
   4221  5026		       00		      .byte.b	0
   4220  5026					      repend
   4221  5027		       00		      .byte.b	0
   4220  5027					      repend
   4221  5028		       00		      .byte.b	0
   4220  5028					      repend
   4221  5029		       00		      .byte.b	0
   4220  5029					      repend
   4221  502a		       00		      .byte.b	0
   4220  502a					      repend
   4221  502b		       00		      .byte.b	0
   4220  502b					      repend
   4221  502c		       00		      .byte.b	0
   4220  502c					      repend
   4221  502d		       00		      .byte.b	0
   4220  502d					      repend
   4221  502e		       00		      .byte.b	0
   4220  502e					      repend
   4221  502f		       00		      .byte.b	0
   4220  502f					      repend
   4221  5030		       00		      .byte.b	0
   4220  5030					      repend
   4221  5031		       00		      .byte.b	0
   4220  5031					      repend
   4221  5032		       00		      .byte.b	0
   4220  5032					      repend
   4221  5033		       00		      .byte.b	0
   4220  5033					      repend
   4221  5034		       00		      .byte.b	0
   4220  5034					      repend
   4221  5035		       00		      .byte.b	0
   4220  5035					      repend
   4221  5036		       00		      .byte.b	0
   4220  5036					      repend
   4221  5037		       00		      .byte.b	0
   4220  5037					      repend
   4221  5038		       00		      .byte.b	0
   4220  5038					      repend
   4221  5039		       00		      .byte.b	0
   4220  5039					      repend
   4221  503a		       00		      .byte.b	0
   4220  503a					      repend
   4221  503b		       00		      .byte.b	0
   4220  503b					      repend
   4221  503c		       00		      .byte.b	0
   4220  503c					      repend
   4221  503d		       00		      .byte.b	0
   4220  503d					      repend
   4221  503e		       00		      .byte.b	0
   4220  503e					      repend
   4221  503f		       00		      .byte.b	0
   4220  503f					      repend
   4221  5040		       00		      .byte.b	0
   4220  5040					      repend
   4221  5041		       00		      .byte.b	0
   4220  5041					      repend
   4221  5042		       00		      .byte.b	0
   4220  5042					      repend
   4221  5043		       00		      .byte.b	0
   4220  5043					      repend
   4221  5044		       00		      .byte.b	0
   4220  5044					      repend
   4221  5045		       00		      .byte.b	0
   4220  5045					      repend
   4221  5046		       00		      .byte.b	0
   4220  5046					      repend
   4221  5047		       00		      .byte.b	0
   4220  5047					      repend
   4221  5048		       00		      .byte.b	0
   4220  5048					      repend
   4221  5049		       00		      .byte.b	0
   4220  5049					      repend
   4221  504a		       00		      .byte.b	0
   4220  504a					      repend
   4221  504b		       00		      .byte.b	0
   4220  504b					      repend
   4221  504c		       00		      .byte.b	0
   4220  504c					      repend
   4221  504d		       00		      .byte.b	0
   4220  504d					      repend
   4221  504e		       00		      .byte.b	0
   4220  504e					      repend
   4221  504f		       00		      .byte.b	0
   4220  504f					      repend
   4221  5050		       00		      .byte.b	0
   4220  5050					      repend
   4221  5051		       00		      .byte.b	0
   4220  5051					      repend
   4221  5052		       00		      .byte.b	0
   4220  5052					      repend
   4221  5053		       00		      .byte.b	0
   4220  5053					      repend
   4221  5054		       00		      .byte.b	0
   4220  5054					      repend
   4221  5055		       00		      .byte.b	0
   4220  5055					      repend
   4221  5056		       00		      .byte.b	0
   4220  5056					      repend
   4221  5057		       00		      .byte.b	0
   4220  5057					      repend
   4221  5058		       00		      .byte.b	0
   4220  5058					      repend
   4221  5059		       00		      .byte.b	0
   4220  5059					      repend
   4221  505a		       00		      .byte.b	0
   4220  505a					      repend
   4221  505b		       00		      .byte.b	0
   4220  505b					      repend
   4221  505c		       00		      .byte.b	0
   4220  505c					      repend
   4221  505d		       00		      .byte.b	0
   4220  505d					      repend
   4221  505e		       00		      .byte.b	0
   4220  505e					      repend
   4221  505f		       00		      .byte.b	0
   4220  505f					      repend
   4221  5060		       00		      .byte.b	0
   4220  5060					      repend
   4221  5061		       00		      .byte.b	0
   4220  5061					      repend
   4221  5062		       00		      .byte.b	0
   4220  5062					      repend
   4221  5063		       00		      .byte.b	0
   4220  5063					      repend
   4221  5064		       00		      .byte.b	0
   4220  5064					      repend
   4221  5065		       00		      .byte.b	0
   4220  5065					      repend
   4221  5066		       00		      .byte.b	0
   4220  5066					      repend
   4221  5067		       00		      .byte.b	0
   4220  5067					      repend
   4221  5068		       00		      .byte.b	0
   4220  5068					      repend
   4221  5069		       00		      .byte.b	0
   4220  5069					      repend
   4221  506a		       00		      .byte.b	0
   4220  506a					      repend
   4221  506b		       00		      .byte.b	0
   4220  506b					      repend
   4221  506c		       00		      .byte.b	0
   4220  506c					      repend
   4221  506d		       00		      .byte.b	0
   4220  506d					      repend
   4221  506e		       00		      .byte.b	0
   4220  506e					      repend
   4221  506f		       00		      .byte.b	0
   4220  506f					      repend
   4221  5070		       00		      .byte.b	0
   4220  5070					      repend
   4221  5071		       00		      .byte.b	0
   4220  5071					      repend
   4221  5072		       00		      .byte.b	0
   4220  5072					      repend
   4221  5073		       00		      .byte.b	0
   4220  5073					      repend
   4221  5074		       00		      .byte.b	0
   4220  5074					      repend
   4221  5075		       00		      .byte.b	0
   4220  5075					      repend
   4221  5076		       00		      .byte.b	0
   4220  5076					      repend
   4221  5077		       00		      .byte.b	0
   4220  5077					      repend
   4221  5078		       00		      .byte.b	0
   4220  5078					      repend
   4221  5079		       00		      .byte.b	0
   4220  5079					      repend
   4221  507a		       00		      .byte.b	0
   4220  507a					      repend
   4221  507b		       00		      .byte.b	0
   4220  507b					      repend
   4221  507c		       00		      .byte.b	0
   4220  507c					      repend
   4221  507d		       00		      .byte.b	0
   4220  507d					      repend
   4221  507e		       00		      .byte.b	0
   4220  507e					      repend
   4221  507f		       00		      .byte.b	0
   4220  507f					      repend
   4221  5080		       00		      .byte.b	0
   4222  5081					      repend
   4223  5081					      if	ECHO5
      3923 bytes of ROM space left in bank 5
   4224  5081					      echo	"    ",[(start_bank5 - *)]d , "bytes of ROM space left in bank 5")
   4225  5081					      endif
   4226  5081		       00 01	   ECHO5      =	1
   4227  5fd4					      ORG	$5FF4-bscode_length
   4228  5fd4					      RORG	$9FF4-bscode_length
   4229  5fd4		       a2 ff	   start_bank5 ldx	#$ff
   4230  5fd6					      ifconst	FASTFETCH	; using DPC+
   4231  5fd6		       8e 58 10 	      stx	FASTFETCH
   4232  5fd9					      endif
   4233  5fd9		       9a		      txs
   4234  5fda				  -	      if	bankswitch == 64
   4235  5fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   4236  5fda					      else
   4237  5fda		       a9 18		      lda	#>(start-1)
   4238  5fdc					      endif
   4239  5fdc		       48		      pha
   4240  5fdd		       a9 e3		      lda	#<(start-1)
   4241  5fdf		       48		      pha
   4242  5fe0		       48		      pha
   4243  5fe1		       8a		      txa
   4244  5fe2		       48		      pha
   4245  5fe3		       ba		      tsx
   4246  5fe4					      if	bankswitch != 64
   4247  5fe4		       b5 04		      lda	4,x	; get high byte of return address
   4248  5fe6		       2a		      rol
   4249  5fe7		       2a		      rol
   4250  5fe8		       2a		      rol
   4251  5fe9		       2a		      rol
   4252  5fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   4253  5fec		       aa		      tax
   4254  5fed		       e8		      inx
   4255  5fee				  -	      else
   4256  5fee				  -	      lda	4,x	; get high byte of return address
   4257  5fee				  -	      tay
   4258  5fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   4259  5fee				  -	      sta	4,x
   4260  5fee				  -	      tya
   4261  5fee				  -	      lsr
   4262  5fee				  -	      lsr
   4263  5fee				  -	      lsr
   4264  5fee				  -	      lsr
   4265  5fee				  -	      tax
   4266  5fee				  -	      inx
   4267  5fee					      endif
   4268  5fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   4269  5ff1		       68		      pla
   4270  5ff2		       aa		      tax
   4271  5ff3		       68		      pla
   4272  5ff4		       60		      rts
   4273  5ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   4274  5ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   4275  5ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   4276  5ff5					      endif
   4277  5ffc					      ORG	$5FFC
   4278  5ffc					      RORG	$9FFC
   4279  5ffc		       d4 9f		      .word.w	start_bank5
   4280  5ffe		       d4 9f		      .word.w	start_bank5
   4281  6000					      ORG	$6000
   4282  6000					      RORG	$B000
   4283  6000					      repeat	129
   4284  6000		       00		      .byte.b	0
   4283  6000					      repend
   4284  6001		       00		      .byte.b	0
   4283  6001					      repend
   4284  6002		       00		      .byte.b	0
   4283  6002					      repend
   4284  6003		       00		      .byte.b	0
   4283  6003					      repend
   4284  6004		       00		      .byte.b	0
   4283  6004					      repend
   4284  6005		       00		      .byte.b	0
   4283  6005					      repend
   4284  6006		       00		      .byte.b	0
   4283  6006					      repend
   4284  6007		       00		      .byte.b	0
   4283  6007					      repend
   4284  6008		       00		      .byte.b	0
   4283  6008					      repend
   4284  6009		       00		      .byte.b	0
   4283  6009					      repend
   4284  600a		       00		      .byte.b	0
   4283  600a					      repend
   4284  600b		       00		      .byte.b	0
   4283  600b					      repend
   4284  600c		       00		      .byte.b	0
   4283  600c					      repend
   4284  600d		       00		      .byte.b	0
   4283  600d					      repend
   4284  600e		       00		      .byte.b	0
   4283  600e					      repend
   4284  600f		       00		      .byte.b	0
   4283  600f					      repend
   4284  6010		       00		      .byte.b	0
   4283  6010					      repend
   4284  6011		       00		      .byte.b	0
   4283  6011					      repend
   4284  6012		       00		      .byte.b	0
   4283  6012					      repend
   4284  6013		       00		      .byte.b	0
   4283  6013					      repend
   4284  6014		       00		      .byte.b	0
   4283  6014					      repend
   4284  6015		       00		      .byte.b	0
   4283  6015					      repend
   4284  6016		       00		      .byte.b	0
   4283  6016					      repend
   4284  6017		       00		      .byte.b	0
   4283  6017					      repend
   4284  6018		       00		      .byte.b	0
   4283  6018					      repend
   4284  6019		       00		      .byte.b	0
   4283  6019					      repend
   4284  601a		       00		      .byte.b	0
   4283  601a					      repend
   4284  601b		       00		      .byte.b	0
   4283  601b					      repend
   4284  601c		       00		      .byte.b	0
   4283  601c					      repend
   4284  601d		       00		      .byte.b	0
   4283  601d					      repend
   4284  601e		       00		      .byte.b	0
   4283  601e					      repend
   4284  601f		       00		      .byte.b	0
   4283  601f					      repend
   4284  6020		       00		      .byte.b	0
   4283  6020					      repend
   4284  6021		       00		      .byte.b	0
   4283  6021					      repend
   4284  6022		       00		      .byte.b	0
   4283  6022					      repend
   4284  6023		       00		      .byte.b	0
   4283  6023					      repend
   4284  6024		       00		      .byte.b	0
   4283  6024					      repend
   4284  6025		       00		      .byte.b	0
   4283  6025					      repend
   4284  6026		       00		      .byte.b	0
   4283  6026					      repend
   4284  6027		       00		      .byte.b	0
   4283  6027					      repend
   4284  6028		       00		      .byte.b	0
   4283  6028					      repend
   4284  6029		       00		      .byte.b	0
   4283  6029					      repend
   4284  602a		       00		      .byte.b	0
   4283  602a					      repend
   4284  602b		       00		      .byte.b	0
   4283  602b					      repend
   4284  602c		       00		      .byte.b	0
   4283  602c					      repend
   4284  602d		       00		      .byte.b	0
   4283  602d					      repend
   4284  602e		       00		      .byte.b	0
   4283  602e					      repend
   4284  602f		       00		      .byte.b	0
   4283  602f					      repend
   4284  6030		       00		      .byte.b	0
   4283  6030					      repend
   4284  6031		       00		      .byte.b	0
   4283  6031					      repend
   4284  6032		       00		      .byte.b	0
   4283  6032					      repend
   4284  6033		       00		      .byte.b	0
   4283  6033					      repend
   4284  6034		       00		      .byte.b	0
   4283  6034					      repend
   4284  6035		       00		      .byte.b	0
   4283  6035					      repend
   4284  6036		       00		      .byte.b	0
   4283  6036					      repend
   4284  6037		       00		      .byte.b	0
   4283  6037					      repend
   4284  6038		       00		      .byte.b	0
   4283  6038					      repend
   4284  6039		       00		      .byte.b	0
   4283  6039					      repend
   4284  603a		       00		      .byte.b	0
   4283  603a					      repend
   4284  603b		       00		      .byte.b	0
   4283  603b					      repend
   4284  603c		       00		      .byte.b	0
   4283  603c					      repend
   4284  603d		       00		      .byte.b	0
   4283  603d					      repend
   4284  603e		       00		      .byte.b	0
   4283  603e					      repend
   4284  603f		       00		      .byte.b	0
   4283  603f					      repend
   4284  6040		       00		      .byte.b	0
   4283  6040					      repend
   4284  6041		       00		      .byte.b	0
   4283  6041					      repend
   4284  6042		       00		      .byte.b	0
   4283  6042					      repend
   4284  6043		       00		      .byte.b	0
   4283  6043					      repend
   4284  6044		       00		      .byte.b	0
   4283  6044					      repend
   4284  6045		       00		      .byte.b	0
   4283  6045					      repend
   4284  6046		       00		      .byte.b	0
   4283  6046					      repend
   4284  6047		       00		      .byte.b	0
   4283  6047					      repend
   4284  6048		       00		      .byte.b	0
   4283  6048					      repend
   4284  6049		       00		      .byte.b	0
   4283  6049					      repend
   4284  604a		       00		      .byte.b	0
   4283  604a					      repend
   4284  604b		       00		      .byte.b	0
   4283  604b					      repend
   4284  604c		       00		      .byte.b	0
   4283  604c					      repend
   4284  604d		       00		      .byte.b	0
   4283  604d					      repend
   4284  604e		       00		      .byte.b	0
   4283  604e					      repend
   4284  604f		       00		      .byte.b	0
   4283  604f					      repend
   4284  6050		       00		      .byte.b	0
   4283  6050					      repend
   4284  6051		       00		      .byte.b	0
   4283  6051					      repend
   4284  6052		       00		      .byte.b	0
   4283  6052					      repend
   4284  6053		       00		      .byte.b	0
   4283  6053					      repend
   4284  6054		       00		      .byte.b	0
   4283  6054					      repend
   4284  6055		       00		      .byte.b	0
   4283  6055					      repend
   4284  6056		       00		      .byte.b	0
   4283  6056					      repend
   4284  6057		       00		      .byte.b	0
   4283  6057					      repend
   4284  6058		       00		      .byte.b	0
   4283  6058					      repend
   4284  6059		       00		      .byte.b	0
   4283  6059					      repend
   4284  605a		       00		      .byte.b	0
   4283  605a					      repend
   4284  605b		       00		      .byte.b	0
   4283  605b					      repend
   4284  605c		       00		      .byte.b	0
   4283  605c					      repend
   4284  605d		       00		      .byte.b	0
   4283  605d					      repend
   4284  605e		       00		      .byte.b	0
   4283  605e					      repend
   4284  605f		       00		      .byte.b	0
   4283  605f					      repend
   4284  6060		       00		      .byte.b	0
   4283  6060					      repend
   4284  6061		       00		      .byte.b	0
   4283  6061					      repend
   4284  6062		       00		      .byte.b	0
   4283  6062					      repend
   4284  6063		       00		      .byte.b	0
   4283  6063					      repend
   4284  6064		       00		      .byte.b	0
   4283  6064					      repend
   4284  6065		       00		      .byte.b	0
   4283  6065					      repend
   4284  6066		       00		      .byte.b	0
   4283  6066					      repend
   4284  6067		       00		      .byte.b	0
   4283  6067					      repend
   4284  6068		       00		      .byte.b	0
   4283  6068					      repend
   4284  6069		       00		      .byte.b	0
   4283  6069					      repend
   4284  606a		       00		      .byte.b	0
   4283  606a					      repend
   4284  606b		       00		      .byte.b	0
   4283  606b					      repend
   4284  606c		       00		      .byte.b	0
   4283  606c					      repend
   4284  606d		       00		      .byte.b	0
   4283  606d					      repend
   4284  606e		       00		      .byte.b	0
   4283  606e					      repend
   4284  606f		       00		      .byte.b	0
   4283  606f					      repend
   4284  6070		       00		      .byte.b	0
   4283  6070					      repend
   4284  6071		       00		      .byte.b	0
   4283  6071					      repend
   4284  6072		       00		      .byte.b	0
   4283  6072					      repend
   4284  6073		       00		      .byte.b	0
   4283  6073					      repend
   4284  6074		       00		      .byte.b	0
   4283  6074					      repend
   4284  6075		       00		      .byte.b	0
   4283  6075					      repend
   4284  6076		       00		      .byte.b	0
   4283  6076					      repend
   4284  6077		       00		      .byte.b	0
   4283  6077					      repend
   4284  6078		       00		      .byte.b	0
   4283  6078					      repend
   4284  6079		       00		      .byte.b	0
   4283  6079					      repend
   4284  607a		       00		      .byte.b	0
   4283  607a					      repend
   4284  607b		       00		      .byte.b	0
   4283  607b					      repend
   4284  607c		       00		      .byte.b	0
   4283  607c					      repend
   4284  607d		       00		      .byte.b	0
   4283  607d					      repend
   4284  607e		       00		      .byte.b	0
   4283  607e					      repend
   4284  607f		       00		      .byte.b	0
   4283  607f					      repend
   4284  6080		       00		      .byte.b	0
   4285  6081					      repend
   4286  6081					      if	ECHO6
      3923 bytes of ROM space left in bank 6
   4287  6081					      echo	"    ",[(start_bank6 - *)]d , "bytes of ROM space left in bank 6")
   4288  6081					      endif
   4289  6081		       00 01	   ECHO6      =	1
   4290  6fd4					      ORG	$6FF4-bscode_length
   4291  6fd4					      RORG	$BFF4-bscode_length
   4292  6fd4		       a2 ff	   start_bank6 ldx	#$ff
   4293  6fd6					      ifconst	FASTFETCH	; using DPC+
   4294  6fd6		       8e 58 10 	      stx	FASTFETCH
   4295  6fd9					      endif
   4296  6fd9		       9a		      txs
   4297  6fda				  -	      if	bankswitch == 64
   4298  6fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   4299  6fda					      else
   4300  6fda		       a9 18		      lda	#>(start-1)
   4301  6fdc					      endif
   4302  6fdc		       48		      pha
   4303  6fdd		       a9 e3		      lda	#<(start-1)
   4304  6fdf		       48		      pha
   4305  6fe0		       48		      pha
   4306  6fe1		       8a		      txa
   4307  6fe2		       48		      pha
   4308  6fe3		       ba		      tsx
   4309  6fe4					      if	bankswitch != 64
   4310  6fe4		       b5 04		      lda	4,x	; get high byte of return address
   4311  6fe6		       2a		      rol
   4312  6fe7		       2a		      rol
   4313  6fe8		       2a		      rol
   4314  6fe9		       2a		      rol
   4315  6fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   4316  6fec		       aa		      tax
   4317  6fed		       e8		      inx
   4318  6fee				  -	      else
   4319  6fee				  -	      lda	4,x	; get high byte of return address
   4320  6fee				  -	      tay
   4321  6fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   4322  6fee				  -	      sta	4,x
   4323  6fee				  -	      tya
   4324  6fee				  -	      lsr
   4325  6fee				  -	      lsr
   4326  6fee				  -	      lsr
   4327  6fee				  -	      lsr
   4328  6fee				  -	      tax
   4329  6fee				  -	      inx
   4330  6fee					      endif
   4331  6fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   4332  6ff1		       68		      pla
   4333  6ff2		       aa		      tax
   4334  6ff3		       68		      pla
   4335  6ff4		       60		      rts
   4336  6ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   4337  6ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   4338  6ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   4339  6ff5					      endif
   4340  6ffc					      ORG	$6FFC
   4341  6ffc					      RORG	$BFFC
   4342  6ffc		       d4 bf		      .word.w	start_bank6
   4343  6ffe		       d4 bf		      .word.w	start_bank6
   4344  7000					      ORG	$7000
   4345  7000					      RORG	$D000
   4346  7000					      repeat	129
   4347  7000		       00		      .byte.b	0
   4346  7000					      repend
   4347  7001		       00		      .byte.b	0
   4346  7001					      repend
   4347  7002		       00		      .byte.b	0
   4346  7002					      repend
   4347  7003		       00		      .byte.b	0
   4346  7003					      repend
   4347  7004		       00		      .byte.b	0
   4346  7004					      repend
   4347  7005		       00		      .byte.b	0
   4346  7005					      repend
   4347  7006		       00		      .byte.b	0
   4346  7006					      repend
   4347  7007		       00		      .byte.b	0
   4346  7007					      repend
   4347  7008		       00		      .byte.b	0
   4346  7008					      repend
   4347  7009		       00		      .byte.b	0
   4346  7009					      repend
   4347  700a		       00		      .byte.b	0
   4346  700a					      repend
   4347  700b		       00		      .byte.b	0
   4346  700b					      repend
   4347  700c		       00		      .byte.b	0
   4346  700c					      repend
   4347  700d		       00		      .byte.b	0
   4346  700d					      repend
   4347  700e		       00		      .byte.b	0
   4346  700e					      repend
   4347  700f		       00		      .byte.b	0
   4346  700f					      repend
   4347  7010		       00		      .byte.b	0
   4346  7010					      repend
   4347  7011		       00		      .byte.b	0
   4346  7011					      repend
   4347  7012		       00		      .byte.b	0
   4346  7012					      repend
   4347  7013		       00		      .byte.b	0
   4346  7013					      repend
   4347  7014		       00		      .byte.b	0
   4346  7014					      repend
   4347  7015		       00		      .byte.b	0
   4346  7015					      repend
   4347  7016		       00		      .byte.b	0
   4346  7016					      repend
   4347  7017		       00		      .byte.b	0
   4346  7017					      repend
   4347  7018		       00		      .byte.b	0
   4346  7018					      repend
   4347  7019		       00		      .byte.b	0
   4346  7019					      repend
   4347  701a		       00		      .byte.b	0
   4346  701a					      repend
   4347  701b		       00		      .byte.b	0
   4346  701b					      repend
   4347  701c		       00		      .byte.b	0
   4346  701c					      repend
   4347  701d		       00		      .byte.b	0
   4346  701d					      repend
   4347  701e		       00		      .byte.b	0
   4346  701e					      repend
   4347  701f		       00		      .byte.b	0
   4346  701f					      repend
   4347  7020		       00		      .byte.b	0
   4346  7020					      repend
   4347  7021		       00		      .byte.b	0
   4346  7021					      repend
   4347  7022		       00		      .byte.b	0
   4346  7022					      repend
   4347  7023		       00		      .byte.b	0
   4346  7023					      repend
   4347  7024		       00		      .byte.b	0
   4346  7024					      repend
   4347  7025		       00		      .byte.b	0
   4346  7025					      repend
   4347  7026		       00		      .byte.b	0
   4346  7026					      repend
   4347  7027		       00		      .byte.b	0
   4346  7027					      repend
   4347  7028		       00		      .byte.b	0
   4346  7028					      repend
   4347  7029		       00		      .byte.b	0
   4346  7029					      repend
   4347  702a		       00		      .byte.b	0
   4346  702a					      repend
   4347  702b		       00		      .byte.b	0
   4346  702b					      repend
   4347  702c		       00		      .byte.b	0
   4346  702c					      repend
   4347  702d		       00		      .byte.b	0
   4346  702d					      repend
   4347  702e		       00		      .byte.b	0
   4346  702e					      repend
   4347  702f		       00		      .byte.b	0
   4346  702f					      repend
   4347  7030		       00		      .byte.b	0
   4346  7030					      repend
   4347  7031		       00		      .byte.b	0
   4346  7031					      repend
   4347  7032		       00		      .byte.b	0
   4346  7032					      repend
   4347  7033		       00		      .byte.b	0
   4346  7033					      repend
   4347  7034		       00		      .byte.b	0
   4346  7034					      repend
   4347  7035		       00		      .byte.b	0
   4346  7035					      repend
   4347  7036		       00		      .byte.b	0
   4346  7036					      repend
   4347  7037		       00		      .byte.b	0
   4346  7037					      repend
   4347  7038		       00		      .byte.b	0
   4346  7038					      repend
   4347  7039		       00		      .byte.b	0
   4346  7039					      repend
   4347  703a		       00		      .byte.b	0
   4346  703a					      repend
   4347  703b		       00		      .byte.b	0
   4346  703b					      repend
   4347  703c		       00		      .byte.b	0
   4346  703c					      repend
   4347  703d		       00		      .byte.b	0
   4346  703d					      repend
   4347  703e		       00		      .byte.b	0
   4346  703e					      repend
   4347  703f		       00		      .byte.b	0
   4346  703f					      repend
   4347  7040		       00		      .byte.b	0
   4346  7040					      repend
   4347  7041		       00		      .byte.b	0
   4346  7041					      repend
   4347  7042		       00		      .byte.b	0
   4346  7042					      repend
   4347  7043		       00		      .byte.b	0
   4346  7043					      repend
   4347  7044		       00		      .byte.b	0
   4346  7044					      repend
   4347  7045		       00		      .byte.b	0
   4346  7045					      repend
   4347  7046		       00		      .byte.b	0
   4346  7046					      repend
   4347  7047		       00		      .byte.b	0
   4346  7047					      repend
   4347  7048		       00		      .byte.b	0
   4346  7048					      repend
   4347  7049		       00		      .byte.b	0
   4346  7049					      repend
   4347  704a		       00		      .byte.b	0
   4346  704a					      repend
   4347  704b		       00		      .byte.b	0
   4346  704b					      repend
   4347  704c		       00		      .byte.b	0
   4346  704c					      repend
   4347  704d		       00		      .byte.b	0
   4346  704d					      repend
   4347  704e		       00		      .byte.b	0
   4346  704e					      repend
   4347  704f		       00		      .byte.b	0
   4346  704f					      repend
   4347  7050		       00		      .byte.b	0
   4346  7050					      repend
   4347  7051		       00		      .byte.b	0
   4346  7051					      repend
   4347  7052		       00		      .byte.b	0
   4346  7052					      repend
   4347  7053		       00		      .byte.b	0
   4346  7053					      repend
   4347  7054		       00		      .byte.b	0
   4346  7054					      repend
   4347  7055		       00		      .byte.b	0
   4346  7055					      repend
   4347  7056		       00		      .byte.b	0
   4346  7056					      repend
   4347  7057		       00		      .byte.b	0
   4346  7057					      repend
   4347  7058		       00		      .byte.b	0
   4346  7058					      repend
   4347  7059		       00		      .byte.b	0
   4346  7059					      repend
   4347  705a		       00		      .byte.b	0
   4346  705a					      repend
   4347  705b		       00		      .byte.b	0
   4346  705b					      repend
   4347  705c		       00		      .byte.b	0
   4346  705c					      repend
   4347  705d		       00		      .byte.b	0
   4346  705d					      repend
   4347  705e		       00		      .byte.b	0
   4346  705e					      repend
   4347  705f		       00		      .byte.b	0
   4346  705f					      repend
   4347  7060		       00		      .byte.b	0
   4346  7060					      repend
   4347  7061		       00		      .byte.b	0
   4346  7061					      repend
   4347  7062		       00		      .byte.b	0
   4346  7062					      repend
   4347  7063		       00		      .byte.b	0
   4346  7063					      repend
   4347  7064		       00		      .byte.b	0
   4346  7064					      repend
   4347  7065		       00		      .byte.b	0
   4346  7065					      repend
   4347  7066		       00		      .byte.b	0
   4346  7066					      repend
   4347  7067		       00		      .byte.b	0
   4346  7067					      repend
   4347  7068		       00		      .byte.b	0
   4346  7068					      repend
   4347  7069		       00		      .byte.b	0
   4346  7069					      repend
   4347  706a		       00		      .byte.b	0
   4346  706a					      repend
   4347  706b		       00		      .byte.b	0
   4346  706b					      repend
   4347  706c		       00		      .byte.b	0
   4346  706c					      repend
   4347  706d		       00		      .byte.b	0
   4346  706d					      repend
   4347  706e		       00		      .byte.b	0
   4346  706e					      repend
   4347  706f		       00		      .byte.b	0
   4346  706f					      repend
   4347  7070		       00		      .byte.b	0
   4346  7070					      repend
   4347  7071		       00		      .byte.b	0
   4346  7071					      repend
   4347  7072		       00		      .byte.b	0
   4346  7072					      repend
   4347  7073		       00		      .byte.b	0
   4346  7073					      repend
   4347  7074		       00		      .byte.b	0
   4346  7074					      repend
   4347  7075		       00		      .byte.b	0
   4346  7075					      repend
   4347  7076		       00		      .byte.b	0
   4346  7076					      repend
   4347  7077		       00		      .byte.b	0
   4346  7077					      repend
   4347  7078		       00		      .byte.b	0
   4346  7078					      repend
   4347  7079		       00		      .byte.b	0
   4346  7079					      repend
   4347  707a		       00		      .byte.b	0
   4346  707a					      repend
   4347  707b		       00		      .byte.b	0
   4346  707b					      repend
   4347  707c		       00		      .byte.b	0
   4346  707c					      repend
   4347  707d		       00		      .byte.b	0
   4346  707d					      repend
   4347  707e		       00		      .byte.b	0
   4346  707e					      repend
   4347  707f		       00		      .byte.b	0
   4346  707f					      repend
   4347  7080		       00		      .byte.b	0
   4348  7081					      repend
   4349  7081							;----------------------------------------
   4350  7081							; Display Data
   4351  7081							;----------------------------------------
   4352  7081							; The Display Data bank is copied into RAM when DPC+ initializes the cartridge.
   4353  7081							; This allows us to manipulate the data during run-time, but have a known
   4354  7081							; starting state when the Atari is first turned on.
   4355  7081							;
   4356  7081							; Unlike normal Atari VCS/2600 sprite definitions, the sprite data in the
   4357  7081							; Display Data bank is stored right-side-up.
   4358  7081							;
   4359  7081							;----------------------------------------
   4360  7081
   4361  7081				   Zeros32
   4362  7081		       00 84	   SOUND_OFF  =	(* & $1fff)/32
   4363  7081				   DisplayDataDigitBlank
   4364  7081		       00		      .byte.b	0	;--
   4365  7082		       00		      .byte.b	0	;--
   4366  7083		       00		      .byte.b	0	;--
   4367  7084		       00		      .byte.b	0	;--
   4368  7085		       00		      .byte.b	0	;--
   4369  7086		       00		      .byte.b	0	;--
   4370  7087		       00		      .byte.b	0	;--
   4371  7088		       00		      .byte.b	0	;--
   4372  7089
   4373  7089							;	align 32
   4374  7089							;Zeros32:
   4375  7089							;SOUND_OFF = (* & $1fff)/32
   4376  7089							;	.byte 0,0,0,0,0,0,0,0
   4377  7089		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   4378  7091		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   4379  7099		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   4380  70a1
   4381  70a1		       00 85	   SINE_WAVE  =	(* & $1fff)/32
   4382  70a1		       03 03 03 04*	      .byte.b	3,3,3,4,4,5,5,5
   4383  70a9		       05 05 05 05*	      .byte.b	5,5,5,5,4,4,3,3
   4384  70b1		       03 02 02 01*	      .byte.b	3,2,2,1,1,0,0,0
   4385  70b9		       00 00 00 00*	      .byte.b	0,0,0,0,1,1,2,2
   4386  70c1
   4387  70e0		       00 00 00 00*	      align	32
   4388  70e0		       00 87	   TRIANGLE_WAVE =	(* & $1fff)/32
   4389  70e0		       00 00 01 01*	      .byte.b	0,0,1,1,1,2,2,2
   4390  70e8		       03 03 03 04*	      .byte.b	3,3,3,4,4,4,5,5
   4391  70f0		       05 05 04 04*	      .byte.b	5,5,4,4,4,3,3,3
   4392  70f8		       02 02 02 01*	      .byte.b	2,2,2,1,1,1,0,0
   4393  7100
   4394  7100					      align	32
   4395  7100		       00 88	   SAWTOOTH_WAVE =	(* & $1fff)/32
   4396  7100		       00 00 00 00*	      .byte.b	0,0,0,0,1,1,1,1
   4397  7108		       01 01 02 02*	      .byte.b	1,1,2,2,2,2,2,2
   4398  7110		       03 03 03 03*	      .byte.b	3,3,3,3,3,3,4,4
   4399  7118		       04 04 04 04*	      .byte.b	4,4,4,4,5,5,5,5
   4400  7120
   4401  7120					      align	32
   4402  7120		       00 89	   SQUARE_WAVE_VOL5 =	(* & $1fff)/32
   4403  7120		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   4404  7128		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   4405  7130		       05 05 05 05*	      .byte.b	5,5,5,5,5,5,5,5
   4406  7138		       05 05 05 05*	      .byte.b	5,5,5,5,5,5,5,5
   4407  7140
   4408  7140					      align	32
   4409  7140		       00 8a	   SQUARE_WAVE_VOL4 =	(* & $1fff)/32
   4410  7140		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   4411  7148		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   4412  7150		       04 04 04 04*	      .byte.b	4,4,4,4,4,4,4,4
   4413  7158		       04 04 04 04*	      .byte.b	4,4,4,4,4,4,4,4
   4414  7160
   4415  7160					      align	32
   4416  7160		       00 8b	   SQUARE_WAVE_VOL3 =	(* & $1fff)/32
   4417  7160		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   4418  7168		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   4419  7170		       03 03 03 03*	      .byte.b	3,3,3,3,3,3,3,3
   4420  7178		       03 03 03 03*	      .byte.b	3,3,3,3,3,3,3,3
   4421  7180
   4422  7180					      align	32
   4423  7180		       00 8c	   NOISE_WAVE =	(* & $1fff)/32
   4424  7180		       07 01 09 0a*	      .byte.b	7, 1, 9,10, 2, 8, 8,14
   4425  7188		       03 0d 08 05*	      .byte.b	3,13, 8, 5,12, 2, 3, 7
   4426  7190		       07 01 08 04*	      .byte.b	7, 1, 8, 4,15, 1,13, 5
   4427  7198		       08 05 0b 06*	      .byte.b	8, 5,11, 6, 8, 7, 9, 2
   4428  71a0
   4429  71a0							; low and high byte of address table (for ROMdata array in C)
   4430  71a0		       4c		      .byte.b	<fetcher_address_table
   4431  71a1		       0d		      .byte.b	((>fetcher_address_table) & $0f) | (((>fetcher_address_table) / 2) & $70)
   4432  71a2		       00		      .byte.b	0
   4433  71a3		       00		      .byte.b	0
   4434  71a4				   FETCHER_BEGIN
   4435  71a4		       10		      .byte.b	16
   4436  71a5		       10		      .byte.b	16
   4437  71a6		       10		      .byte.b	16
   4438  71a7		       10		      .byte.b	16	; to zero-fill on boot
   4439  71a8							;bB.asm
   4440  71a8							; bB.asm file is split here
   4441  71a8				   playerL055_0
   4442  71a8		       3c		      .byte.b	%00111100
   4443  71a9		       7e		      .byte.b	%01111110
   4444  71aa		       ff		      .byte.b	%11111111
   4445  71ab		       bd		      .byte.b	%10111101
   4446  71ac		       99		      .byte.b	%10011001
   4447  71ad		       99		      .byte.b	%10011001
   4448  71ae		       db		      .byte.b	%11011011
   4449  71af		       ff		      .byte.b	%11111111
   4450  71b0		       bd		      .byte.b	%10111101
   4451  71b1		       81		      .byte.b	%10000001
   4452  71b2		       c3		      .byte.b	%11000011
   4453  71b3		       e7		      .byte.b	%11100111
   4454  71b4		       7e		      .byte.b	%01111110
   4455  71b5		       3c		      .byte.b	%00111100
   4456  71b6				   playercolorL056_0
   4457  71b6		       36 36 36 36*	      .byte.b	$36, $36, $36, $36, $36, $36, $36, $36
   4458  71be		       36 36 36 36*	      .byte.b	$36, $36, $36, $36, $36, $36
   4459  71c4		       36 36 36 36*	      .byte.b	$36, $36, $36, $36, $36, $36
   4460  71ca				   playfieldcolorL066
   4461  71ca		       c8		      .byte.b	$C8
   4462  71cb				   backgroundcolorL068
   4463  71cb		       00		      .byte.b	$00
   4464  71cc				   playerL0136_1
   4465  71cc		       3c		      .byte.b	%00111100
   4466  71cd		       7e		      .byte.b	%01111110
   4467  71ce		       db		      .byte.b	%11011011
   4468  71cf		       db		      .byte.b	%11011011
   4469  71d0		       ff		      .byte.b	%11111111
   4470  71d1		       e7		      .byte.b	%11100111
   4471  71d2		       c3		      .byte.b	%11000011
   4472  71d3		       db		      .byte.b	%11011011
   4473  71d4		       7e		      .byte.b	%01111110
   4474  71d5		       3c		      .byte.b	%00111100
   4475  71d6				   playercolorL0137_1
   4476  71d6		       1e 1e 1e 1e*	      .byte.b	$1E, $1E, $1E, $1E, $1E, $1E, $1E, $1E
   4477  71de		       1e 1e 1e 	      .byte.b	$1E, $1E, $1E
   4478  71e1		       1e 1e 1e 	      .byte.b	$1E, $1E, $1E
   4479  71e4				   playerL0190_0
   4480  71e4		       00		      .byte.b	%00000000
   4481  71e5		       00		      .byte.b	%00000000
   4482  71e6		       00		      .byte.b	%00000000
   4483  71e7		       00		      .byte.b	%00000000
   4484  71e8		       00		      .byte.b	%00000000
   4485  71e9		       00		      .byte.b	%00000000
   4486  71ea		       00		      .byte.b	%00000000
   4487  71eb		       00		      .byte.b	%00000000
   4488  71ec		       00		      .byte.b	%00000000
   4489  71ed		       00		      .byte.b	%00000000
   4490  71ee		       00		      .byte.b	%00000000
   4491  71ef		       00		      .byte.b	%00000000
   4492  71f0		       7e		      .byte.b	%01111110
   4493  71f1		       3c		      .byte.b	%00111100
   4494  71f2				   playerL0205_1
   4495  71f2		       3c		      .byte.b	%00111100
   4496  71f3		       7e		      .byte.b	%01111110
   4497  71f4		       db		      .byte.b	%11011011
   4498  71f5		       db		      .byte.b	%11011011
   4499  71f6		       ff		      .byte.b	%11111111
   4500  71f7		       bd		      .byte.b	%10111101
   4501  71f8		       e7		      .byte.b	%11100111
   4502  71f9		       7e		      .byte.b	%01111110
   4503  71fa		       3c		      .byte.b	%00111100
   4504  71fb				   playerL0218_2
   4505  71fb		       3c		      .byte.b	%00111100
   4506  71fc		       7e		      .byte.b	%01111110
   4507  71fd		       db		      .byte.b	%11011011
   4508  71fe		       db		      .byte.b	%11011011
   4509  71ff		       ff		      .byte.b	%11111111
   4510  7200		       bd		      .byte.b	%10111101
   4511  7201		       c3		      .byte.b	%11000011
   4512  7202		       e7		      .byte.b	%11100111
   4513  7203		       7e		      .byte.b	%01111110
   4514  7204		       3c		      .byte.b	%00111100
   4515  7205				   playerL0230_3
   4516  7205		       3c		      .byte.b	%00111100
   4517  7206		       7e		      .byte.b	%01111110
   4518  7207		       db		      .byte.b	%11011011
   4519  7208		       db		      .byte.b	%11011011
   4520  7209		       ff		      .byte.b	%11111111
   4521  720a		       bd		      .byte.b	%10111101
   4522  720b		       c3		      .byte.b	%11000011
   4523  720c		       e7		      .byte.b	%11100111
   4524  720d		       7e		      .byte.b	%01111110
   4525  720e		       3c		      .byte.b	%00111100
   4526  720f				   playerL0243_4
   4527  720f		       3c		      .byte.b	%00111100
   4528  7210		       7e		      .byte.b	%01111110
   4529  7211		       db		      .byte.b	%11011011
   4530  7212		       db		      .byte.b	%11011011
   4531  7213		       ff		      .byte.b	%11111111
   4532  7214		       bd		      .byte.b	%10111101
   4533  7215		       c3		      .byte.b	%11000011
   4534  7216		       e7		      .byte.b	%11100111
   4535  7217		       7e		      .byte.b	%01111110
   4536  7218		       3c		      .byte.b	%00111100
   4537  7219				   playerL0256_5
   4538  7219		       3c		      .byte.b	%00111100
   4539  721a		       7e		      .byte.b	%01111110
   4540  721b		       db		      .byte.b	%11011011
   4541  721c		       db		      .byte.b	%11011011
   4542  721d		       ff		      .byte.b	%11111111
   4543  721e		       bd		      .byte.b	%10111101
   4544  721f		       c3		      .byte.b	%11000011
   4545  7220		       e7		      .byte.b	%11100111
   4546  7221		       7e		      .byte.b	%01111110
   4547  7222		       3c		      .byte.b	%00111100
   4548  7223				   playerL0269_6
   4549  7223		       3c		      .byte.b	%00111100
   4550  7224		       7e		      .byte.b	%01111110
   4551  7225		       db		      .byte.b	%11011011
   4552  7226		       db		      .byte.b	%11011011
   4553  7227		       ff		      .byte.b	%11111111
   4554  7228		       bd		      .byte.b	%10111101
   4555  7229		       c3		      .byte.b	%11000011
   4556  722a		       e7		      .byte.b	%11100111
   4557  722b		       7e		      .byte.b	%01111110
   4558  722c		       3c		      .byte.b	%00111100
   4559  722d				   playerL0282_7
   4560  722d		       3c		      .byte.b	%00111100
   4561  722e		       7e		      .byte.b	%01111110
   4562  722f		       db		      .byte.b	%11011011
   4563  7230		       db		      .byte.b	%11011011
   4564  7231		       ff		      .byte.b	%11111111
   4565  7232		       bd		      .byte.b	%10111101
   4566  7233		       c3		      .byte.b	%11000011
   4567  7234		       e7		      .byte.b	%11100111
   4568  7235		       7e		      .byte.b	%01111110
   4569  7236		       3c		      .byte.b	%00111100
   4570  7237				   playerL0295_8
   4571  7237		       3c		      .byte.b	%00111100
   4572  7238		       7e		      .byte.b	%01111110
   4573  7239		       db		      .byte.b	%11011011
   4574  723a		       db		      .byte.b	%11011011
   4575  723b		       ff		      .byte.b	%11111111
   4576  723c		       bd		      .byte.b	%10111101
   4577  723d		       c3		      .byte.b	%11000011
   4578  723e		       e7		      .byte.b	%11100111
   4579  723f		       7e		      .byte.b	%01111110
   4580  7240		       3c		      .byte.b	%00111100
   4581  7241				   playerL0308_9
   4582  7241		       3c		      .byte.b	%00111100
   4583  7242		       7e		      .byte.b	%01111110
   4584  7243		       db		      .byte.b	%11011011
   4585  7244		       db		      .byte.b	%11011011
   4586  7245		       ff		      .byte.b	%11111111
   4587  7246		       bd		      .byte.b	%10111101
   4588  7247		       c3		      .byte.b	%11000011
   4589  7248		       e7		      .byte.b	%11100111
   4590  7249		       7e		      .byte.b	%01111110
   4591  724a		       3c		      .byte.b	%00111100
   4592  724b					      if	ECHOFIRST
      3465 bytes of ROM space left in graphics bank
   4593  724b					      echo	"    ",[(DPC_graphics_end - *)]d , "bytes of ROM space left in graphics bank")
   4594  724b					      endif
   4595  724b		       00 01	   ECHOFIRST  =	1
   4596  724b
   4597  724b
   4598  7fd4					      ORG	$7FF4-bscode_length
   4599  7fd4					      RORG	$DFF4-bscode_length
   4600  7fd4				   DPC_graphics_end
   4601  7fd4
   4602  7fd4							; every bank has this stuff at the same place
   4603  7fd4							; this code can switch to/from any bank at any entry point
   4604  7fd4							; and can preserve register values
   4605  7fd4							; note: lines not starting with a space are not placed in all banks
   4606  7fd4							;
   4607  7fd4							; line below tells the compiler how long this is - do not remove
   4608  7fd4							;size=32
   4609  7fd4
   4610  7fd4				   begin_bscode
   4611  7fd4		       a2 ff		      ldx	#$ff
   4612  7fd6					      ifconst	FASTFETCH	; using DPC+
   4613  7fd6		       8e 58 10 	      stx	FASTFETCH
   4614  7fd9					      endif
   4615  7fd9		       9a		      txs
   4616  7fda				  -	      if	bankswitch == 64
   4617  7fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   4618  7fda					      else
   4619  7fda		       a9 18		      lda	#>(start-1)
   4620  7fdc					      endif
   4621  7fdc		       48		      pha
   4622  7fdd		       a9 e3		      lda	#<(start-1)
   4623  7fdf		       48		      pha
   4624  7fe0
   4625  7fe0				   BS_return
   4626  7fe0		       48		      pha
   4627  7fe1		       8a		      txa
   4628  7fe2		       48		      pha
   4629  7fe3		       ba		      tsx
   4630  7fe4
   4631  7fe4					      if	bankswitch != 64
   4632  7fe4		       b5 04		      lda	4,x	; get high byte of return address
   4633  7fe6
   4634  7fe6		       2a		      rol
   4635  7fe7		       2a		      rol
   4636  7fe8		       2a		      rol
   4637  7fe9		       2a		      rol
   4638  7fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   4639  7fec		       aa		      tax
   4640  7fed		       e8		      inx
   4641  7fee				  -	      else
   4642  7fee				  -	      lda	4,x	; get high byte of return address
   4643  7fee				  -	      tay
   4644  7fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   4645  7fee				  -	      sta	4,x
   4646  7fee				  -	      tya
   4647  7fee				  -	      lsr
   4648  7fee				  -	      lsr
   4649  7fee				  -	      lsr
   4650  7fee				  -	      lsr
   4651  7fee				  -	      tax
   4652  7fee				  -	      inx
   4653  7fee					      endif
   4654  7fee
   4655  7fee				   BS_jsr
   4656  7fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   4657  7ff1		       68		      pla
   4658  7ff2		       aa		      tax
   4659  7ff3		       68		      pla
   4660  7ff4		       60		      rts
   4661  7ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   4662  7ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   4663  7ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   4664  7ff5					      endif
   4665  8000					      org	$8000
   4666  8000					      rorg	$1000
   4667  8000							; 1K Frequency Table.
   4668  8000							; Fred Quimby, Darrell Spice Jr, Chris Walton 2010
   4669  8000							;
   4670  8000							; The 1K Frequency Table can contain up to 256 frequency values
   4671  8000							;
   4672  8000							; Table entries are defined as 2^32*freq/20000
   4673  8000							;
   4674  8000							; If User ARM code is being used, then the last 512 bytes of the frequency
   4675  8000							; table will no longer be available, reducing the number of frequencies you can
   4676  8000							; use to 128.
   4677  8000
   4678  8000							; piano key frequencies (s = sharp)
   4679  8000
   4680  8000				   .freq_table_start
   4681  8000
   4682  8000		       00 00 00 00	      DC.L	0
   4683  8000		       00 01	   A0	      =	(* & $3ff)/4
   4684  8004		       ac 1c 5a 00	      DC.L	5905580
   4685  8008
   4686  8008		       00 02	   A0s	      =	(* & $3ff)/4
   4687  8008		       68 78 5f 00	      DC.L	6256744
   4688  800c
   4689  800c		       00 03	   B0	      =	(* & $3ff)/4
   4690  800c		       b5 25 65 00	      DC.L	6628789
   4691  8010
   4692  8010		       00 04	   C1	      =	(* & $3ff)/4
   4693  8010		       6e 29 6b 00	      DC.L	7022958
   4694  8014
   4695  8014		       00 05	   C1s	      =	(* & $3ff)/4
   4696  8014		       b5 88 71 00	      DC.L	7440565
   4697  8018
   4698  8018		       00 06	   D1	      =	(* & $3ff)/4
   4699  8018		       fc 48 78 00	      DC.L	7883004
   4700  801c
   4701  801c		       00 07	   D1s	      =	(* & $3ff)/4
   4702  801c		       07 70 7f 00	      DC.L	8351751
   4703  8020
   4704  8020		       00 08	   E1	      =	(* & $3ff)/4
   4705  8020		       f4 03 87 00	      DC.L	8848372
   4706  8024
   4707  8024		       00 09	   F1	      =	(* & $3ff)/4
   4708  8024		       3c 0b 8f 00	      DC.L	9374524
   4709  8028
   4710  8028		       00 0a	   F1s	      =	(* & $3ff)/4
   4711  8028		       ba 8c 97 00	      DC.L	9931962
   4712  802c
   4713  802c		       00 0b	   G1	      =	(* & $3ff)/4
   4714  802c		       b3 8f a0 00	      DC.L	10522547
   4715  8030
   4716  8030		       00 0c	   G1s	      =	(* & $3ff)/4
   4717  8030		       db 1b aa 00	      DC.L	11148251
   4718  8034
   4719  8034		       00 0d	   A1	      =	(* & $3ff)/4
   4720  8034		       58 39 b4 00	      DC.L	11811160
   4721  8038
   4722  8038		       00 0e	   A1s	      =	(* & $3ff)/4
   4723  8038		       d0 f0 be 00	      DC.L	12513488
   4724  803c
   4725  803c		       00 0f	   B1	      =	(* & $3ff)/4
   4726  803c		       6b 4b ca 00	      DC.L	13257579
   4727  8040
   4728  8040		       00 10	   C2	      =	(* & $3ff)/4
   4729  8040		       dc 52 d6 00	      DC.L	14045916
   4730  8044
   4731  8044		       00 11	   C2s	      =	(* & $3ff)/4
   4732  8044		       69 11 e3 00	      DC.L	14881129
   4733  8048
   4734  8048		       00 12	   D2	      =	(* & $3ff)/4
   4735  8048		       f7 91 f0 00	      DC.L	15766007
   4736  804c
   4737  804c		       00 13	   D2s	      =	(* & $3ff)/4
   4738  804c		       0f e0 fe 00	      DC.L	16703503
   4739  8050
   4740  8050		       00 14	   E2	      =	(* & $3ff)/4
   4741  8050		       e9 07 0e 01	      DC.L	17696745
   4742  8054
   4743  8054		       00 15	   F2	      =	(* & $3ff)/4
   4744  8054		       78 16 1e 01	      DC.L	18749048
   4745  8058
   4746  8058		       00 16	   F2s	      =	(* & $3ff)/4
   4747  8058		       74 19 2f 01	      DC.L	19863924
   4748  805c
   4749  805c		       00 17	   G2	      =	(* & $3ff)/4
   4750  805c		       67 1f 41 01	      DC.L	21045095
   4751  8060
   4752  8060		       00 18	   G2s	      =	(* & $3ff)/4
   4753  8060		       b5 37 54 01	      DC.L	22296501
   4754  8064
   4755  8064		       00 19	   A2	      =	(* & $3ff)/4
   4756  8064		       b0 72 68 01	      DC.L	23622320
   4757  8068
   4758  8068		       00 1a	   A2s	      =	(* & $3ff)/4
   4759  8068		       a0 e1 7d 01	      DC.L	25026976
   4760  806c
   4761  806c		       00 1b	   B2	      =	(* & $3ff)/4
   4762  806c		       d6 96 94 01	      DC.L	26515158
   4763  8070
   4764  8070		       00 1c	   C3	      =	(* & $3ff)/4
   4765  8070		       b7 a5 ac 01	      DC.L	28091831
   4766  8074
   4767  8074		       00 1d	   C3s	      =	(* & $3ff)/4
   4768  8074		       d2 22 c6 01	      DC.L	29762258
   4769  8078
   4770  8078		       00 1e	   D3	      =	(* & $3ff)/4
   4771  8078		       ee 23 e1 01	      DC.L	31532014
   4772  807c
   4773  807c		       00 1f	   D3s	      =	(* & $3ff)/4
   4774  807c		       1d c0 fd 01	      DC.L	33407005
   4775  8080
   4776  8080		       00 20	   E3	      =	(* & $3ff)/4
   4777  8080		       d1 0f 1c 02	      DC.L	35393489
   4778  8084
   4779  8084		       00 21	   F3	      =	(* & $3ff)/4
   4780  8084		       f0 2c 3c 02	      DC.L	37498096
   4781  8088
   4782  8088		       00 22	   F3s	      =	(* & $3ff)/4
   4783  8088		       e9 32 5e 02	      DC.L	39727849
   4784  808c
   4785  808c		       00 23	   G3	      =	(* & $3ff)/4
   4786  808c		       cd 3e 82 02	      DC.L	42090189
   4787  8090
   4788  8090		       00 24	   G3s	      =	(* & $3ff)/4
   4789  8090		       6a 6f a8 02	      DC.L	44593002
   4790  8094
   4791  8094		       00 25	   A3	      =	(* & $3ff)/4
   4792  8094		       60 e5 d0 02	      DC.L	47244640
   4793  8098
   4794  8098		       00 26	   A3s	      =	(* & $3ff)/4
   4795  8098		       41 c3 fb 02	      DC.L	50053953
   4796  809c
   4797  809c		       00 27	   B3	      =	(* & $3ff)/4
   4798  809c		       ac 2d 29 03	      DC.L	53030316
   4799  80a0
   4800  80a0		       00 28	   C4	      =	(* & $3ff)/4
   4801  80a0		       6e 4b 59 03	      DC.L	56183662
   4802  80a4
   4803  80a4		       00 29	   C4s	      =	(* & $3ff)/4
   4804  80a4		       a5 45 8c 03	      DC.L	59524517
   4805  80a8
   4806  80a8		       00 2a	   D4	      =	(* & $3ff)/4
   4807  80a8		       dd 47 c2 03	      DC.L	63064029
   4808  80ac
   4809  80ac		       00 2b	   D4s	      =	(* & $3ff)/4
   4810  80ac		       3b 80 fb 03	      DC.L	66814011
   4811  80b0
   4812  80b0		       00 2c	   E4	      =	(* & $3ff)/4
   4813  80b0		       a3 1f 38 04	      DC.L	70786979
   4814  80b4
   4815  80b4		       00 2d	   F4	      =	(* & $3ff)/4
   4816  80b4		       e0 59 78 04	      DC.L	74996192
   4817  80b8
   4818  80b8		       00 2e	   F4s	      =	(* & $3ff)/4
   4819  80b8		       d1 65 bc 04	      DC.L	79455697
   4820  80bc
   4821  80bc		       00 2f	   G4	      =	(* & $3ff)/4
   4822  80bc		       9b 7d 04 05	      DC.L	84180379
   4823  80c0
   4824  80c0		       00 30	   G4s	      =	(* & $3ff)/4
   4825  80c0		       d5 de 50 05	      DC.L	89186005
   4826  80c4
   4827  80c4		       00 31	   A4	      =	(* & $3ff)/4
   4828  80c4		       c1 ca a1 05	      DC.L	94489281
   4829  80c8
   4830  80c8		       00 32	   A4s	      =	(* & $3ff)/4
   4831  80c8		       82 86 f7 05	      DC.L	100107906
   4832  80cc
   4833  80cc		       00 33	   B4	      =	(* & $3ff)/4
   4834  80cc		       57 5b 52 06	      DC.L	106060631
   4835  80d0
   4836  80d0		       00 34	   C5	      =	(* & $3ff)/4
   4837  80d0		       dd 96 b2 06	      DC.L	112367325
   4838  80d4
   4839  80d4		       00 35	   C5s	      =	(* & $3ff)/4
   4840  80d4		       4a 8b 18 07	      DC.L	119049034
   4841  80d8
   4842  80d8		       00 36	   D5	      =	(* & $3ff)/4
   4843  80d8		       b9 8f 84 07	      DC.L	126128057
   4844  80dc
   4845  80dc		       00 37	   D5s	      =	(* & $3ff)/4
   4846  80dc		       76 00 f7 07	      DC.L	133628022
   4847  80e0
   4848  80e0		       00 38	   E5	      =	(* & $3ff)/4
   4849  80e0		       46 3f 70 08	      DC.L	141573958
   4850  80e4
   4851  80e4		       00 39	   F5	      =	(* & $3ff)/4
   4852  80e4		       bf b3 f0 08	      DC.L	149992383
   4853  80e8
   4854  80e8		       00 3a	   F5s	      =	(* & $3ff)/4
   4855  80e8		       a3 cb 78 09	      DC.L	158911395
   4856  80ec
   4857  80ec		       00 3b	   G5	      =	(* & $3ff)/4
   4858  80ec		       36 fb 08 0a	      DC.L	168360758
   4859  80f0
   4860  80f0		       00 3c	   G5s	      =	(* & $3ff)/4
   4861  80f0		       a9 bd a1 0a	      DC.L	178372009
   4862  80f4
   4863  80f4		       00 3d	   A5	      =	(* & $3ff)/4
   4864  80f4		       81 95 43 0b	      DC.L	188978561
   4865  80f8
   4866  80f8		       00 3e	   A5s	      =	(* & $3ff)/4
   4867  80f8		       03 0d ef 0b	      DC.L	200215811
   4868  80fc
   4869  80fc		       00 3f	   B5	      =	(* & $3ff)/4
   4870  80fc		       af b6 a4 0c	      DC.L	212121263
   4871  8100
   4872  8100		       00 40	   C6	      =	(* & $3ff)/4
   4873  8100		       b9 2d 65 0d	      DC.L	224734649
   4874  8104
   4875  8104		       00 41	   C6s	      =	(* & $3ff)/4
   4876  8104		       93 16 31 0e	      DC.L	238098067
   4877  8108
   4878  8108		       00 42	   D6	      =	(* & $3ff)/4
   4879  8108		       73 1f 09 0f	      DC.L	252256115
   4880  810c
   4881  810c		       00 43	   D6s	      =	(* & $3ff)/4
   4882  810c		       ec 00 ee 0f	      DC.L	267256044
   4883  8110
   4884  8110		       00 44	   E6	      =	(* & $3ff)/4
   4885  8110		       8b 7e e0 10	      DC.L	283147915
   4886  8114
   4887  8114		       00 45	   F6	      =	(* & $3ff)/4
   4888  8114		       7f 67 e1 11	      DC.L	299984767
   4889  8118
   4890  8118		       00 46	   F6s	      =	(* & $3ff)/4
   4891  8118		       45 97 f1 12	      DC.L	317822789
   4892  811c
   4893  811c		       00 47	   G6	      =	(* & $3ff)/4
   4894  811c		       6c f6 11 14	      DC.L	336721516
   4895  8120
   4896  8120		       00 48	   G6s	      =	(* & $3ff)/4
   4897  8120		       53 7b 43 15	      DC.L	356744019
   4898  8124
   4899  8124		       00 49	   A6	      =	(* & $3ff)/4
   4900  8124		       02 2b 87 16	      DC.L	377957122
   4901  8128
   4902  8128		       00 4a	   A6s	      =	(* & $3ff)/4
   4903  8128		       06 1a de 17	      DC.L	400431622
   4904  812c
   4905  812c		       00 4b	   B6	      =	(* & $3ff)/4
   4906  812c		       5d 6d 49 19	      DC.L	424242525
   4907  8130
   4908  8130		       00 4c	   C7	      =	(* & $3ff)/4
   4909  8130		       73 5b ca 1a	      DC.L	449469299
   4910  8134
   4911  8134		       00 4d	   C7s	      =	(* & $3ff)/4
   4912  8134		       26 2d 62 1c	      DC.L	476196134
   4913  8138
   4914  8138		       00 4e	   D7	      =	(* & $3ff)/4
   4915  8138		       e6 3e 12 1e	      DC.L	504512230
   4916  813c
   4917  813c		       00 4f	   D7s	      =	(* & $3ff)/4
   4918  813c		       d8 01 dc 1f	      DC.L	534512088
   4919  8140
   4920  8140		       00 50	   E7	      =	(* & $3ff)/4
   4921  8140		       17 fd c0 21	      DC.L	566295831
   4922  8144
   4923  8144		       00 51	   F7	      =	(* & $3ff)/4
   4924  8144		       fd ce c2 23	      DC.L	599969533
   4925  8148
   4926  8148		       00 52	   F7s	      =	(* & $3ff)/4
   4927  8148		       8a 2e e3 25	      DC.L	635645578
   4928  814c
   4929  814c		       00 53	   G7	      =	(* & $3ff)/4
   4930  814c		       d7 ec 23 28	      DC.L	673443031
   4931  8150
   4932  8150		       00 54	   G7s	      =	(* & $3ff)/4
   4933  8150		       a6 f6 86 2a	      DC.L	713488038
   4934  8154
   4935  8154		       00 55	   A7	      =	(* & $3ff)/4
   4936  8154		       04 56 0e 2d	      DC.L	755914244
   4937  8158
   4938  8158		       00 56	   A7s	      =	(* & $3ff)/4
   4939  8158		       0c 34 bc 2f	      DC.L	800863244
   4940  815c
   4941  815c		       00 57	   B7	      =	(* & $3ff)/4
   4942  815c		       bb da 92 32	      DC.L	848485051
   4943  8160
   4944  8160		       00 58	   C8	      =	(* & $3ff)/4
   4945  8160		       e5 b6 94 35	      DC.L	898938597
   4946  8164
   4947  8164							;values for 89-255 may go here
   4948  8164
   4949  8164					      if	(* <= $1400)
   4950  8164		       00 00 00 00*	      ds	($1400-*)	; pad out remaining space in frequency table
   4951  8400				  -	      else
   4952  8400				  -	      echo	"FATAL ERROR - Frequency table exceeds 1K"
   4953  8400				  -	      err
   4954  8400					      endif
